<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LoRA &amp;&amp; QLoRA</title>
    <link href="/2023/08/18/LoRA%20&amp;&amp;%20QLoRA/"/>
    <url>/2023/08/18/LoRA%20&amp;&amp;%20QLoRA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前置假设"><a href="#1-前置假设" class="headerlink" title="1 前置假设"></a>1 前置假设</h1><ul><li>LoRA的灵感来自于另一篇论文：Intrinsic Dimensionality Explains the Effectiveness of Language Model Fine-Tuning</li><li>这篇论文认为，<strong>在参数更新时，不需要对参数的整个向量空间进行更新，只需要随机映射到他的一个子空间（一般都是直接指列空间的子空间），在这个子空间上参数更新，就能达到十分接近的效果，能达到这个要求的最小子空间维度即为“intrinsic dimension”</strong></li><li>设原参数为<script type="math/tex">W \in \mathbb{R}^{D \times m}</script>，其列空间为<script type="math/tex">\theta^m = [\theta_0, ..., \theta_{m-1}]</script>，那么参数更新公式则变为了：</li></ul><script type="math/tex; mode=display">\theta^m = \theta^m + P(\theta^n)</script><p>其中<script type="math/tex">\theta^n \in \mathbb{R}^{D \times n}</script>表示映射后的子空间，P表示<script type="math/tex">\mathbb{R}^n \rightarrow \mathbb{R}^m</script>的随机映射，用矩阵表示为右乘<script type="math/tex">M \in \mathbb{R}^{n \times m}</script>。<strong>子空间维度n即为“intrinsic dimension”</strong></p><ul><li><p>随机映射P有多种，包括随机线性映射、随机稀疏线性映射、Fastfood Transform等。并且<script type="math/tex">\theta^n</script>是初始化为全0以保持开始时和预训练权重一致</p></li><li><p>这篇文章还有其他结论：</p></li></ul><blockquote><ol><li>预训练可以降低intrinsic dimension</li><li>大模型通常拥有更小的intrinsic dimension</li></ol></blockquote><h1 id="2-LoRA"><a href="#2-LoRA" class="headerlink" title="2 LoRA"></a>2 LoRA</h1><h3 id="2-1-LoRA定义"><a href="#2-1-LoRA定义" class="headerlink" title="2.1 LoRA定义"></a>2.1 LoRA定义</h3><ul><li><p>LoRA认为<strong>权重的更新量同样拥有一个intrinsic dimension（记为r），所以将权重更新量<script type="math/tex">\Delta W</script>分解为两个矩阵<script type="math/tex">\Delta W = BA</script></strong></p></li><li><p>在计算时，将原预训练权重的activation加上这个BA的activation，得到新的activation：</p></li></ul><script type="math/tex; mode=display">h=W_{0} x+\Delta W x=W_{0} x+B A x</script><p>其中<script type="math/tex">W_0 \in \mathbb{R}^{d \times k}</script>，<script type="math/tex">B \in \mathbb{R}^{d \times r}</script>表示映射后的子空间参数矩阵，<script type="math/tex">A \in \mathbb{R}^{r \times k}</script>表示两个空间的映射矩阵，并且<script type="math/tex">r \ll \min (d, k)</script></p><ul><li>在参数初始化时是将B设为全0，A服从<script type="math/tex">\mathcal{N}\left(0, \sigma^{2}\right)</script>：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808143823489.png" alt="image-20230808143823489" style="zoom:60%;" /></p><h3 id="2-2-LoRA的优点"><a href="#2-2-LoRA的优点" class="headerlink" title="2.2 LoRA的优点"></a>2.2 LoRA的优点</h3><ul><li><strong>在训练时，是将原参数冻结，然后只更新A、B矩阵</strong>，由于<script type="math/tex">r \ll \min (d, k)</script>，所以用LoRA微调，需要更新的参数很少，并且尽管可更新参数变小了，但是效果却不差</li><li>LoRA没有像Adapter那样的额外推理时间消耗，<strong>在推理部署时，是直接将BA的结果加到原参数<script type="math/tex">W_0</script>上，再部署上去</strong></li></ul><h3 id="2-3-对比实验"><a href="#2-3-对比实验" class="headerlink" title="2.3 对比实验"></a>2.3 对比实验</h3><ul><li>LoRA可以应用的地方有5个，分别是Attention Layer里的<script type="math/tex">W_q, W_k, W_v,W_o</script>矩阵，以及MLP中的权重矩阵。<strong>本次实验并未对MLP的权重矩阵进行LoRA优化</strong></li><li><strong>并且在大部分对比实验中，都是仅对<script type="math/tex">W_q, W_v</script>进行<script type="math/tex">r=4</script>的优化</strong></li></ul><h5 id="2-3-1-和其他微调方法的对比"><a href="#2-3-1-和其他微调方法的对比" class="headerlink" title="2.3.1 和其他微调方法的对比"></a>2.3.1 和其他微调方法的对比</h5><ul><li>RoBERTa结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808172556109.png" alt="image-20230808172556109" style="zoom:40%;" /></p><ul><li>GPT-2结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808172638176.png" alt="image-20230808172638176" style="zoom:40%;" /></p><ul><li>GPT-3结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808172719697.png" alt="image-20230808172719697" style="zoom:40%;" /></p><ul><li>此外，还对比了当可训练参数逐渐增多时，各种微调方法的结果变化（GPT-3上）：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808172934424.png" alt="image-20230808172934424" style="zoom:50%;" /></p><h5 id="2-3-2-对哪些矩阵采用LoRA"><a href="#2-3-2-对哪些矩阵采用LoRA" class="headerlink" title="2.3.2 对哪些矩阵采用LoRA"></a>2.3.2 对哪些矩阵采用LoRA</h5><ul><li>作者在相同的可训练参数量的情况下，实验了不同的矩阵和不同的r：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808173756918.png" alt="image-20230808173756918" style="zoom:45%;" /></p><ul><li>可以发现，<strong>同时对<script type="math/tex">W_q, W_v</script>进行优化，取得的效果最好</strong></li><li>并且对比单用<script type="math/tex">W_q</script>或者单用<script type="math/tex">W_k</script>的情况，发现<strong>对于每个矩阵<script type="math/tex">r=4</script>已经能获取足够的特征，这时将LoRA应用更多的矩阵比单纯提升<script type="math/tex">r</script>更有用</strong></li></ul><h5 id="2-3-3-最佳r"><a href="#2-3-3-最佳r" class="headerlink" title="2.3.3 最佳r"></a>2.3.3 最佳r</h5><ul><li>作者实验了应用不同的矩阵和不同的r：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230808174526241.png" alt="image-20230808174526241" style="zoom:45%;" /></p><ul><li>表明在很小的r上，LoRA已经能够取得很好的结果</li></ul><h3 id="2-4-Empirical-Analysis"><a href="#2-4-Empirical-Analysis" class="headerlink" title="2.4 Empirical Analysis"></a>2.4 Empirical Analysis</h3><h5 id="2-4-1-如何对比子空间的相似度"><a href="#2-4-1-如何对比子空间的相似度" class="headerlink" title="2.4.1 如何对比子空间的相似度"></a>2.4.1 如何对比子空间的相似度</h5><ul><li>给定两个矩阵<script type="math/tex">A, B</script>，而<script type="math/tex">U_A^i \in \mathbb{R}^{d \times i}</script>表示A的左或右奇异矩阵的前<script type="math/tex">i</script>列组成的矩阵，<script type="math/tex">U_B^j \in \mathbb{R}^{d \times j}</script>同理，则这两个奇异矩阵的子空间的相似度可以定义为：</li></ul><script type="math/tex; mode=display">\phi(A, B, i, j)=\psi\left(U_{A}^{i}, U_{B}^{j}\right)=\frac{\left\|U_{A}^{i \top} U_{B}\right\|_{F}^{2}}{\min \{i, j\}}</script><ul><li>具体到LoRA上面，<script type="math/tex">\Delta W = BA</script>，我们对子空间的分析可以采用<strong>B的左奇异矩阵</strong>或者<strong>A的右奇异矩阵</strong>，论文是采用后者来分析的</li></ul><h5 id="2-4-2-不同r所产生的子空间"><a href="#2-4-2-不同r所产生的子空间" class="headerlink" title="2.4.2 不同r所产生的子空间"></a>2.4.2 不同r所产生的子空间</h5><ul><li>作者采用相同的预训练权重，用<script type="math/tex">r=8</script>和<script type="math/tex">r=64</script>分别微调了一遍，并得到了两个A矩阵<script type="math/tex">A_{r=8}, A_{r=64}</script>，以及他们的右奇异矩阵<script type="math/tex">U_{A_{r=8}}, U_{A_{r=64}}</script>，并计算他们不同子空间的相似度：</li></ul><script type="math/tex; mode=display">\phi\left(A_{r=8}, A_{r=64}, i, j\right)=\frac{\left\|U_{A_{r=8}}^{i \top} U_{A_{r=64}}^{j}\right\|_{F}^{2}}{\min (i, j)} \in[0,1]</script><ul><li>得到以下结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230810153943129.png" alt="image-20230810153943129" style="zoom:50%;" /></p><p>右边两图对应左边两图的左下角空白处</p><ul><li>分析结论：<strong>在<script type="math/tex">i, j</script>较小时，是由top的几个奇异向量组成的子空间，在不同的r下，这个子空间的相似度是非常高的（特别是在<script type="math/tex">i=1</script>或<script type="math/tex">j=1</script>时，子空间的相似度甚至大于0.5）。说明top的几个奇异向量组成的子空间才是最主要的，这也解释了为什么GPT-3用<script type="math/tex">r=1</script>都能取得很不错的结果</strong></li></ul><h5 id="2-4-3-Delta-W-q和-Delta-W-v的对比"><a href="#2-4-3-Delta-W-q和-Delta-W-v的对比" class="headerlink" title="2.4.3 \Delta W_q和\Delta W_v的对比"></a>2.4.3 <script type="math/tex">\Delta W_q</script>和<script type="math/tex">\Delta W_v</script>的对比</h5><ul><li>作者采用了<script type="math/tex">r=64</script>，但是不用预训练权重，而是两次不同的随机初始化，来对模型进行训练，得到了两个不同的A矩阵<script type="math/tex">A_{r=64}, A'_{r=64}</script>，得到结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230810161204970.png" alt="image-20230810161204970" style="zoom:50%;" /></p><ul><li>分析结论：<strong>在不同的初始参数下，<script type="math/tex">\Delta W_q</script>共享重合的子空间（即相似度高的奇异矩阵子空间）的维度比<script type="math/tex">\Delta W_v</script>更高，说明<script type="math/tex">\Delta W_q</script>具有更高的intrinsic dimension，表明<script type="math/tex">\Delta W_q</script>学得的下游”task specific”信息更多</strong></li></ul><h5 id="2-4-4-W和-Delta-W的关系"><a href="#2-4-4-W和-Delta-W的关系" class="headerlink" title="2.4.4 W和\Delta W的关系"></a>2.4.4 <script type="math/tex">W</script>和<script type="math/tex">\Delta W</script>的关系</h5><ul><li>作者还对比了<script type="math/tex">W_q</script>以及其<script type="math/tex">A_{r=k}</script>的子空间相似度：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230810162338348.png" alt="image-20230810162338348" style="zoom:50%;" /></p><ul><li>分析结论：<strong>在<script type="math/tex">i = 400</script>周围，他们的子空间是几乎不重叠的，但是随着<script type="math/tex">i</script>的增加，子空间相似度居然又上来了。说明<script type="math/tex">\Delta W</script>所包含的奇异向量是<script type="math/tex">W</script>的奇异空间中很靠后的奇异向量。说明LoRA潜在地强调了一些重要特征，而这个特征是包含在预训练中，但是并没有在预训练中强调出来的task-specific特征</strong></li></ul><blockquote><p>This suggests that the low-rank adaptation matrix potentially amplifies the important features for specific downstream tasks that were learned but not emphasized in the general pre-training model  </p></blockquote><h1 id="3-QLoRA"><a href="#3-QLoRA" class="headerlink" title="3 QLoRA"></a>3 QLoRA</h1><h3 id="3-1-量化技术"><a href="#3-1-量化技术" class="headerlink" title="3.1 量化技术"></a>3.1 量化技术</h3><ul><li>最常见的量化方法是：</li></ul><script type="math/tex; mode=display">\begin{gather}Q = \frac{R}{S} + Z \\R =(Q - Z) * S\end{gather}</script><p>其中R表示量化前的值，Q表示量化后的值，<script type="math/tex">S = \frac{R_{\max} - R_{\min}}{Q_{\max} -Q_{min}}</script>表示缩放系数，<script type="math/tex">Z = Q_{\max} - R_{\max}/S</script>表示偏移量</p><ul><li>而在QLoRA中运用了更简化一点的形式：</li></ul><script type="math/tex; mode=display">\begin{gather}\mathbf{X}^{\mathrm{Int8}}=\operatorname{round}\left(\frac{127}{\operatorname{absmax}\left(\mathbf{X}^{\mathrm{FP} 32}\right)} \mathbf{X}^{\mathrm{FP} 32}\right)=\operatorname{round}\left(c^{\mathrm{FP} 32} \cdot \mathbf{X}^{\mathrm{FP} 32}\right) \\\operatorname{dequant}\left(c^{\mathrm{FP} 32}, \mathbf{X}^{\mathrm{Int} 8}\right)=\frac{\mathbf{X}^{\mathrm{Int} 8}}{c^{\mathrm{FP} 32}}=\mathbf{X}^{\mathrm{FP} 32}\end{gather}</script><ul><li>运用该方法主要是可以少存储一个偏移量</li><li>但是量化方法有一个通病：<strong>我们是希望量化后的每一个bit的利用率都尽可能高，即映射到每个bit的概率是差不多的，这样信息损失才更小。但是如果有很大的离群值，那么bit利用率会很低</strong></li><li>解决方法：<strong>采用分块量化，即将一个Tensor分为几个小块，分别量化和分别存储量化系数<script type="math/tex">c^{\mathrm{FP} 32}</script></strong></li></ul><h3 id="3-2-QLoRA实现"><a href="#3-2-QLoRA实现" class="headerlink" title="3.2 QLoRA实现"></a>3.2 QLoRA实现</h3><h5 id="3-2-1-4-bit-NormalFloat-Quantization"><a href="#3-2-1-4-bit-NormalFloat-Quantization" class="headerlink" title="3.2.1 4-bit NormalFloat Quantization"></a>3.2.1 4-bit NormalFloat Quantization</h5><ul><li>QLoRA是采用分位数量化，是将权重量化至4bit，并且量化的block_size为64，步骤如下：</li></ul><ol><li>采集<script type="math/tex">N(0,1)</script>的18分位点（有17个分位点），然后通过下式计算：</li></ol><script type="math/tex; mode=display">q_{i}=\frac{1}{2}\left(Q_{X}\left(\frac{i}{2^{k}+1}\right)+Q_{X}\left(\frac{i+1}{2^{k}+1}\right)\right)</script><p>得到16个<script type="math/tex">q_i</script>，然后将这16个<script type="math/tex">q_i</script>除以<script type="math/tex">absmax(q_i)</script>，将其映射到<script type="math/tex">[-1,1]</script>，然后保存下来</p><ol><li>然后再将原权重除以量化常数<script type="math/tex">c^{\mathrm{FP} 32}</script>映射到<script type="math/tex">[-1,1]</script><strong>（注意这个<script type="math/tex">c^{\mathrm{FP} 32}</script>是要保存下来的，去量化的时候用）</strong>，和上一步保存的<script type="math/tex">q_i</script>对比，把原参数转为最近的<script type="math/tex">q_i</script>的index</li><li>去量化时再通过index查保存下来的<script type="math/tex">q_i</script>，再乘上之前除的即<script type="math/tex">c^{\mathrm{FP} 32}</script>可</li></ol><ul><li><p>上述方法存在问题：<strong>通过第一步得到的<script type="math/tex">q_i</script>中并没有0，所以在去量化后不会得到0，但是0在计算中是一个非常重要的值，所以去量化后必须得到准确的0</strong></p></li><li><p>解决方法：<strong>再加一个分位点，使用19分位点（有18个分位点），在17个得到<script type="math/tex">q_i</script>后（映射前的<script type="math/tex">q_i</script>），再将前8个映射到<script type="math/tex">[-1,0]</script>，后9个映射到<script type="math/tex">[0, 1]</script>，再将两部分合并（会丢弃一个重合的0），从而得到16个映射后的<script type="math/tex">q_i</script></strong></p></li><li><p>论文给出了通过这种方法所得到的<script type="math/tex">q_i</script>，直接保存下来使用即可，不需要现算：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829160539803.png" alt="image-20230829160539803" style="zoom:40%;" /></p><h5 id="3-2-2-双量化"><a href="#3-2-2-双量化" class="headerlink" title="3.2.2 双量化"></a>3.2.2 双量化</h5><ul><li>上面说过，对于每个block（block_size=64），需要保存一个<script type="math/tex">c^{\mathrm{FP} 32}</script>，而这会造成<script type="math/tex">32/64=0.5</script>bits/parameter的内存增加</li><li><p>而双量化则是对这个<script type="math/tex">c^{\mathrm{FP} 32}</script>再做一次量化，将其映射到8bit，由于这个absmax很少会有离群值，所以block_size可以大些，第二次量化的block_size为256，这样就把内存增加降低至<script type="math/tex">8/64 + 32/(64 \times 256)=0.127</script>bits/parameter</p></li><li><p>并且由于<script type="math/tex">c^{\mathrm{FP} 32}</script>都为正，所以直接量化只会用到一半的bit，所以是先减去均值再量化。在去量化的时候，乘上<script type="math/tex">c^{\mathrm{FP} 32}</script>之后再算一波均值，然后再加上这个均值</p></li></ul><blockquote><ul><li>个人觉得这个双量化没啥必要哈，节省的内存也很有限说实话</li><li>另外QLoRA还用了Paged Optimizers优化了一些CPU、GPU内存调用的问题</li></ul></blockquote><h5 id="3-2-3-具体实现"><a href="#3-2-3-具体实现" class="headerlink" title="3.2.3 具体实现"></a>3.2.3 具体实现</h5><ul><li>首先，用上述方法将模型权重量化到4bit得到<script type="math/tex">W^{\mathrm{NF4}}</script>，再放入显存。训练是使用bf16精度，每次的计算步骤为：</li></ul><script type="math/tex; mode=display">\begin{gather}\mathbf{Y}^{\mathrm{BF} 16}=\mathbf{X}^{\mathrm{BF} 16} \text { doubleDequant }\left(c_{1}^{\mathrm{FP} 32}, c_{2}^{8\mathrm{bit}}, \mathbf{W}^{\mathrm{NF} 4}\right)+\mathbf{X}^{\mathrm{BF} 16} \mathbf{L}_{1}^{\mathrm{BF} 16} \mathbf{L}_{2}^{\mathrm{BF} 16} \\\operatorname{doubleDequant}\left(c_{1}^{\mathrm{FP} 32}, c_{2}^{8 \text {bit }}, \mathbf{W}^{4 \text {bit }}\right)=\operatorname{dequant}\left(\operatorname{dequant}\left(c_{1}^{\mathrm{FP} 32}, c_{2}^{8\mathrm{bit}}\right), \mathbf{W}^{4 \mathrm{bit}}\right)=\mathbf{W}^{\mathrm{BF} 16}\end{gather}</script><h3 id="3-3-对比实验"><a href="#3-3-对比实验" class="headerlink" title="3.3 对比实验"></a>3.3 对比实验</h3><h5 id="3-3-1-LoRA超参选择"><a href="#3-3-1-LoRA超参选择" class="headerlink" title="3.3.1 LoRA超参选择"></a>3.3.1 LoRA超参选择</h5><ul><li>LoRA论文中采用的只微调query和value矩阵，QLoRA还对比了其他超参，如全参数微调（Alpaca的训练方法）、只调FFN、对所有Attention Layer微调，实验结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829174543969.png" alt="image-20230829174543969" style="zoom:33%;" /></p><ul><li><p>作者发现，<strong>原LoRA参数在QLoRA中并不能获得和全参数微调持平的结果，但是对所有Attention Layer微调可以，并且后面还有个实验说明了<script type="math/tex">r</script>的选择其实不是很重要</strong></p></li><li><p>另外，对比右边两列，发现Alpaca的超参选择的不好，所以自己又调了一版，结果更好</p></li></ul><h5 id="3-3-2-NF4-amp-amp-双量化"><a href="#3-3-2-NF4-amp-amp-双量化" class="headerlink" title="3.3.2 NF4 &amp;&amp; 双量化"></a>3.3.2 NF4 &amp;&amp; 双量化</h5><ul><li>作者对比了NF4和其他4-bit精度，并且探究了双量化对效果是否有影响，实验结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829175203934.png" alt="image-20230829175203934" style="zoom:33%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829175357381.png" alt="image-20230829175357381" style="zoom:40%;" /></p><h3 id="3-4-Chat-Bot-Evaluation"><a href="#3-4-Chat-Bot-Evaluation" class="headerlink" title="3.4 Chat-Bot Evaluation"></a>3.4 Chat-Bot Evaluation</h3><h5 id="3-4-1-训练配置"><a href="#3-4-1-训练配置" class="headerlink" title="3.4.1 训练配置"></a>3.4.1 训练配置</h5><ul><li>用<strong>OASST1、HH-RLHF、Alpaca 、self-instruct、unnatural-instructions、FLAN v2、Chip2、Longform</strong>等几个数据集微调LLaMA，<strong>并没有进行RLHF</strong></li><li>测评采用<strong>MMLU、对比ChatGPT、Elo Rating</strong>，MMLU采用5-shot测试，后两者是基于Vicuna prompts和OASST1的测试集（称为Vicuna benchmark）进行测评的，并且混合采用了人类和GPT-4进行测评</li><li>对比ChatGPT时，<strong>对于同一prompt，测评模型和ChatGPT生成的responses，分别打分（满分10分）。</strong>再计算该模型能达到ChatGPT性能的百分之几，100%为刚好打平</li><li><p>计算Elo Rating时，<strong>对于同一prompt，不同模型responses，进行三分类任务，选哪个更好或打平。</strong>再通过多次对比结果，计算Elo Rating</p></li><li><p>在采用GPT-4进行测评时，<strong>发现GPT-4会对在prompt中排靠前的answer有更多偏好，所以每次用GPT-4测评两次，依次将不同answer至于靠前位置，然后取平均分</strong></p></li><li><p>其中Guanaco是用QLoRA+OASST1数据集的变体微调的模型</p></li></ul><h5 id="3-4-2-实验结果"><a href="#3-4-2-实验结果" class="headerlink" title="3.4.2 实验结果"></a>3.4.2 实验结果</h5><ul><li><strong>不同数据集的微调结果：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829191239069.png" alt="image-20230829191239069" style="zoom:40%;" /></p><ul><li><strong>Competition with ChatGPT：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829191321959.png" alt="image-20230829191321735" style="zoom:35%;" /></p><ul><li><strong>Elo rating排行榜：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230829191406666.png" alt="image-20230829191406666" style="zoom: 37%;" /></p><h5 id="3-4-3-结果分析"><a href="#3-4-3-结果分析" class="headerlink" title="3.4.3 结果分析"></a>3.4.3 结果分析</h5><ul><li>Guanaco能达到和ChatGPT差不多的水平，<strong>表明QLoRA在chat-bot表现上仍然很好</strong></li><li><strong>数据集和下游任务的匹配度才是最重要的</strong>，比如FLAN v2在MMLU上表现很好，但是在Vicuna benchmark上表现很差</li><li>并且还说明了MMLU并不能很全面地反映chat-bot的能力（个人理解：MMLU反映的是在多学科、多领域的知识能力以及知识覆盖面，而其他chat-bot能力反应的不是特别好）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Megatron-LM</title>
    <link href="/2023/08/02/Megatron-LM/"/>
    <url>/2023/08/02/Megatron-LM/</url>
    
    <content type="html"><![CDATA[<ul><li>Megatron-LM的张量并行（TP）思想是：<strong>将一个权重Tensor沿行或者列进行划分，将各部分分别在不同的卡上进行计算，最后再汇总</strong></li><li>相比于其他张量并行的方法，Megatron-LM的优点主要是：<strong>不需要改重写底层算子，只需要稍微改变一点计算和增加少量的同步锁即可。并且可以和DP、PP等方法一起使用</strong></li></ul><h1 id="1-划分方法"><a href="#1-划分方法" class="headerlink" title="1 划分方法"></a>1 划分方法</h1><ul><li>一个权重张量可以延行或者列展开，针对Transformer里的MLP层和Attention层具有不同的划分方式</li></ul><h3 id="1-1-MLP层"><a href="#1-1-MLP层" class="headerlink" title="1.1 MLP层"></a>1.1 MLP层</h3><ul><li>计算流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230803125202209.png" alt="image-20230803125202209" style="zoom:50%;" /></p><ul><li>其中输入的X和输出的Z是每张卡都有一份copy的</li><li>权重矩阵A按列划分，B是按行划分，算出<script type="math/tex">Z_1, Z_2</script>后在<script type="math/tex">g</script>进行一个<strong>All-Reduce</strong>，每张卡得到相同的<script type="math/tex">Z = Z_1 + Z_2</script>，再每张卡都对<script type="math/tex">Z</script>重复一次相同的dropout</li><li>其中<script type="math/tex">f</script>在forward时没用，在backward时代表对梯度做一次<strong>All-Reduce</strong></li></ul><h3 id="1-2-Attention层"><a href="#1-2-Attention层" class="headerlink" title="1.2 Attention层"></a>1.2 Attention层</h3><ul><li>计算流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230803130712170.png" alt="image-20230803130712170" style="zoom: 28%;" /></p><ul><li><p>注意：<strong>这里对Q、K、V的划分是按Attention Head划分的，每张卡会包含1到多个Head</strong></p></li><li><p>当然，应该尽量保证GPU数能整除Attention Head的数量，尽量均匀划分</p></li></ul><h3 id="1-3-通信量分析"><a href="#1-3-通信量分析" class="headerlink" title="1.3 通信量分析"></a>1.3 通信量分析</h3><ul><li><p>两种子层的划分，<strong>通信量在于forward时<script type="math/tex">g</script>的All-Reduce和backward时<script type="math/tex">f</script>的All-Reduce</strong></p></li><li><p>一次All-Reduce的通信量为：<strong>2 <em> batch_size </em> seq_len * hidden_size</strong></p></li><li><p>所以一个MLP层或Attention层的通信量都为：<strong>4 <em> batch_size </em> seq_len * hidden_size</strong></p></li><li><p>回想一下ZeRO中，通信量为2倍模型参数（ZeRo Stage2，通信的就只有梯度），<strong>所以两者的通信量是差不多的</strong></p></li></ul><h3 id="1-4-Embedding层"><a href="#1-4-Embedding层" class="headerlink" title="1.4 Embedding层"></a>1.4 Embedding层</h3><ul><li>在NLP模型参数中，由于词表一般都很大，所以很大一部分参数都集中在Embedding矩阵中，所以对Embedding矩阵进行划分也是十分必要的</li><li>Embedding矩阵同时用于最开始的word2vec和最后的输出层（Weight Tying），所以两个层对Embedding矩阵划分后的操作是不同的</li></ul><h5 id="1-4-1-输入层"><a href="#1-4-1-输入层" class="headerlink" title="1.4.1 输入层"></a>1.4.1 输入层</h5><ul><li>Embedding矩阵shape为（hidden_size, vocab_size），将其按列划分</li><li>将完整的词索引向量输入进每张卡，对每张卡的Embedding矩阵进行提取，<strong>若在某张卡上没有找到对应的Embedding（因为该词的Embedding在其他卡上），则直接将对应的提取值置为全0，最后一起拿去All-Reduce即可</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230803134548873.png" alt="image-20230803134548873" style="zoom:33%;" /></p><ul><li>我们一般只对word embedding进行划分，position embedding的矩阵之类的由于并不大，所以每张卡都备份一份完整的</li></ul><h5 id="1-4-2-输出层"><a href="#1-4-2-输出层" class="headerlink" title="1.4.2 输出层"></a>1.4.2 输出层</h5><ul><li>同样的，将Embedding矩阵按列划分，假设只有两张卡，<script type="math/tex">E = [E_1, E_2]</script></li><li>然后计算<script type="math/tex">Y_1, Y_2 = XE_1, XE_2</script>，每张卡得到一半的logits，然后进行<strong>All-Gather</strong>操作，每张卡得到完整的logits，再用交叉熵算损失</li><li>但是这样的方法通信量为<strong>batch_size <em> seq_len </em> vocab_size</strong>，通行量过大</li><li><strong>改进方法：</strong></li></ul><blockquote><ol><li>得到<script type="math/tex">Y_1, Y_2 = XE_1, XE_2</script>的部分logits之后，每张卡对自己所属的部分logits算<script type="math/tex">\sum_{logit}e^{logit}</script>，然后将这个值<strong>All-Reduce</strong></li><li>那么现在每张卡都得到了完整的<script type="math/tex">\sum_{logit}e^{logit}</script>，就可以算自己这块对应的loss了，然后再把这个loss再<strong>All-Reduce</strong>一次，每张卡即可得到完整的loss</li><li>改进之后通信量约为<strong>batch_size * seq_len</strong></li></ol></blockquote><h1 id="2-2D-Parallelism（DP-TP）"><a href="#2-2D-Parallelism（DP-TP）" class="headerlink" title="2 2D-Parallelism（DP+TP）"></a>2 2D-Parallelism（DP+TP）</h1><ul><li>前面说过TP和DP的通信量基本差不多，而在多机多卡的场景下，<strong>我们对体系设计主要考虑通信量和是否需要等待其他机器两个因素</strong></li><li>2D-Parallelism体系如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230803143148059.png" alt="image-20230803143148059" style="zoom:40%;" /></p><ul><li>即一台机器输入一批micro-batch，然后一台机器上的多张卡来做模型并行</li><li><p>这样做的好处是：<strong>对于TP，每次每张卡分别算了一部分参数的梯度后，需要做All-Reduce操作才能继续上一层的backward，所以对于带宽要求较高，理应放在同一台机器中；而对于DP，算完属于自己micro-batch的部分梯度后，直接把这部分梯度传出去就可以了，可以同时进行上一层的backward，所以不需要等待，对带宽要求不高</strong></p></li><li><p>值得一提的是，同样有3D-Parallelism，体系如下，同样是在多机之间做DP：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230804180339179.png" alt="image-20230804180339179" style="zoom:50%;" /></p><h1 id="3-实验效果"><a href="#3-实验效果" class="headerlink" title="3 实验效果"></a>3 实验效果</h1><ul><li>要评测采用TP或者DP+TP是否降低了训练效率，最直观的方法就是看每张卡的吞吐量：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230803143930235.png" alt="image-20230803143930235" style="zoom:50%;" /></p><p>图中Y轴为吞吐量相比于一张卡训练的时候的吞吐量的占比</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>混合精度训练</title>
    <link href="/2023/08/01/%E6%B7%B7%E5%90%88%E7%B2%BE%E5%BA%A6%E8%AE%AD%E7%BB%83/"/>
    <url>/2023/08/01/%E6%B7%B7%E5%90%88%E7%B2%BE%E5%BA%A6%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1-浮点数精度"><a href="#1-浮点数精度" class="headerlink" title="1 浮点数精度"></a>1 浮点数精度</h1><ul><li>一个浮点数在存储时有3部分，<strong>拿IEEE float32举例，总共32bit，其中包含1bit符号位，8bit指数位，23bit尾数位</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230801193815438.png" alt="image-20230801193815438" style="zoom:50%;" /></p><ul><li><p>以25.125举例，先转为二进制11001.001，然后移动位数后为<script type="math/tex">1.1001001 \times 2^4</script>，符号位为1表示正数，指数位为4，尾数位为1.1001001</p></li><li><p>所以容易得出结论：<strong>指数位越多，表示范围越大；尾数位越多，表示精度越大（因为一些数的尾数过长，所以会对尾数位进行截断，所以尾数位越多精度损失越小）</strong></p></li><li><p>而深度学习里最常用的三种浮点精度为：FP32、FP16、BF16</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230801194506322.png" alt="image-20230801194506322" style="zoom:50%;" /></p><ul><li><p>有三者的各位数可知：<strong>表示范围FP32=BF16&gt;FP16；表示精度FP32&gt;FP16&gt;BF16</strong></p></li><li><p><strong>而在深度学习当中，不是很依赖于数字表示的精度（有微小误差是完全可以接受的），所以BF16是全面优于FP16的（并且两者吞吐量是相同的），但是部分硬件并不支持BF16</strong></p></li></ul><h1 id="2-混合精度训练"><a href="#2-混合精度训练" class="headerlink" title="2 混合精度训练"></a>2 混合精度训练</h1><ul><li>混合精度训练的是用FP16来代替FP32的计算，增大系统吞吐量和运算速度，并减少显存占用</li></ul><h3 id="2-1-训练流程"><a href="#2-1-训练流程" class="headerlink" title="2.1 训练流程"></a>2.1 训练流程</h3><ul><li>大致流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-3b81fa8af962c682b9c55ee48014af0e_1440w.webp" alt="img" style="zoom:67%;" /></p><ol><li>备份一份FP32的模型权重，然后将模型参数转为FP16进行前向传播，那么前向传播中的各数据，如激活值等，都是FP16</li><li>得到loss后做loss-scaling，将loss乘某一个倍数进行放大</li><li>然后进行反向传播，<strong>得到FP16的梯度，然后将该梯度转为FP32，再除以刚刚所乘的倍数</strong></li><li>使用得到的FP32梯度对备份的FP32权重进行更新，然后用新的参数进行下一次迭代</li></ol><h3 id="2-2-精度损失"><a href="#2-2-精度损失" class="headerlink" title="2.2 精度损失"></a>2.2 精度损失</h3><ul><li>用FP16进行运算，可表示范围减少了很多，肯定会造成模型精度的下降，作者对SSD网络在训练过程中的梯度和激活值中各精度的占比进行了统计：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230801205003340.png" alt="image-20230801205003340" style="zoom:55%;" /></p><ul><li>统计发现，会有67%的值如果用FP16表示，会直接下溢变成0</li><li>在上文的训练流程中，发现得到loss之后会做scaling，然后在权重更新的时候又会unscaling回来。<strong>这样其实是为了将对应的梯度放大到FP16的可表示范围之内，然后再在梯度更新的时候缩小回正确值进行更新。这样是可行的，因为训练到后面会发现参数基本都很小，所以靠前的位基本都是0，所以放大一般不会造成值的损失</strong></li></ul><h3 id="2-3-Tensor-Core"><a href="#2-3-Tensor-Core" class="headerlink" title="2.3 Tensor Core"></a>2.3 Tensor Core</h3><ul><li><p><strong>在一些对精度较高的计算中（如BN、Softmax，因为涉及到一个大向量内部各个元素的相加，所以精度损失很严重），必须使用FP32</strong></p></li><li><p>而混合精度训练使用了Tensor Core，<strong>将原本的FP32运算转为了两个FP16矩阵的乘积，再另用一个FP32矩阵来补精度，每次FP16溢出的值都会累计到这个FP32矩阵上</strong></p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230801211604956.png" alt="image-20230801211604956" style="zoom: 50%;" /></p><ul><li><p>在算法实现完之后再将这个FP32矩阵加到最终运算结果上，再转为FP16重新放入显存</p></li><li><p>这样可以同时得兼顾高运算速度和高精度</p></li></ul><h1 id="3-混合精度训练的缺点"><a href="#3-混合精度训练的缺点" class="headerlink" title="3 混合精度训练的缺点"></a>3 混合精度训练的缺点</h1><ul><li>在实际使用的时候，混合精度训练每次迭代会不断尝试不同的scaling值，如果不溢出才会使用这个scaling值。<strong>但是有时候可能使用规定的最大的scaling值还是会溢出，所以可能训练失败</strong></li><li>其实也可以直接不用混合精度训练，直接用bf16来训练模型，也是完全可行</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ZeRO</title>
    <link href="/2023/07/26/ZeRo/"/>
    <url>/2023/07/26/ZeRo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-三种并行方式"><a href="#1-三种并行方式" class="headerlink" title="1 三种并行方式"></a>1 三种并行方式</h1><h3 id="1-1-数据并行"><a href="#1-1-数据并行" class="headerlink" title="1.1 数据并行"></a>1.1 数据并行</h3><ul><li>数据并行分为同时有server（更新参数的主gpu）和worker的<strong>朴素数据并行（DP）</strong>和没有server只有worker的<strong>分布式数据并行（DDP）</strong></li></ul><h5 id="1-1-1-DP"><a href="#1-1-1-DP" class="headerlink" title="1.1.1 DP"></a>1.1.1 DP</h5><ul><li><strong>数据并行流程如下：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730141424734.png" alt="image-20230730141424734" style="zoom:40%;" /></p><blockquote><ol><li>每张卡都有一份模型权重备份，并且每张卡都喂入一个不同的micro-batch，分别进行一次FWD和BWD，得到各自得梯度</li><li>进行一次all reduce操作，将梯度push到server gpu上，然后在server gpu上进行参数的更新</li><li>server gpu搞完之后再把更新结果（更新后的模型参数和优化器参数）广播到其他worker gpu上</li></ol></blockquote><ul><li><p>但是这种方法具有很大的<strong>显存冗余</strong>，<strong>对于server的通信负担也很大，并且在server更新参数的时候，其他卡都在空转</strong></p></li><li><p><strong>可以通过异步更新的方法减少空转，即：</strong>在server更新参数的时候，其他worker直接拿还未更新的参数和下一批batch的数据，继续进行FWD和BWD，相当于变相翻倍了batch size</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730145643681.png" alt="image-20230730145643681" style="zoom:50%;" /></p><h5 id="1-1-2-DDP"><a href="#1-1-2-DDP" class="headerlink" title="1.1.2 DDP"></a>1.1.2 DDP</h5><ul><li><p>DDP的主要优化点就是：<strong>去除了server，将server上的通讯压力均衡转到各个worker上，减少了单节点的通信负担</strong></p></li><li><p>DDP在通信时的传输策略和DP不同，是采用<strong>环状通信算法Ring-AllReduce</strong></p></li><li><p>现在的传输目标如下，假设有4块GPU，每块GPU上的数据也对应被切成4份：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730151217839.png" alt="image-20230730151217839" style="zoom:50%;" /></p><ul><li><p>Ring-ALLReduce的实现分为：<strong>Reduce-Scatter</strong>和<strong>All-Gather</strong></p></li><li><p>在<strong>Reduce-Scatter</strong>过程中，每张卡一次只传输自身1/4的数据：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730151658273.png" alt="image-20230730151658273" style="zoom:50%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730151738179.png" alt="image-20230730151738179" style="zoom:50%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730151810709.png" alt="image-20230730151810709" style="zoom:50%;" /></p><ul><li>可以看到，经过三次环状传输之后，每张卡拥有了1/4的完整数据：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730151911922.png" alt="image-20230730151911922" style="zoom:50%;" /></p><ul><li>然后进行<strong>All-Gather</strong>操作，使每张卡都拥有完整数据：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730152041754.png" alt="image-20230730152041754" style="zoom:50%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730152050446.png" alt="image-20230730152050446" style="zoom:50%;" /></p><ul><li>在<strong>All-Gather</strong>同样进行三轮环状传播，每张卡即可得到一样的结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730152146123.png" alt="image-20230730152146123" style="zoom:50%;" /></p><ul><li><strong>采用环状算法的DDP和朴素DP的通信量是相同的，但是通信效率更高，并且减少了server节点压力</strong></li><li><strong>Ring-AllReduce十分常用，在ZeRO，Megatron-LM中，它将频繁地出现，是分布式训练系统中重要的算子。</strong></li></ul><h3 id="1-2-模型并行"><a href="#1-2-模型并行" class="headerlink" title="1.2 模型并行"></a>1.2 模型并行</h3><ul><li>如果模型的规模比较大，单个 GPU 的内存承载不下时，我们可以将模型网络结构进行拆分，将一个Tensor分成若干份，把每一份分配到不同的 GPU 中分别计算</li><li>代表方法是Megatron-LM</li></ul><h3 id="1-3-流水线并行"><a href="#1-3-流水线并行" class="headerlink" title="1.3 流水线并行"></a>1.3 流水线并行</h3><ul><li>将不同的 layer 分配给指定 GPU 进行计算。相较于数据并行需要 GPU 之间的全局通信，流水线并行只需其之间点对点地通讯传递部分 activations，<strong>这样的特性可以使流水并行对通讯带宽的需求降到更低</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730153614898.png" alt="image-20230730153614898" style="zoom:80%;" /></p><ul><li><p>然而，<strong>流水并行需要相对稳定的通讯频率来确保效率</strong>，这导致在应用时需要手动进行网络分段，<strong>并插入繁琐的通信原语</strong></p></li><li><p>代表方法是GPipe</p></li></ul><h1 id="2-ZeRO"><a href="#2-ZeRO" class="headerlink" title="2 ZeRO"></a>2 ZeRO</h1><h3 id="2-1-CUDA显存占用"><a href="#2-1-CUDA显存占用" class="headerlink" title="2.1 CUDA显存占用"></a>2.1 CUDA显存占用</h3><ul><li>CUDA显存占用如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-fcc24ce92b951ca8515114204cfa59cf_1440w.webp" alt="img" style="zoom:40%;" /></p><ul><li>其中Model States包括<strong>优化器参数、梯度、模型参数</strong>，这也是ZeRO所优化的部分</li><li><strong>activation</strong>表示前向传播时留的缓存，会在反向传播时用到。但是不是必须的，可以使用<strong>Gradient Checkpoint</strong>来反向传播的时候现算，会慢一些</li><li>剩余的存储空间基本就是：<strong>通信buffer、碎片、CUDA核占用</strong></li></ul><h3 id="2-2-ZeRO-Stages"><a href="#2-2-ZeRO-Stages" class="headerlink" title="2.2 ZeRO Stages"></a>2.2 ZeRO Stages</h3><ul><li><strong>ZeRO一般都是结合混合精度训练使用，当然也可以不结合</strong></li><li>ZeRO其实就是<strong>对三种Model States进行划分，每张卡存储一部分参数，在要用的时候再通信传输</strong>，具体分为三个等级：</li></ul><blockquote><ol><li><strong>Stage 1：</strong>只划分优化器参数<strong>（注意这里的优化器参数还包括fp32的模型参数备份）</strong></li><li><strong>Stage 2：</strong>划分优化器参数、梯度</li><li><strong>Stage 3：</strong>划分优化器参数、梯度、模型参数</li></ol></blockquote><ul><li>设：模型参数为<script type="math/tex">\Psi</script>，卡的张数为<script type="math/tex">N_d</script>，由于有各种优化器，所以直接设优化器状态所占显存为<script type="math/tex">K\Psi</script></li><li><p>由于采用混合精度训练，<strong>模型参数和梯度为fp16，所以分别占<script type="math/tex">2\Psi</script></strong>。优化器以Adam举例，优化器状态包括：<strong>模型参数备份（fp32）、momentum（fp32）、variance（fp32）</strong>，分别占<script type="math/tex">4\Psi</script>，所以<script type="math/tex">K=12</script></p></li><li><p>采用三种stages的显存优化效果如下（暂不考虑activation所占空间）：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730161151812.png" alt="image-20230730161151812" style="zoom:50%;" /></p><h3 id="2-3-具体流程"><a href="#2-3-具体流程" class="headerlink" title="2.3 具体流程"></a>2.3 具体流程</h3><h5 id="2-3-1-常用通信方式及其通信量"><a href="#2-3-1-常用通信方式及其通信量" class="headerlink" title="2.3.1 常用通信方式及其通信量"></a>2.3.1 常用通信方式及其通信量</h5><ul><li>通信量分析都<strong>指单卡传出的通信量</strong>，而忽略传入的通信量，因为传入传出通信量相同且可以同时进行</li><li><p>并且这里的通信量不是像上面一样，指具体的字节数，而是直接指传输的参数数量</p></li><li><p><strong>Reduce-Scatter：单卡通信量<script type="math/tex">\Psi</script></strong></p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730162556796.png" alt="image-20230730162556796" style="zoom:50%;" /></p><ul><li><strong>All-Gather：单卡通信量<script type="math/tex">\Psi</script></strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730162542367.png" alt="image-20230730162542367" style="zoom:50%;" /></p><ul><li><strong>All-Reduce：单卡通信量<script type="math/tex">2 \Psi</script>（All-Reduce一般都是直接指Ring-AllReduce，即Reduce-Scatter + All-Gather）</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730162527164.png" alt="image-20230730162527164" style="zoom:50%;" /></p><ul><li><strong>不带ZeRO的DDP的通信量为</strong><script type="math/tex">2 \Psi</script>，只需要对梯度做一次<strong>All-Reduce</strong></li></ul><h5 id="2-3-2-Stage-1流程"><a href="#2-3-2-Stage-1流程" class="headerlink" title="2.3.2 Stage 1流程"></a>2.3.2 Stage 1流程</h5><ol><li>每张卡分别FWD和BWD得到各自的梯度</li><li>对梯度做一次<strong>Reduce-Scatter</strong>，每张卡得到自己所属部分的<script type="math/tex">\frac{1}{N_d}</script>优化器状态对应的那部分的reduce后的<script type="math/tex">\frac{1}{N_d}</script>梯度（图中蓝色部分），<strong>产生单卡通信量<script type="math/tex">\Psi</script></strong></li><li><strong>并且在梯度汇总完之后，不属于自己的那<script type="math/tex">1 - \frac{1}{N_d}</script>梯度可以直接丢弃（图书白色部分）。然后现在每张卡有且只拥有自己所对应的<script type="math/tex">\frac{1}{N_d}</script>优化器参数以及<script type="math/tex">\frac{1}{N_d}</script>梯度，所以可以更新自己所属的<script type="math/tex">\frac{1}{N_d}</script>参数</strong></li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230730165502320.png" style="zoom:40%;" /></p><ol><li>此时，每块GPU上都有<script type="math/tex">1 - \frac{1}{N_d}</script>的参数没有完成更新。所以我们需要参数对做一次<strong>All-Gather</strong>，从别的GPU上把更新好的<script type="math/tex">\frac{1}{N_d}</script>的参数取回来。<strong>产生单卡通信量<script type="math/tex">\Psi</script></strong></li></ol><ul><li><strong>每张卡总通信量<script type="math/tex">2 \Psi</script></strong></li></ul><h5 id="2-3-3-Stage-2流程"><a href="#2-3-3-Stage-2流程" class="headerlink" title="2.3.3 Stage 2流程"></a>2.3.3 Stage 2流程</h5><ol><li>正常FWD，然后在BWD时，每张卡在做完<script type="math/tex">\frac{1}{N_d}</script>参数的BWD后，得到的这部分梯度有两个去向：<strong>在当前卡上，用于用于继续上一层的BWD；将这部分梯度传到另一张卡上进行梯度的reduce</strong></li><li><strong>这两个去向都结束之后，这部分梯度就可以删除了，每张卡的BWD产生通信量<script type="math/tex">\Psi</script></strong></li><li>现在每张卡都带有每张卡有且只拥有自己所对应的<script type="math/tex">\frac{1}{N_d}</script>优化器参数以及<script type="math/tex">\frac{1}{N_d}</script>梯度，所以剩余流程和stage1一样，<strong>产生单卡通信量<script type="math/tex">\Psi</script></strong></li></ol><ul><li><strong>每张卡总通信量<script type="math/tex">2 \Psi</script></strong></li></ul><h5 id="2-2-4-Stage-3流程"><a href="#2-2-4-Stage-3流程" class="headerlink" title="2.2.4 Stage 3流程"></a>2.2.4 Stage 3流程</h5><ol><li>在FWD的过程中，需要哪部分参数，对应的卡就需要把这<script type="math/tex">\frac{1}{N_d}</script>参数广播出来，才能继续的前向传播，<strong>这部分参数用完之后马上丢，FWD产生单卡通信量<script type="math/tex">\Psi</script></strong></li><li>然后BWD流程和stage 2差不多，但是在BWD时同样需要用到对应的<script type="math/tex">\frac{1}{N_d}</script>模型参数，所以每张卡需要传输参数和梯度，<strong>BWD产生单卡通信量<script type="math/tex">2\Psi</script></strong></li><li><strong>由于每张卡只维护<script type="math/tex">\frac{1}{N_d}</script>参数，所以最后不再需要对参数再做一次All-Gather，得到reduce后的<script type="math/tex">\frac{1}{N_d}</script>梯度后，直接更新自己的<script type="math/tex">\frac{1}{N_d}</script>参数即可</strong></li></ol><ul><li><strong>每张卡总通信量<script type="math/tex">3 \Psi</script></strong></li></ul><h1 id="3-ZeRO-Offload"><a href="#3-ZeRO-Offload" class="headerlink" title="3 ZeRO Offload"></a>3 ZeRO Offload</h1><h3 id="3-1-Offload-思想"><a href="#3-1-Offload-思想" class="headerlink" title="3.1 Offload 思想"></a>3.1 Offload 思想</h3><ul><li>在混合精度训练下，一次训练迭代大致分为：<strong>FWD、BWD、fp32参数更新、fp32参数更新之后再转fp16</strong></li><li>设模型参数为<script type="math/tex">M</script>，Batch_size为<script type="math/tex">B</script>。<strong>前两个过程的时间复杂度为<script type="math/tex">O(MB)</script>，后两个过程时间复杂度为<script type="math/tex">O(M)</script></strong></li><li><p>而Offload的思想就是<strong>将后两个时间复杂度较低的过程下放到CPU进行</strong></p></li><li><p>整体过程大致如下：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230801151916236.png" alt="image-20230801151916236" style="zoom: 50%;" /></p><p>其中边的权重要么是2M（fp16），要么是4M（fp32）</p><ul><li>另外，为了提高效率，可以将计算和CPU、GPU通信并行。GPU算完一部分梯度后，同时进行上一层的梯度计算和将梯度传输给CPU。同样的，CPU在参数更新的同时，可以将已经更新好的参数传给GPU</li></ul><h3 id="3-2-多卡场景"><a href="#3-2-多卡场景" class="headerlink" title="3.2 多卡场景"></a>3.2 多卡场景</h3><ul><li>刚刚讲的是单卡场景，在多卡场景下，只需要每张卡都对应一个CPU进程即可，各算各的</li><li>每个CPU进程只更新属于自己的参数，然后将参数传给GPU，GPU再进行通信（Stage 1 &amp;&amp; 2最后还会有All-Gather的通信）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GPT</title>
    <link href="/2023/03/10/GPT/"/>
    <url>/2023/03/10/GPT/</url>
    
    <content type="html"><![CDATA[<h1 id="1-GPT-v1"><a href="#1-GPT-v1" class="headerlink" title="1 GPT v1"></a>1 GPT v1</h1><ul><li>GPT采用无监督预训练+下游任务微调的方法</li></ul><h3 id="1-1-模型结构"><a href="#1-1-模型结构" class="headerlink" title="1.1 模型结构"></a>1.1 模型结构</h3><ul><li><p>采用12个堆叠的Transformer的Decoder块（去除了和encoder连接的那个Multi-Head）：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_1.png" alt="IMG_1" style="zoom:40%;" /></p></li></ul><h3 id="1-2-模型训练目标"><a href="#1-2-模型训练目标" class="headerlink" title="1.2 模型训练目标"></a>1.2 模型训练目标</h3><h5 id="1-2-1-无监督预训练目标"><a href="#1-2-1-无监督预训练目标" class="headerlink" title="1.2.1 无监督预训练目标"></a>1.2.1 无监督预训练目标</h5><ul><li>无监督预训练采用的是LM（语言模型）的训练方法，采用n元语法：<script type="math/tex; mode=display">L_{1}(\mathcal{U})=\sum_{i} \log P\left(u_{i} \mid u_{i-k}, \ldots, u_{i-1} ; \Theta\right)</script>其中k即n元语法中的n，具<strong>体实现中k是取最大，即表示使用前面的所有词（个人觉得他这里说的有点歧义）</strong>，<script type="math/tex">\Theta</script>是模型参数</li><li>具体到模型实现上， 类似于word2vec的实现方法，当要预测当前时间步的词u时，采用前面所有的词<script type="math/tex">U = (u_{-k}, ..., u_{-1})</script>来进行预测：<script type="math/tex; mode=display">\begin{aligned}h_{0} & =U W_{e}+W_{p} \\h_{l} & =\text { transformer_block }\left(h_{l-1}\right) \forall i \in[1, n] \\P(u) & =\operatorname{softmax}\left(h_{n} W_{e}^{T}\right)\end{aligned}</script>其中<script type="math/tex">W_e \in (vocab\_size, embedding\_dim)</script>是embedding矩阵，<script type="math/tex">W_p \in (seq\_len, embedding\_dim)</script>是<strong>学习到的</strong>位置编码，n表示Transformer层数。<strong>注意最后还是乘的<script type="math/tex">W_e</script>表示使用了Weight Tying</strong>。具体实现是和Transformer一样的</li></ul><h5 id="1-2-2-有监督微调"><a href="#1-2-2-有监督微调" class="headerlink" title="1.2.2 有监督微调"></a>1.2.2 有监督微调</h5><ul><li>有监督任务一般都是在最后接一个全连接，训练目标是：<script type="math/tex; mode=display">L_{2}(\mathcal{C})=\sum_{(x, y)} \log P\left(y \mid x^{1}, \ldots, x^{m}\right)</script>其中x是输入，y是label</li><li>在微调的时候，作者还加入了LM无监督任务作为额外目标，那么微调时的训练目标变为：<script type="math/tex; mode=display">L_{3}(\mathcal{C})=L_{2}(\mathcal{C})+\lambda * L_{1}(\mathcal{C})</script>其中<script type="math/tex">\lambda</script>表示权重</li><li><strong>这么做的优点是：</strong>可以增加模型泛化能力和收敛速度，后面作者还对此做了消融实验</li></ul><h3 id="1-3-微调具体实现方法"><a href="#1-3-微调具体实现方法" class="headerlink" title="1.3 微调具体实现方法"></a>1.3 微调具体实现方法</h3><ul><li>GPT针对不同类型的下游任务，其做法是不同的。尤其是<strong>由于在预训练时，是在连续通顺文本上训练的，所以在下游任务上有多个输入时，句子之间的相对顺序尤为重要</strong></li><li>最初的输入还要加三个特殊token：起始token（\<s\>）、分隔token（$）、结束token（\<e\>）</li><li><strong>方法汇总：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_2.png" alt="IMG_2" style="zoom: 67%;" /></p><ul><li>在做Textual entailment任务时，由于前提p和假设h是有前后文关系的，所以直接p在前h在后即可，中间用$做分隔</li><li>在做Similarity任务时，因为没有明确前后文关系，所以将两种排列顺序分别通过模型，最后将输出结果按元素相加，再喂入mlp</li><li>在做QA或尝试推理这类多选择任务时，上下文在前，选择在后，如给定背景上下文z、问题q、回答集<script type="math/tex">\{a_k\}</script>，那么分别构造<script type="math/tex">[z;q;\$;a_k]</script>作为输入。最后将结果通过softmax映射为概率</li></ul><h3 id="1-4-模型训练"><a href="#1-4-模型训练" class="headerlink" title="1.4 模型训练"></a>1.4 模型训练</h3><h5 id="1-4-1-无监督预训练"><a href="#1-4-1-无监督预训练" class="headerlink" title="1.4.1 无监督预训练"></a>1.4.1 无监督预训练</h5><ul><li>采用Adam算法，并且加了warm up，最大学习率为2.5e-4</li><li>epoch = 100，batch size = 64</li><li>采用<script type="math/tex">N(0, 0.02)</script>进行参数初始化，由于含有Layer Norm，所以初始化不需要太关注</li><li>激活函数采用GELU</li></ul><h5 id="1-4-2-有监督微调"><a href="#1-4-2-有监督微调" class="headerlink" title="1.4.2 有监督微调"></a>1.4.2 有监督微调</h5><ul><li>在mlp中也加入了dropout</li><li>learning rate = 6.25e-5，batch size = 32, epochs = 3</li><li>采用线性学习率衰减，在0.2%的训练中使用了warm up，超参<script type="math/tex">\lambda = 0.5</script></li></ul><h3 id="1-5-下游任务表现"><a href="#1-5-下游任务表现" class="headerlink" title="1.5 下游任务表现"></a>1.5 下游任务表现</h3><ul><li><strong>NLI任务：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_3.png" alt="IMG_3" style="zoom: 50%;" /></p><ul><li><strong>QA &amp;&amp; 常识推理：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_4.png" alt="IMG_4" style="zoom: 50%;" /></p><ul><li><strong>语义相似 &amp;&amp; 分类任务：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_5.png" alt="IMG_5" style="zoom:50%;" /></p><h3 id="1-6-消融实验"><a href="#1-6-消融实验" class="headerlink" title="1.6 消融实验"></a>1.6 消融实验</h3><h5 id="1-6-1-迁移的decoder个数的影响"><a href="#1-6-1-迁移的decoder个数的影响" class="headerlink" title="1.6.1 迁移的decoder个数的影响"></a>1.6.1 迁移的decoder个数的影响</h5><ul><li>将预训练之后的模型的一部分decoder用于下游任务，得到结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_6.png" alt="IMG_6" style="zoom: 60%;" /></p><p>由上图可知模型的精度和泛化能力会随着解码器层数增加而不断提升，而且目前还有提升空间</p><ul><li><strong>结论：</strong>预训练得到的每个decoder都是对下游任务有作用的（个人觉得就是模型表达能力更加强大，并且不同的decoder所包含的知识是不同的）</li></ul><h5 id="1-6-2-预训练的作用"><a href="#1-6-2-预训练的作用" class="headerlink" title="1.6.2 预训练的作用"></a>1.6.2 预训练的作用</h5><ul><li>作者去除了微调，以验证模型的zero-shot能力（没有进行过下游任务训练，而在下游的表现），并且和LSTM进行了比较（同样没有进行下游任务）：  </li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_7.png" alt="IMG_7" style="zoom:60%;" /></p><ul><li><strong>结论：</strong>生成式预训练任务是提升其语言建模能力，可以支持各种各样的下游相关任务。并且与 LSTM 相比，Transformer 的结构化注意力记忆有助于迁移</li></ul><h5 id="1-6-3-其他实验"><a href="#1-6-3-其他实验" class="headerlink" title="1.6.3 其他实验"></a>1.6.3 其他实验</h5><ul><li>作者还探究了<strong>微调时将LM作为额外目标的作用、将模型换为LSTM的对比、pre-training的作用</strong>：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_8.png" alt="IMG_8" style="zoom:50%;" /></p><ul><li><strong>结论：</strong></li></ul><ol><li>LM额外目标在大数据集上有提升，但是小数据集上没有</li><li>pre-training不可缺少</li></ol><h1 id="2-GPT-v2"><a href="#2-GPT-v2" class="headerlink" title="2 GPT v2"></a>2 GPT v2</h1><h3 id="2-1-主要思想"><a href="#2-1-主要思想" class="headerlink" title="2.1 主要思想"></a>2.1 主要思想</h3><ul><li>GPT2主要着眼于<strong>只使用无监督的LM训练任务，来使模型具有zero-shot能力，不使用有监督数据微调，直接应用于下游任务</strong></li><li>本篇文章的核心观点就是：<strong>只要无监督数据量足够大且足够多样，那么有监督任务就是无监督任务的子集。从一个尽可能大且多样化的数据集中一定能收集到不同领域不同任务相关的自然语言描述示例</strong><blockquote><p>Our approach motivates building as large and diverse a dataset as possible in order to collect natural language demonstrations of tasks in as varied of domains and contexts as possible.</p></blockquote></li><li>举个例子：<blockquote><ol><li>比如我在训练语言模型时，有一句话“The translation of word Machine Learning in chinese is 机器学习”，那在训练完这句话时，语言模型就自然地将翻译任务和任务的输入输出都学到了</li><li>再比如，又碰到一句话“美国的总统是特朗普”，这一句话训练完，也就是一个小的问答了</li><li>文章也给了用于训练的WebText Dataset中的英法互译真实实例：</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_9.png" alt="IMG_9" style="zoom:50%;" /></p></blockquote></li><li>还有一个需要注意的点是，在下游任务时，<strong>由于预训练的预料都会自然、通顺的语言形式，所以下游任务的输入文本也需要重新构造为自然、通顺的形式</strong>，如：<blockquote><p>机器翻译任务：translate to french, { english text }, { french text }<br>阅读理解任务：answer the question, { document }, { question }, { answer }</p></blockquote></li></ul><h3 id="2-2-训练目标"><a href="#2-2-训练目标" class="headerlink" title="2.2 训练目标"></a>2.2 训练目标</h3><ul><li>GPT2的训练目标仍是LM，但是下游任务的建模发生了一些转变</li><li>一般的有监督任务是在估计分布：<script type="math/tex; mode=display">P(output|input)</script></li><li>然而GPT2由于是要用同一个模型进行多任务，所以建模变为：<script type="math/tex; mode=display">P(output|input, task)</script>对于output的估计还要基于具体是什么任务，相同的输入，不同的任务，所产生的output可能是不同的</li><li>针对不同任务，具体做法的话，就是上文提到的，将有监督数据构造为自然语言形式</li></ul><h3 id="2-3-模型结构"><a href="#2-3-模型结构" class="headerlink" title="2.3 模型结构"></a>2.3 模型结构</h3><ul><li>大体结构还是和GPT1一样，但是做了如下改动：</li></ul><ol><li>Layer Norm由每个sub-block（Attention block和MLP block）之后，移到了之前：</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_11.png" alt="IMG_11" style="zoom:50%;" /></p><ol><li>在模型最后一个自注意力层之后，额外增加一个Layer Norm</li><li>根据残差块的数量，减少了residual path所对应的权重，具体来说，模型一共有N个残差块，那么residual path的权重就都要乘<script type="math/tex">1 / \sqrt{N}</script></li><li>词汇量增加到50257，上下文大小从512增加到1024，batch size增加到512</li></ol><ul><li>模型结构大致如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230802140419199.png" alt="image-20230802140419199" style="zoom:50%;" /></p><h3 id="2-4-实验结果"><a href="#2-4-实验结果" class="headerlink" title="2.4 实验结果"></a>2.4 实验结果</h3><ul><li>在实验效果上，由于 GPT-2 主要是做 zero-shot，所以在实验部分，很多的实验对比都是在无监督的设定下进行的，也就是说他对比的都是无监督的算法</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230329234220217.png" alt="image-20230329234220217"></p><ul><li>GPT-2 在较多任务上对比无监督算法取得了一定的提升，证明了 zero-shot 的能力。但是，在很多任务上与有监督微调的方法相比还是有一些差距的</li></ul><h1 id="3-GPT-v3"><a href="#3-GPT-v3" class="headerlink" title="3 GPT v3"></a>3 GPT v3</h1><ul><li>GPT3不再像GPT2一样完全主推zero-shot，<strong>而是采用few-shot，采用少量的有监督样本（一般10～100）来辅助模型进行推理</strong>。但是，<strong>GPT3采用有监督样本仅用于推理预测的时候，而不会进行微调的参数更新</strong></li></ul><h3 id="3-1-模型结构"><a href="#3-1-模型结构" class="headerlink" title="3.1 模型结构"></a>3.1 模型结构</h3><ul><li>GPT3采用和GPT2一样的结构，<strong>但是将其中的注意力机制变为了Sparse Attention</strong></li><li>传统的Attention是每个token之间两两计算attentino，复杂度为<script type="math/tex">O(n^2)</script></li><li>而Sparse Attention除了相对距离不超过 k 以及相对距离为 k，2k，3k，… 的 token，其他所有 token 的注意力都设为 0，如下图所示：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_14.png" alt="IMG_14" style="zoom: 80%;" /></p><p>其计算复杂度为<script type="math/tex">O(n * \log n)</script></p><ul><li>Sparse Attention的好处：<blockquote><ol><li><strong>减少注意力层的计算复杂度</strong>，节约显存和耗时，从而能够处理更长的输入序列</li><li><strong>具有“局部紧密相关和远程稀疏相关”的特性</strong>，对于距离较近的上下文关注更多，对于距离较远的上下文关注较少</li></ol></blockquote></li><li>最后实验了不同规模的模型：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_15.png" alt="IMG_15" style="zoom: 40%;" /></p><h3 id="3-2-下游评估方法"><a href="#3-2-下游评估方法" class="headerlink" title="3.2 下游评估方法"></a>3.2 下游评估方法</h3><ul><li>具体到下游任务是，采用了三种不同的方法<strong>（注意这三种方法都只用于推理预测，不会进行参数更新）</strong>：<blockquote><ol><li><strong>Zero-shot：</strong>仅使用当前任务的自然语言描述，不进行任何梯度更新</li><li><strong>One-shot：</strong>当前任务的自然语言描述，加上一个简单的输入输出样例，不进行任何梯度更新</li><li><strong>Few-shot：</strong>当前任务的自然语言描述，加上几个简单的输入输出样例，不进行任何梯度更新，也被称为<strong>in-context learning（上下文学习）</strong></li></ol></blockquote></li><li><strong>和fine-tune的对比：</strong> </li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_16.png" alt="IMG_16" style="zoom: 40%;" /></p><p>Few-shot虽然和fine-tune一样都用到多个有监督数据，但是其数据量的需要较少（一般10～100个数据），摒弃不进行参数更新</p><ul><li><strong>三种方法对比的实验效果：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_17.png" alt="IMG_17" style="zoom: 40%;" /></p><h3 id="3-3-训练数据"><a href="#3-3-训练数据" class="headerlink" title="3.3 训练数据"></a>3.3 训练数据</h3><ul><li>GPT-3 使用了多个数据集，其中最大的是 Common Crawl，原始未处理的数据达到了 45TB，其实在 GPT-2 的时候他们就有考虑使用这个数据集，但是后来还是觉得这个<strong>数据集太脏了</strong>所以没用，但是现在 GPT-3 的模型规模太大了，使得训练对数据量的需求也增加了很多，他们不得不重新考虑这个数据集。因此，他们必须在这个数据集上做一些额外的数据清洗工作来尽量保证数据的质量</li><li><strong>数据处理包括：</strong></li></ul><ol><li>采用GPT2中的WebText、Wikiedia等高质量文本作为正样本，用Common Crawl中的样本作为负样本，训练一个LR二分类器，然后采用这个分类器对Common Crawl采样，只保留其中的正样本</li><li>采用MinHashLSH算法，进行相似文本的去重，减少了大约10%的样本</li><li>加入其他的高质量数据集，不同数据集是通过不同的权重进行采样：</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_18.png" alt="IMG_18" style="zoom:50%;" /></p><h3 id="3-4-GPT3的局限性"><a href="#3-4-GPT3的局限性" class="headerlink" title="3.4 GPT3的局限性"></a>3.4 GPT3的局限性</h3><ol><li>当生成文本长度较长时，GPT-3 还是会出现各种问题，比如重复生成一段话，前后矛盾，逻辑衔接不好等等；</li><li>模型和结构的局限性，对于某一些任务，比如填空类型的文本任务，使用单向的自回归语言模型确实存在一定的局限性，这时候如果同时考虑上文和下文的话，效果很可能会更好一些；</li><li>预训练语言模型的通病，在训练时，语料中所有的词都被同等看待，对于一些虚词或无意义的词同样需要花费很多计算量去学习，无法区分学习重点；</li><li>样本有效性或者利用率过低，训一个模型几乎要把整个互联网上的文本数据全都用起来，这与我们人类学习时所需要的成本存在非常大的差异，这方面也是未来人工智能研究的重点；</li><li>有一个不太确定的点是，模型到底是在“学习”还是在“记忆”？我们当然希望它能够学习，但是在使用数据量如此大的情况下，很难去判断它到底是什么样的；</li><li>众所周知，GPT-3 的训练和使用成本都太大了；</li><li>GPT-3 跟很多深度学习模型一样，都是不可解释的，没办法知道模型内部到底是如何作出一系列决策的；</li><li>训练数据中可能存在种族、性别等偏见，导致模型也会有这种偏见</li></ol><h1 id="4-InstructGPT"><a href="#4-InstructGPT" class="headerlink" title="4 InstructGPT"></a>4 InstructGPT</h1><h3 id="4-1-GPT存在的问题"><a href="#4-1-GPT存在的问题" class="headerlink" title="4.1 GPT存在的问题"></a>4.1 GPT存在的问题</h3><ul><li>GPT的训练方式是采用LM的方法，是估计下一个时间步的词的概率分布：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_19.png" alt="IMG_19" style="zoom:67%;" /></p><ul><li>但是由于这是一个概率分布，所以模型的一些输入可能并不符合人类的预期，比如：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_20.png" alt="IMG_20" style="zoom:67%;" /></p><ul><li><strong>对于上述问题的解决方案有两种：</strong><blockquote><ol><li>在训练数据上，构造更加好的问答数据集，但是所花费的人工成本极大，因为训练数据集很大</li><li>引入一个“老师”，让老师对GPT生成的回答进行打分排序，告诉模型人类更期望哪种结果<strong>（这里的老师既可以是真人，也就是使用在线学习；也可以训练一个Reward Model来对模型结果自动打分排序）</strong></li></ol></blockquote></li></ul><h3 id="4-2-实现方案"><a href="#4-2-实现方案" class="headerlink" title="4.2 实现方案"></a>4.2 实现方案</h3><ul><li>模型通过<strong>三个不同的数据集</strong>，完成了三个子任务：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_21.png" alt="IMG_21" style="zoom:55%;" /></p><ol><li><strong>有监督微调（SFT）：</strong>通过常见的prompt和labeler编写的response，来对GPT-3进行LM任务微调</li><li><strong>训练奖励模型（RM）：</strong>通过常见的prompt，让SFT微调后的GPT模型生成多个response，labeler对这些response进行排序。再使用这些prompt+ response对，输入GPT进行打分</li><li><strong>强化学习（RL）：</strong>只需要prompt，不需要有监督，采用PPO算法，再次微调SFT微调后的模型</li></ol><h3 id="4-3-训练数据"><a href="#4-3-训练数据" class="headerlink" title="4.3 训练数据"></a>4.3 训练数据</h3><ul><li>训练数据所用到的prompt来自两部分：<blockquote><ol><li>labeler先构造了一批prompt和对应的response，对GPT-3进行微调，然后上线内测</li><li>将内测用户的prompt又收集起来，由labeler撰写response</li></ol></blockquote></li><li>然后将两部分数据分为三个子任务的数据集： </li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_22.png" alt="IMG_22" style="zoom: 67%;" /></p><p>注意，最后RL的数据集是只有prompt，且只包含收集的用户的prompt，而SFT和RM是两者都有</p><h3 id="4-4-实现细节"><a href="#4-4-实现细节" class="headerlink" title="4.4 实现细节"></a>4.4 实现细节</h3><h5 id="4-4-1-SFT"><a href="#4-4-1-SFT" class="headerlink" title="4.4.1 SFT"></a>4.4.1 SFT</h5><ul><li>方法很简单，就不多赘述</li><li>值得注意的是，作者在SFT中一共训练了16个epoch，但是发现在第一个epoch后就过拟合了（这么大的模型用这么小的数据肯定过拟合）。<strong>但是由于这个模型并不是微调完就直接拿来用，所以过拟合也没关系。甚至更多的epoch甚至能产生更高的RM分数的输出</strong></li></ul><h5 id="4-4-2-RM"><a href="#4-4-2-RM" class="headerlink" title="4.4.2 RM"></a>4.4.2 RM</h5><ul><li>先采用SFT后的模型，对一个prompt生成多个response，并对每一对prompt+response，让labeler进行排序：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_23.png" alt="IMG_23" style="zoom: 25%;" /></p><ul><li>然后将SFT后的模型最后的输出层去掉，转而变为一个只有一个神经元的线性层</li><li>将每一对prompt+response连结起来，输入该模型，最后输出相当于两者契合的logit分数。然后采用以下损失函数进行优化：<script type="math/tex; mode=display">\operatorname{loss}(\theta)=-\frac{1}{\left(\begin{array}{c}K \\2\end{array}\right)} E_{\left(x, y_{w}, y_{l}\right) \sim D}\left[\log \left(\sigma\left(r_{\theta}\left(x, y_{w}\right)-r_{\theta}\left(x, y_{l}\right)\right)\right)\right]</script>其中，K是每个prompt生成的response数量，<script type="math/tex">y_w, y_l</script>分别是prompt输入x的输出response，且<script type="math/tex">rank(y_w) \ge rank(y_l)</script>，外层函数就相当于一个Logestic Regression</li><li>RM是采用的6B的模型，因为作者发现<strong>大模型（比如175B）训练后期loss不稳定</strong></li><li>此外，作者还提出了另一种方法：采用交叉熵，将排名第一的输出当作正样本，其他输出当作负样本，但是<strong>非常容易过拟合</strong></li></ul><h5 id="4-4-3-RL"><a href="#4-4-3-RL" class="headerlink" title="4.4.3 RL"></a>4.4.3 RL</h5><ul><li>RL涉及三个模型：RM模型<script type="math/tex">r_{\theta}</script>、SFT模型<script type="math/tex">\pi^{SFT}</script>和我们最终想要得到的RL模型<script type="math/tex">\pi^{RL}</script>；以及两个数据集RL自身的数据集<script type="math/tex">D_{RL}</script>和预训练时的一部分数据集<script type="math/tex">D_{pretrain}</script></li><li>优化目标如下：<script type="math/tex; mode=display">\begin{aligned}\operatorname{objective}(\phi)= & E_{(x, y) \sim D_{\pi_{\phi}^{\mathrm{RL}}}}\left[r_{\theta}(x, y)-\beta \log \left(\pi_{\phi}^{\mathrm{RL}}(y \mid x) / \pi^{\mathrm{SFT}}(y \mid x)\right)\right]+ \\& \gamma E_{x \sim D_{\text {prerrain }}}\left[\log \left(\pi_{\phi}^{\mathrm{RL}}(x)\right)\right]\end{aligned}</script></li><li>一开始<script type="math/tex">\pi^{RL}</script>是由<script type="math/tex">\pi^{SFT}</script>初始化得来的</li><li>对于第一项，是想让<script type="math/tex">\pi^{RL}</script>的输出得到的RM分数尽可能高，并且在这个微调过程中，<script type="math/tex">\pi^{RL}</script>和<script type="math/tex">\pi^{SFT}</script>的差距不能过大，所以减去两者的KL散度来保证这个差距</li><li>如果只使用第一项，方法就称作PPO。但是为了防止模型遗忘预训练时的知识，引入第二项，也就是预训练任务的优化目标，加入第二项后则称为PPO-ptx</li></ul><h3 id="4-5-实验结果"><a href="#4-5-实验结果" class="headerlink" title="4.5 实验结果"></a>4.5 实验结果</h3><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_24.png" alt="IMG_24" style="zoom: 80%;" /></p><h1 id="5-GPT-vs-BERT"><a href="#5-GPT-vs-BERT" class="headerlink" title="5 GPT vs BERT"></a>5 GPT vs BERT</h1><ul><li>编码器和解码器的选取倒不是 GPT 和 BERT 的区别，它们的区别主要是预训练目标函数的选取，有人认为 GPT 选择的是一个更难的训练目标，它是根据前面的信息去预测下文，预测未来肯定是比完形填空难度要更大的。这也能从某种程度上解释了为什么相同规模的 GPT 和 BERT 模型，GPT 的效果要比 BERT 差。</li><li>但是从另一个角度去想，如果能够把预测未来这个事情做好的话，它最终所能达到的效果的天花板一定是更高的，这可能也是 OpenAI 从一开始到现在一直坚持使用标准语言模型目标函数来做预训练模型的其中一个原因吧，当然这只是一种猜想。事实证明，从 GPT-3 开始，到最近的 ChatGPT，OpenAI 所取得的令人惊艳的效果也一定程度上证明了他们的选择的正确性。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱-基本概念</title>
    <link href="/2022/12/30/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/12/30/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-知识图谱的构成"><a href="#1-知识图谱的构成" class="headerlink" title="1 知识图谱的构成"></a>1 知识图谱的构成</h1><ul><li>作为一种只是表示形式，知识图谱是一种大规模语义网络，包含实体（Entity）、概念（Concept）及其之间的各种语义关系，如下图：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108190012895.png" alt="image-20230108190012895"></p><ul><li>而语义网络是以图形化的形式通过点和边表达知识的方式，其中点包括：</li></ul><blockquote><ol><li><strong>实体：</strong>实体是属性赖以存在的基础，并且必须是自在的，即独立的、不依附于其他东西而存在的。比如身高，仅仅说身高是没有意义的，说“哲学家”这个类别的身高也是没有意义的，而必须说某个具体的哲学家的身高，这才是有明确所指且有意义的。</li><li><strong>概念：</strong>是指一类实体，比如“哲学家”，不是指某个特定的哲学家，而是指一类人</li><li><strong>值：</strong>每个实体都有一定的属性值，一般是数值、日期或文本</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108190222968.png" alt="image-20230108190222968"></p></blockquote><ul><li><p>知识图谱中的边可以分为<strong>属性（Property）</strong>和<strong>关系（Relation）</strong>两类。属性描述实体某方面的特性，而关系则可以认为是一类特殊的属性，当实体的某个属性值也是一个实体时，这个属性就是关系</p></li><li><p>知识图谱和传统语义网络很像，但是两者的根本区别在于<strong>前者是大规模自动化知识获取，而后者过于依赖于专家知识，导致规模等受限</strong></p></li></ul><h1 id="2-知识图谱中的分类"><a href="#2-知识图谱中的分类" class="headerlink" title="2 知识图谱中的分类"></a>2 知识图谱中的分类</h1><ul><li>可以根据所包含的不同知识对知识图谱进行分类：</li></ul><blockquote><ol><li><strong>事实知识（Factual Knowledge）：</strong>关于某个特定实体的基本事实。如（柏拉图，出生地，雅典）</li><li><strong>概念知识（Taxonomy Knowledge）：</strong>概念知识分为两类，一类是实体与概念之间的类属关系（isA关系），如（柏拉图，isA，哲学家），另一类是子概念与父概念之间的子类关系（subclassOf ），如（唯心主义哲学家 subclassOf 哲学家）</li><li><strong>词汇知识（Lexical Knowledge）：</strong>主要包括实体与词汇之间的关系（比如，实体的命名、称谓、英文名等）以及词汇之间的关系(包括同义关系、反义关系、缩略词关系、上下位词关系等)。例如﹐(“Plato”，中文名，柏拉图)、(赵匡胤，谥号，宋太祖)、(妻子，同义，老婆）</li><li><strong>常识知识（Commonsense Knowledge）：</strong>是人类通过身体与世界交互而积累的经验与知识，是人们在交流时无需言明就能理解的知识。如我们都知道鸟有翅膀，能飞，但是这种信息很少出现在文本里，所以常识知识的提取是十分困难的</li></ol></blockquote><ul><li>知识图谱还可以通过其他方式来分类，总结一下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108194127845.png" alt="image-20230108194127845"></p><h1 id="3-知识图谱的数值表示"><a href="#3-知识图谱的数值表示" class="headerlink" title="3 知识图谱的数值表示"></a>3 知识图谱的数值表示</h1><ul><li>一个三元组包括：主题（Subject）、谓词（Predicate）以及客体（Object）。而一个知识图谱可以视作许多个三元组的集合，如下图：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108194532703.png" alt="image-20230108194532703" style="zoom:80%;" /></p><ul><li><p>知识图谱的表示学习旨在将知识图谱中的元素（包括实体、属性、概念等）表示为低维稠密实值向量。而其关键是合理定义知识图谱中<strong>关于事实（即三元组<script type="math/tex"><h, r, t></script>）的损失函数<script type="math/tex">f_r(h,t)</script>，当事实<script type="math/tex"><h, r, t></script>成立时，我们期望<script type="math/tex">f_r(h,t)</script>越小。考虑整个知识图谱的事实，就可以通过最小化<script type="math/tex">\sum_{\langle h, r, t\rangle \in O} f_{r}(\boldsymbol{h}, \boldsymbol{t})</script>来学习向量化表示</strong></p></li><li><p>那么现在问题就变成了如何定义<script type="math/tex">f_r(h,t)</script>，一般思路有基于距离和基于翻译两种</p></li></ul><h3 id="3-1-SE模型"><a href="#3-1-SE模型" class="headerlink" title="3.1 SE模型"></a>3.1 SE模型</h3><ul><li>基于距离的代表模型，基本思想是当两个实体属于同一个三元组<script type="math/tex"><h,r,t ></script>时，它们的向量表示在投影后的空间中也应该彼此靠近</li><li>因此定义损失函数为向量投影后的距离：</li></ul><script type="math/tex; mode=display">f_{r}(\boldsymbol{h}, \boldsymbol{t})=\left\|\boldsymbol{W}_{r, 1} \boldsymbol{h}-\boldsymbol{W}_{r, 2} \boldsymbol{t}\right\|_{l_{1}}</script><p>其中的两个矩阵<script type="math/tex">W_{r, 1}, W_{r, 2}</script>分别用于头实体向量<script type="math/tex">h</script>和尾实体向量<script type="math/tex">t</script>的投影操作，<strong>但SE难以捕捉实体和关系之间的语义相关性</strong></p><h3 id="3-2-TransE模型"><a href="#3-2-TransE模型" class="headerlink" title="3.2 TransE模型"></a>3.2 TransE模型</h3><ul><li>除了基于距离，还有基于翻译的模型，如TransE认为在知识库中，三元组<script type="math/tex"><h,r,t ></script>可以堪称头实体h到尾实体t利用关系r所进行的翻译。</li><li>比如，对于三元组&lt;柏拉图，老师，苏格拉底&gt;来说，头实体“柏拉图”的向量加上关系“老师”的向量，应该尽可能和尾实体“苏格拉底”的向量接近，<strong>也就是<script type="math/tex">h+r \approx t</script></strong></li><li>基于这一思想可以得到损失函数：</li></ul><script type="math/tex; mode=display">f_{r}(\boldsymbol{h}, \boldsymbol{t})=\|\boldsymbol{h}+\boldsymbol{r}-\boldsymbol{t}\|_{l_{1} / l_{2}}</script><ul><li>在实际应用中，<strong>为了使习得的表示更有区分度，使用Hinge Loss目标函数，使得正负例尽可能分开：</strong></li></ul><script type="math/tex; mode=display">L=\sum_{(h, r, t) \in S} \sum_{\left(h^{\prime}, r, t^{\prime}\right) \in S^{\prime}}\left[\gamma+f_{r}(\boldsymbol{h}, \boldsymbol{t})-f_{r}\left(\boldsymbol{h}^{\prime}, \boldsymbol{t}^{\prime}\right)\right]_{+}</script><p>其中，<script type="math/tex">\gamma</script>是间隔参数，<script type="math/tex">S</script>是正例集合（知识库中已有的三元组)，<script type="math/tex">S'</script>是负例集合（知识库中不存在的三元组，通常通过对关系r的三元组头尾实体进行随机替换来构造)。<script type="math/tex">[x]_+ = \max(0, x)</script></p><h3 id="3-3-TransH模型"><a href="#3-3-TransH模型" class="headerlink" title="3.3 TransH模型"></a>3.3 TransH模型</h3><ul><li><strong>TransE模型中的<script type="math/tex">h+r \approx t</script>假设太强</strong>，导致在自反一对多、多对一等关系下实体向量学习的错误。</li><li>比如，对于自反关系r，<script type="math/tex"><h,r,t ></script>和<script type="math/tex"><t,r,h ></script>同时成立，导致h =t。对于多对一关系。又比如&lt;柏拉图，性别，男&gt;、&lt;特朗普，性别，男&gt;两个三元组有着相同的关系和尾实体，导致柏拉图和特朗普向量接近。但是柏拉图与特朗普除了在性别上相同，在其他方面显然完全不同。</li><li>为解决上述问题，TransH放宽了假设，<strong>只要求头尾实体在关系r相对应的超平面上的投影彼此接近即可</strong>。设r所对应的超平面的法向量为<script type="math/tex">W_r</script>，那么<script type="math/tex">h, t</script>映射到超平面上为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{h}_{\perp} & =\boldsymbol{h}-\boldsymbol{W}_{r}^{\mathrm{T}} \boldsymbol{h} \boldsymbol{W}_{r} \\\boldsymbol{t}_{\perp} & =\boldsymbol{t}-\boldsymbol{W}_{r}^{\mathrm{T}} \boldsymbol{t} \boldsymbol{W}_{r}\end{aligned}</script><ul><li>那么损失函数为：</li></ul><script type="math/tex; mode=display">f_{r}(\boldsymbol{h}, \boldsymbol{t})=\left\|\left(\boldsymbol{h}-\boldsymbol{W}_{r}^{\mathrm{T}} \boldsymbol{h} \boldsymbol{W}_{r}\right)+r-\left(\boldsymbol{t}-\boldsymbol{W}_{r}^{\mathrm{T}} \boldsymbol{t} \boldsymbol{W}_{r}\right)\right\|_{l_{1} / l_{2}}</script><h3 id="3-4-TransR模型"><a href="#3-4-TransR模型" class="headerlink" title="3.4 TransR模型"></a>3.4 TransR模型</h3><ul><li>在TransE模型和TransH模型中，实体和关系都在相同的空间中进行表示。这种做法无法区分两个语义相近的实体在某些特定方面（关系）上的不同</li><li>而TransR模型基本思想和TransH相似，<strong>但是要求将头尾实体映射到关系r所对应的向量空间中，并且彼此接近</strong></li><li>每个关系r维护一个映射矩阵<script type="math/tex">M_r</script>，那么头尾实体映射到该向量空间为：</li></ul><script type="math/tex; mode=display">\begin{aligned}h_r = M_rh \\t_r = M_rt\end{aligned}</script><ul><li>那么损失函数为：</li></ul><script type="math/tex; mode=display">f_{r}(\boldsymbol{h}, \boldsymbol{t})=\left\|\boldsymbol{h}_{r}+\boldsymbol{r}-\boldsymbol{t}_{r}\right\|_{l_{1} / l_{2}}</script><h3 id="3-5-TransD模型"><a href="#3-5-TransD模型" class="headerlink" title="3.5 TransD模型"></a>3.5 TransD模型</h3><ul><li><p>在TransR中，一个关系r对应一个映射矩阵<script type="math/tex">M_r</script>，<strong>该矩阵是和头尾实体无关的</strong>。对于一个三元组，头尾实体可能不是一类实体，比如&lt;柏拉图，出生地，希腊&gt;，<strong>头尾实体不是一类实体，但是却使用了相同的映射矩阵<script type="math/tex">M_r</script></strong>，明显不合理</p></li><li><p><strong>所以TransD令映射矩阵和实体、关系同时相关</strong>。在TransD中，<strong>每个实体或关系都拥有两个向量</strong>，对于三元组<script type="math/tex"><h,r,t ></script>，需要用6个向量<script type="math/tex">h,h_p,t,t_p \in R^n, r, r_p \in R^m</script>，其中<strong>没有下标p的向量是用来捕捉语义信息的，而有下标p的向量是用于构造映射矩阵<script type="math/tex">M_{rh}, M_{rt}</script>的</strong>，映射函数为：</p></li></ul><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{M}_{r h}=r_{p} \boldsymbol{h}_{p}^{\mathrm{T}}+\boldsymbol{I}^{m \times n}\\\quad \boldsymbol{M}_{r t}=r_{p} \boldsymbol{t}_{p}^{\mathrm{T}}+\boldsymbol{I}^{m \times n}\end{aligned}</script><blockquote><ul><li>为什么构造映射矩阵的时候要加单位矩阵？</li></ul><p>每次构造映射矩阵时，是先将矩阵初始化为单位矩阵，然后再通过向量内积来改变这个矩阵。<strong>个人猜测是为了不要让映射后的空间和原空间相差过大</strong></p></blockquote><ul><li>得到映射矩阵后，进行空间变换<script type="math/tex">\boldsymbol{h}_{\perp}=\boldsymbol{M}_{r h} \boldsymbol{h}, \quad \boldsymbol{t}_{\perp}=\boldsymbol{M}_{r t} \boldsymbol{t}</script>，那么损失函数变为：</li></ul><script type="math/tex; mode=display">f_{r}(\boldsymbol{h}+\boldsymbol{t})=\left\|\boldsymbol{h}_{\perp}+\boldsymbol{r}-\boldsymbol{t}_{\perp}\right\|_{l_{1} / l_{2}}</script><h1 id="4-知识表示形式"><a href="#4-知识表示形式" class="headerlink" title="4 知识表示形式"></a>4 知识表示形式</h1><ul><li>最常见的知识表示形式即前面的三元组形式，但是也有其他的表示形式，如谓词逻辑、产生式规则、框架（Frame）、树形知识表示、概率图等：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108215032003.png" alt="image-20230108215032003" style="zoom:80%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108215042336.png" alt="image-20230108215042336" style="zoom:80%;" /></p><ul><li>这里主要介绍一下用马尔可夫随机场（MRF）和马尔可夫逻辑网（MLN）进行表示</li><li><strong>马尔可夫逻辑网是通过软化一阶逻辑实现的</strong>。传统的一阶逻辑知识库（由一阶逻辑命题所组成的知识库）被视作在一系列可能世界 （Possible World）上所施加的一组硬约束（Hard Constraint)，<strong>但是这样的约束太过生硬，有时观察到的规则可能和知识库中的规则冲突</strong>。而MLN旨在软化这些约束，<strong>每条规则都与一个反应其约束强度的权重关联，权重越高，满足和不满足此规则的对数概率差就越大，即这条规则的置信度就越高</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108215936859.png" alt="image-20230108215936859"></p><p>其中，<script type="math/tex">Fr(x, y)</script>表示x，y是朋友，<script type="math/tex">Sm(x)</script>表示x抽烟。综上所述，<strong>MLN就是一个（规则，权重）对的集合</strong></p><ul><li>而MLN可以视作定义具体的MRF（马尔可夫随机场）的模板。给定一个MLN（记作<script type="math/tex">L=\{F_i, w_i\}</script>）以及一个常量集合（如<script type="math/tex">C=\{Anna, Bob\}</script>），就可以定义一个相应的MRF（记作<script type="math/tex">M_{L, C}</script>）。构筑规则如下：</li></ul><blockquote><ul><li><strong>MRF的每个节点对应将MLN规则中经过给定常量实例化（Grounding）而得到的一个谓词</strong>。比如规则<script type="math/tex">\forall x \forall y \forall z \operatorname{Fr}(x, y) \wedge \operatorname{Fr}(y, z) \Rightarrow \operatorname{Fr}(x, z)</script>中包含<script type="math/tex">Fr(x, y)</script>，由于给定了<script type="math/tex">C=\{Anna, Bob\}</script>，所以可以将其实例化为<script type="math/tex">Fr(Anna, Bob)</script>，这就是一个谓词实例，也是一个二元随机变量（要么为真要么为假），其就对应了MRF中的一个节点</li><li>现在要进一步需要明确MRF中的边：<strong>两个谓词实例之间存在一条边，当且仅当它们至少在一个规则中同时出现。一条规则中的谓词之间形成了马尔可夫随机场中的一个团（不一定是最大团）</strong></li></ul></blockquote><ul><li>通过上图的最后两条规则，并给定<script type="math/tex">C=\{Anna, Bob\}</script>，可以构建出如下的MRF：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20230108221652749.png" alt="image-20230108221652749"  /></p><ul><li>根据得到的<script type="math/tex">M_{L,C}</script>可以进行概率推理，推理所要回答的问题形式是：<strong>一直一条规则成立，则另一条规则成立的概率是多少</strong>。比如已知<script type="math/tex">F_2</script>为<script type="math/tex">Fr(Anna, Bob) \vee Sm(Anna)</script>，求<script type="math/tex">F_1 = Sm(Bob)</script>的概率：</li></ul><script type="math/tex; mode=display">\begin{aligned}P(F_1 \mid F_2, M_{L, C}) & =\frac{P\left(F_{1} \wedge F_{2} \mid M_{L, C}\right)}{P\left(F_{2} \mid M_{L, C}\right)} \\& =\frac{\sum_{x \in \chi_{F_{1}} \cap \chi_{F_{2}}} P\left(X=x \mid M_{L, C}\right)}{\sum_{x \in \chi_{F_{2}}} P\left(X=x \mid M_{L, C}\right)}\end{aligned}</script><p>其中<script type="math/tex">\chi_{F_i}</script>表示<script type="math/tex">F_i</script>成立的世界的集合</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>T5 &amp;&amp; mT5</title>
    <link href="/2022/11/22/T5%20&amp;&amp;%20mT5/"/>
    <url>/2022/11/22/T5%20&amp;&amp;%20mT5/</url>
    
    <content type="html"><![CDATA[<ul><li>T5（Text-to-Text Transfer Transformer）模型采用了一种Text-to-text（文本到文本）的框架，想要把NLP领域的许多常见任务，如文本分类、QA等，都套到这个框架中解决</li><li>如机器翻译任务，输入”translate English to German: That is good.”，目标输出是”Das ist gut.”，在输入中” : “前面称为prompt，代指现在需要执行的任务</li><li>这样的好处是可以把所有的问题都套进去一个统一的范式，从而可以采用同样的模型架构、同样的训练策略、同样的损失函数、同样的解码手段。</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221126211139471.png" alt="image-20221126211139471" style="zoom:80%;" /></p><ul><li>这里我们讲的是T51.0，之后再介绍T51.1的不同点</li></ul><h3 id="1-1-C4数据集"><a href="#1-1-C4数据集" class="headerlink" title="1.1 C4数据集"></a>1.1 C4数据集</h3><ul><li>C4全称Colossal Clean Crawled Corpus，跟GPT2、GPT3的训练数据来源一样，是从网上爬的文本数据，由于是爬的数据，所以数据量足够大，而且类型丰富，缺点是数据质量差，需要过滤，过滤手段包括</li><li>经过一番数据清洗后得到了一个750G的数据集</li></ul><h3 id="1-2-Baseline"><a href="#1-2-Baseline" class="headerlink" title="1.2 Baseline"></a>1.2 Baseline</h3><ul><li>其实T5就是经过很多个实验，对不同的模型结构、训练策略等进行对比，然后挑出效果最好的，所以我们先给出实验中用于对比的baseline</li><li><strong>模型结构：</strong>和Transformer一模一样，12层的encoder-decoder架构</li><li><strong>训练/预测策略：</strong>训练时采用teacher-forcing，预测时采用贪婪搜索</li><li><strong>预训练：</strong>在C4上面训练<script type="math/tex">2^{19}</script>个steps，batch_size=128，seq_len=512。<strong>预训练并没有覆盖所有C4数据集，即没一个样本会重复训练</strong>。预训练目标稍后介绍</li><li><strong>学习率调整：</strong>采用平方根倒数：</li></ul><script type="math/tex; mode=display">l r=\frac{1}{\sqrt{\max (n, k)}}, k=10^{4}</script><ul><li><strong>微调：</strong>对每个下游任务训练<script type="math/tex">2^{18}</script>个steps</li><li><strong>词表：</strong>采用WordPiece，大约有32000个token，有部分非英语词</li></ul><h3 id="1-3-无监督预训练目标"><a href="#1-3-无监督预训练目标" class="headerlink" title="1.3 无监督预训练目标"></a>1.3 无监督预训练目标</h3><ul><li>预训练目标和BERT一样，都是采用随机mask破坏文本，然后通过上下文将这个词训练出来，称为<strong>Denoising</strong>的预训练目标</li><li><strong>对输入随机挑选15%的token，然后使用一个哨兵token进行替换，注意挑选出来的token如果时连续的text span，则只用一个哨兵token进行替换。然后target文本变为：每个哨兵token+其对应的值的形式，最后再接一个特殊的哨兵token，表示结束</strong></li><li>举例栗子：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221126223744785.png" alt="image-20221126223744785"></p><p>如上图，将for inviting和last分别替换成了两个不同的哨兵token，然后target变为了分别预测每个哨兵token，然后文本最后预测出另一个哨兵token\，表示结束</p><h3 id="1-4-不同模型结构的对比"><a href="#1-4-不同模型结构的对比" class="headerlink" title="1.4 不同模型结构的对比"></a>1.4 不同模型结构的对比</h3><ul><li>针对self-atttion，有三种mask方式：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221126230434585.png" alt="image-20221126230434585"></p><p>分别为：</p><blockquote><ol><li>fully-visible：每个时间步都对其他时间步可见</li><li>causal：对未来的时间步不可见</li><li>causal with prefix：前面两者的结合，prefix部分的token能看到prefix所有token的信息，非prefix的token只能看到它的上文信息。那么什么是prefix，如上面提到的英文翻译德文的例子，prefix就是”translate English to German: That is good.”，说白了就是输入部分的时间步是fully-visible，输出部分的时间步是causal</li></ol></blockquote><ul><li>针对三种不一样的mask方式，作者对如下三种模型架构进行了比较：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221126230815635.png" alt="image-20221126230815635"></p><ul><li>对此，作者提出了五种模型（为了公平，只有两个模型有同样数量的参数或者同样的计算效率才能进行比较）：</li></ul><blockquote><ol><li><strong>Encoder-decoder：</strong>编码层和解码层各有L层</li><li><strong>Enc-dec, shared：</strong>编码层和解码层各有L层，但它们参数共享，所以参数减半</li><li><strong>Enc-dec, 6 layers：</strong>编码层和解码层各有L/2层</li><li><strong>LM：</strong>只有L层解码层，采用语言模型的形式</li><li><strong>Prefix LM：</strong>只有L层解码层，但采用Prefix语言模型的形式</li></ol></blockquote><ul><li>并且还对比使用了两种预训练目标：</li></ul><blockquote><ol><li><strong>Denoising：</strong>即baseline中使用的随机mask词然后预测出来</li><li><strong>LM：</strong>LM中常用的自回归预测，即每个时间步预测通过上个时间步的输出来进行当前时间步的输出预测</li></ol></blockquote><ul><li>最后得到以下结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127105905994.png" alt="image-20221127105905994" style="zoom:67%;" /></p><h3 id="1-5-不同的无监督预训练目标对比"><a href="#1-5-不同的无监督预训练目标对比" class="headerlink" title="1.5 不同的无监督预训练目标对比"></a>1.5 不同的无监督预训练目标对比</h3><ul><li>首先介绍采用的预训练目标：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127110614966.png" alt="image-20221127110614966" style="zoom: 80%;" /></p><blockquote><ol><li><strong>Prefix LM：</strong>输入前部分文本，预测剩余的文本</li><li><strong>BERT-style：</strong>利用和BERT中一样的mask策略，然后预测出原文本</li><li><strong>Deshuffling：</strong>随机打乱文本，然后预测出原文本</li><li><strong>MASS-style：</strong>和BERT-style的不同在于，mask时直接用[M]替换</li><li><strong>noise, replace spans：</strong>前文提到的无监督预训练目标</li><li><strong>noise, drop tokens：</strong>和5差不多，但是不用哨兵token替换，直接drop</li><li><strong>Random spans：</strong>和5差不多，但是每次选择的是一个长为3的text span</li></ol></blockquote><ul><li>作者首先对前三种目标进行对比：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127112236904.png" alt="image-20221127112236904" style="zoom:80%;" /></p><ul><li>结果发现BERT-style效果最好，然后再使用余下的方法和BERT-style进行比较：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127112315271.png" alt="image-20221127112315271" style="zoom:80%;" /></p><p><strong>其实这三种和BERT-style差不多，但是后两种不需要预测出整个原文本，更快，</strong></p><ul><li>此外，作者还对比了<strong>不同的文本corruption率和允许的最长text span的长度</strong>（由于连续的mask掉的token都处理为一个哨兵token，允许最长的text span即指最多只有3个token可以替换成一个哨兵token，超过三个要使用另一个哨兵token）</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127112647149.png" alt="image-20221127112647149" style="zoom:80%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127112657299.png" alt="image-20221127112657299" style="zoom:80%;" /></p><ul><li>最后对这部分实验做个总结，作者是逐层递进来进行的对比试验：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127112910646.png" alt="image-20221127112910646" style="zoom:80%;" /></p><h3 id="1-6-数据集对比"><a href="#1-6-数据集对比" class="headerlink" title="1.6 数据集对比"></a>1.6 数据集对比</h3><ul><li>作者还对不同类型和不同大小的预训练数据集进行了对比</li><li>最后得出：<strong>用更专的数据来做预训练，对下游任务的提升越明显，或者换句更准确的话来说，预训练的语料跟任务语料domain越接近，效果越好，并且数据越多越好，即使预训练不能覆盖完</strong></li><li>所以个人认为最佳的策略是<strong>在丰富的数据上进行预训练，然后再在领域相关、任务相关的语料上继续预训练，最后再fine-tuning</strong></li></ul><h3 id="1-7-训练策略"><a href="#1-7-训练策略" class="headerlink" title="1.7 训练策略"></a>1.7 训练策略</h3><ul><li><strong>fine-tuning方法：</strong>作者对三种微调方法进行了对比：</li></ul><blockquote><ol><li><strong>All parameters：</strong>微调时更新所有参数</li><li><strong>Adapter layers：</strong>adapter layers接在编码器和解码器的每一个block的全连接层后面，在fine-tuning的时候只更新它们。adapter layers有一个内部维度d作为超参</li><li><strong>Gradual unfreezing：</strong>一开始离任务层近的参数先更新，其它保持不动，随着训练的进行，逐渐放开其它层的参数。</li></ol></blockquote><p>实验结果：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127115209871.png" alt="image-20221127115209871" style="zoom:80%;" /></p><p>发现还是更新所有参数效果最好，但是会慢很多</p><ul><li><strong>多任务学习：</strong>得益于提出的text-to-text范式，我们可以<strong>在预训练的时候把有监督的训练也加进来，一起做预训练（注意：多任务学习预训练中的数据集包括原本的无监督数据集+多个有监督数据集）</strong>。现在问题就变为了<strong>给定多个不同任务的数据集，怎样对数据进行采样</strong>，作者使用了以下三种策略：</li></ul><blockquote><ol><li><strong>Examples-proportional mixing：</strong>设第<script type="math/tex">i</script>个任务的数据集大小为<script type="math/tex">e_i</script>，那么采样自第<script type="math/tex">j</script>个数据集的概率为<script type="math/tex">r_j=\min(e_j,K)/∑_i\min(e_i,K)</script>，其中K为提前设置好的超参</li><li><strong>Temperature-scaled mixing：</strong>在上面的策略下，再做一些软化，具体来说就是求得<script type="math/tex">r_j</script>后再开1/T方根，T为提前设置好的超参，T越大，各个任务数据集采样越均衡</li><li><strong>Equal mixing：</strong>各数据集均匀采样</li></ol></blockquote><p>实验结果：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221127120459146.png" alt="image-20221127120459146" style="zoom:80%;" /></p><p>实验结果都一般，<strong>不过注意，这里的多任务学习是多个任务一起做训练，相当于把pre-training和fine-tuning两个合并了，而不会对单个任务进行fine-tuning</strong>，所以效果不好也可以理解。</p><ul><li><strong>多任务学习+fine-tuning：</strong>作者采用了一下集中训练策略进行比较：</li></ul><blockquote><ol><li><strong>Unsupervised pre-training + fine-tuning：</strong>baseline中使用的方法，先无监督预训练再在特定的下游任务上微调</li><li><strong>Multi-task training：</strong>直接在多任务数据集上训练（注意mutl-task的训练集中有有监督的也有无监督的）</li><li><strong>Multi-task pre-training + fine-tuning：</strong>多任务预训练+微调</li><li><strong>Leave-one-out multi-task training：</strong>在预训练的时候同样使用多任务，但是要去除和下游任务相关的那个数据集，然后再在下游任务微调</li><li><strong>Supervised multi-task pre-training：</strong>在多任务预训练的时候把无监督任务剔除掉，然后再微调</li></ol></blockquote><p>实验结果：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221128120902619.png" alt="image-20221128120902619"></p><p>通过实验结果得到以下结论：</p><blockquote><ol><li>使用Multi-task pre-training + fine-tuning的结果和baseline差不多，表明<strong>在多任务后使用微调可以减轻不同的数据集mixing比例之间的权衡</strong>，即你选用的Mixing方式（比如上文的三种）不一定是最好的，但是微调可以减轻这种错选带来的干扰</li><li>Leave-one-out的效果只有一点点下降，表明<strong>多任务学习不会导致严重的任务干扰</strong></li><li>使用Supervised multi-task pre-training几乎除了翻译任务都导致了下降，表明<strong>翻译任务从英语预训练中学得的很少，反之其他任务仍然很依赖无监督预训练</strong></li></ol></blockquote><h3 id="1-8-Scaling"><a href="#1-8-Scaling" class="headerlink" title="1.8 Scaling"></a>1.8 Scaling</h3><ul><li>此外，作者还对模型规模等进行了测试，得出<strong>使用更多的数据、训练更大的模型、模型融合都能提高性能</strong></li><li>最后提一句，经过一系列实验，T5还是选择了<strong>Multi-task pre-training + fine-tuning</strong>以及预测时采用束搜索，无监督预训练目标采用了<strong>noise, replace spans</strong></li></ul><h1 id="2-T5-v1-1"><a href="#2-T5-v1-1" class="headerlink" title="2 T5 v1.1"></a>2 T5 v1.1</h1><ul><li>上文讲的是T5 v1.0，谷歌之后又发布了一个T5 v1.1，只有一些细微差别，改进如下：</li></ul><blockquote><ol><li>前馈神经层的激活函数由ReLU改为了GEGLU</li><li>在pre-training的时候关闭Dropout，在微调的时候重新开启</li><li>预训练的时候只使用C4数据集，而不混入下游数据集</li><li>Embedding层和最后的分类层没有使用Weight Tying</li><li>模型形状有点不同，较大的 d_model 和较小的 num_heads 和 d_ff</li></ol></blockquote><h1 id="3-mT5"><a href="#3-mT5" class="headerlink" title="3 mT5"></a>3 mT5</h1><ul><li>mT5的预训练目标和策略等等和T5基本相同， 值得注意的是mT5使用的是T5 v1.1</li></ul><h3 id="3-1-mC4数据集"><a href="#3-1-mC4数据集" class="headerlink" title="3.1 mC4数据集"></a>3.1 mC4数据集</h3><ul><li>一个多语言版的C4数据集，但是使用的数据清洗方法和T5不同：</li><li>对于多语言模型，一个很重要的部分是如何多多种语言进行采样，<strong>不同语种数据占比不同，有的语言样本少（low-resource languages ），如果不常采样到，模型就会由于样本过少而过拟合；如果样本量太大（high-resource languages ），内容丰富，模型又可能欠拟合，所以不能让模型遍历太多high-resource languages</strong></li><li>要解决上述问题，直观上来说可以使用均匀分布来采样，但是使用均匀分布效果肯定比较差，因为很多high-resource languages 压根用不到</li><li>所以采用了：</li></ul><script type="math/tex; mode=display">P(L) \propto L^{\alpha}</script><p>其中L为对应语言的样本数，<script type="math/tex">\alpha \in [0,1]</script>为超参，<script type="math/tex">\alpha</script>越小分布越接近均匀分布，<strong>mT5经过实验发现<script type="math/tex">\alpha=0.3</script>最合适</strong>。那么这样就可以<strong>适当提升low-resource languages的采样概率而适当减少high-resource languages的采样概率</strong></p><ul><li>mC4中不同语言的样本数，以及使用不同<script type="math/tex">\alpha</script>的采样概率：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129191709077.png" alt="image-20221129191709077" style="zoom:80%;" /></p><h3 id="3-2-微调策略"><a href="#3-2-微调策略" class="headerlink" title="3.2 微调策略"></a>3.2 微调策略</h3><ul><li>模型在mC4上预训练之后，作者采用了一下三种微调方式进行对比（微调采用lr = 0.001）：</li></ul><blockquote><ol><li><strong>zero-shot：</strong>仅在英语训练集上微调</li><li><strong>translate-train：</strong>在英语+由英语翻译到所有目标语言的数据集上微调</li><li><strong>in-language multitask：</strong>在目标语言的gold data上微调（这里是真实的人工表述的数据，而tanslate-train的目标语言数据是翻译过来的）</li></ol></blockquote><p>结果如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129193118134.png" alt="image-20221129193118134" style="zoom:80%;" /></p><ul><li>此外，作者还对比了采用不同的模型参数量对这三种微调方式的提升：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129193253828.png" alt="image-20221129193253828"></p><h3 id="3-3-T5-vs-mT5"><a href="#3-3-T5-vs-mT5" class="headerlink" title="3.3 T5 vs mT5"></a>3.3 T5 vs mT5</h3><ul><li>作者还对比了T5和mT5在英语QA任务上的效果差异：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129193755886.png" alt="image-20221129193755886" style="zoom:80%;" /></p><ul><li>发现<strong>mT5还是略逊色于T5，但是随着模型规模的增大，之间的差异越来越小。也证明了多语言模型同样有能力比肩单语言模型</strong></li></ul><h3 id="3-4-消融实验"><a href="#3-4-消融实验" class="headerlink" title="3.4 消融实验"></a>3.4 消融实验</h3><ul><li>作者还对训练的各方面进行了一些消融实验，策略如下：</li></ul><blockquote><ol><li><strong>Dropout 0.1：</strong>由于使用的是T5 v1.1，所以在预训练时没有使用Dropout，这里为了对照又把Dropout加上了</li><li><strong>Sequence length 512：</strong>将最大序列长度减少为512</li><li><strong>Span length 10：</strong>将连续token的长度由3变为10</li><li><strong><script type="math/tex">\alpha=0.7,0.2</script>：</strong>采样时的超参改一下</li><li><strong>No line length filter：</strong>数据清洗时的策略改一下</li><li><strong>Add Wikipedia data：</strong>预训练使用mC4+Wikipedia data</li></ol></blockquote><h3 id="3-5-zero-shot微调策略的问题"><a href="#3-5-zero-shot微调策略的问题" class="headerlink" title="3.5 zero-shot微调策略的问题"></a>3.5 zero-shot微调策略的问题</h3><ul><li>采用zero-shot会造成预测时产生一些非法输出：</li></ul><blockquote><ol><li><strong>Normalization：</strong>prediction是合法的，但是unicode characters被替代了，可以通过Unicode NFKC normalization来恢复</li><li><strong>Grammatical adjustment：</strong>answer本身就存在语法问题</li><li><strong>Accidental translation：</strong>模型直接做了翻译，将目标语言翻译成英文了，以至于生成部分或者完整英文</li></ol><p>同时，在一些短语生成的时候，出现正确答案之前可能会先预测出两个英语词</p><p>上面最常出现的是Accidental translation</p></blockquote><p>以下是非法输出的一些栗子：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129195942926.png" alt="image-20221129195942926" style="zoom:80%;" /></p><ul><li><strong>产生原因：</strong>模型在微调的时候压根没有接触过non-English的target文本，在non-English上做推理时，non-English的likelihood会降低，以至于English变成最可能的输出</li><li><strong>解决方法：</strong>在微调时再次使用<strong>少量的mC4数据进行无监督二次预训练</strong>（和微调的样本数比例是1：100，并且包含全部101种语言），并且二次预训练时<strong>删除了target文本中的哨兵token</strong>，因为最后的结果发现在下游任务时就偶尔会预测出哨兵token，然后还将α从0.3降为0.1，<strong>使采样分布十分近似于均匀分布</strong>。结果提升显著：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221129201243017.png" alt="image-20221129201243017" style="zoom:80%;" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SimCSE总结</title>
    <link href="/2022/10/21/SimCSE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/21/SimCSE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li>作者提出了一种对比学习的方法，分为<strong>有监督和无监督两种</strong>。其中<strong>只用dropout作为噪音，也可以当作一种数据增强，可以改善语义空间，提升其同向异性，使向量空间更为均匀，并且在有监督方法时，还能对齐正样本</strong></li></ul><h1 id="1-评估标准"><a href="#1-评估标准" class="headerlink" title="1 评估标准"></a>1 评估标准</h1><ul><li>本篇文章的目的是改善embedding，并且作者在后面的实验发现，进行了SimCSE后有部分下游任务上的表现甚至出现了下降，但是这并不影响SimCSE的作用。<strong>句子嵌入的主要目标是对语义相似的句子进行聚类，所以为了更加综合的评估实验结果，肯定不能使用某个下游任务的实验结果</strong>，作者采用了另一篇论文中一种评估embedding质量的方法：<strong>采用语义相关的正样本之间的对齐（alignment）和整个表示空间的一致性（uniformity）来衡量学习嵌入的质量</strong></li></ul><blockquote><p>We takes <strong>alignment</strong> between semantically-related positive pairs and <strong>uniformity</strong> of the whole representation space to measure the quality of learned embeddings.  </p></blockquote><ul><li>总的来说，对比学习所做的任务就是：<strong>拉近正样本的距离，剩余的随机样本应该均匀分布在一个超平面上（也就是减少其各向异性）</strong>，所以对比学习的任务就变为了降低以下两个指标：</li></ul><script type="math/tex; mode=display">\ell_{\text {align }} \triangleq \underset{\left(x, x^{+}\right) \sim p_{\text {pos }}}{\mathbb{E}}\left\|f(x)-f\left(x^{+}\right)\right\|^{2}, \\\ell_{\text {uniform }} \triangleq log \underset{\left(x, y\right) \sim p_{\text {data }}}{\mathbb{E}}e^{-2\left\|f(x)-f\left(y\right)\right\|^{2}}</script><p>其中<script type="math/tex">p_{pos}</script>为正样本对，<script type="math/tex">p_{data}</script>为所有数据对，<script type="math/tex">f(x)</script>为输入<script type="math/tex">x</script>经过encoder的输出</p><ul><li><p>并且作者还发现无监督的SimCSE能够向量空间的均匀性，并且并不会降低正样本之间的对齐。然后对于有监督，作者指出NLI任务最为适合训练出好的sentence embedding，并且有监督能够进一步提升正样本之间的对齐</p></li><li><p>本文还多次使用了STS-B数据集，这是一个五分类任务的数据集，旨在判定两个句子的相关程度，分为了5个等级，并且得分采用斯皮尔曼等级相关系数</p></li></ul><h1 id="2-无监督SimCSE"><a href="#2-无监督SimCSE" class="headerlink" title="2 无监督SimCSE"></a>2 无监督SimCSE</h1><h3 id="2-1-基本方法"><a href="#2-1-基本方法" class="headerlink" title="2.1 基本方法"></a>2.1 基本方法</h3><ul><li>方法非常简单，就是将同一个输入，分别经过两次encoder，encoder中的dropout<strong>（dropout率仍为默认的0.1）</strong>作为一种微小的数据增强，会使得两次的输出有些许不同。这两次的输出，就作为一对正样本，然后使用以下loss：</li></ul><script type="math/tex; mode=display">\ell_{i}=-\log \frac{e^{\operatorname{sim}\left(\mathbf{h}_{i}^{z_{i}}, \mathbf{h}_{i}^{z_{i}^{\prime}}\right) / \tau}}{\sum_{j=1}^{N} e^{\operatorname{sim}\left(\mathbf{h}_{i}^{z_{i}}, \mathbf{h}_{j}^{z_{j}^{\prime}}\right) / \tau}},</script><p>其中<script type="math/tex">h_i^z=f_{\theta}(x_i, z)</script>为输入<script type="math/tex">x_i</script>经过<script type="math/tex">\theta</script>的encoder进行编码得到的结果，其中的z代表不同的dropout mask，每次的dropout mask都不同。N为batch size，所以该loss是每个batch内的交叉熵。<script type="math/tex">\tau</script>为温度超参。sim()使用的是余弦距离</p><ul><li><strong>并且在微调时选择更新所有参数</strong></li></ul><h3 id="2-2-Dropout和其他数据增强方式的对比"><a href="#2-2-Dropout和其他数据增强方式的对比" class="headerlink" title="2.2 Dropout和其他数据增强方式的对比"></a>2.2 Dropout和其他数据增强方式的对比</h3><ul><li>本文是将dropout作为一种微小的数据增强方式，所以作者也将其他数据增强方式同其对比了一下，本实验采用lr=3e-5，N=64，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810133558725.png" alt="image-20220810133558725" style="zoom:75%;" /></p><ul><li><strong>发现其他数据增强方式都没有SimCSE效果好（可能是其他方法噪音太大了）</strong></li></ul><h3 id="2-3-采用一个OR两个Encoder"><a href="#2-3-采用一个OR两个Encoder" class="headerlink" title="2.3 采用一个OR两个Encoder"></a>2.3 采用一个OR两个Encoder</h3><ul><li>由于之前有些论文是使用的两个不同的encoder，所以作者也就采用一个还是两个encoder的问题进行了对比试验，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810140539627.png" alt="image-20220810140539627" style="zoom:80%;" /></p><p>图中的next sentence为输入原句子和该句子的下一句。Delete on word同2.2中图一样，输入原句子和删除一个词的原句</p><ul><li>通过实验发现，<strong>只用一个encoder比两个要好</strong></li></ul><h3 id="2-4-采用多少Dropout率"><a href="#2-4-采用多少Dropout率" class="headerlink" title="2.4 采用多少Dropout率"></a>2.4 采用多少Dropout率</h3><ul><li>dropout是SimCSE中重要的一环，所以作者对该超参进行了实验，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810141017109.png" alt="image-20220810141017109" style="zoom:80%;" /></p><p>图中的fixed 0.1为0.1的dropout率，但是对正样本对中的两个样本使用相同的dropout mask，就是两个输出都长一样（有用才有怪了）</p><ul><li><strong>通过实验发现，还是原先默认的0.1最好用</strong></li></ul><h3 id="2-5-alignment-and-uniformity"><a href="#2-5-alignment-and-uniformity" class="headerlink" title="2.5 alignment and uniformity"></a>2.5 alignment and uniformity</h3><ul><li>前面说过，最综合的评估标准是检测结果向量空间的alignment和uniformity，作者对几种方法进行了评估，并给出了可视化的结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810142955971.png" alt="image-20220810142955971" style="zoom:80%;" /></p><p>其中箭头所指方向是训练进行的方向，横轴和竖轴都是越小越好</p><ul><li>通过实验发现，<strong>所有的方法都能有效的提升uniformity</strong>，但是前两种方法会降低正样本之间的alignment，而<strong>无监督SimCSE的alignment则稳定不变</strong>，delete one word可以稍微增加alignment，但是总体表现还是低于无监督SimCSE</li></ul><h1 id="3-有监督SimCSE"><a href="#3-有监督SimCSE" class="headerlink" title="3 有监督SimCSE"></a>3 有监督SimCSE</h1><ul><li>无监督的SimCSE可以提升uniformity，但是alignment不会有改善。而之后作者引入了有监督的数据，<strong>利用其提供更好的训练信号，以提升alignment</strong></li></ul><h3 id="3-1-使用哪种有监督数据"><a href="#3-1-使用哪种有监督数据" class="headerlink" title="3.1 使用哪种有监督数据"></a>3.1 使用哪种有监督数据</h3><ul><li>先简要介绍一下SNLI和MNLI数据集，都是NLI任务下的数据集，是一个三分类，每次输入两个文本，模型预测两者的相似度，然后进行分类：<strong>entailment（相关）、neutral（无关）、contradiction（矛盾）</strong>，举个栗子：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810152937757.png" alt="image-20220810152937757" style="zoom:67%;" /></p><ul><li>作者探究了使用哪种有监督的数据集，能更有效地提升SimCSE的性能，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810152252447.png" alt="image-20220810152252447" style="zoom:67%;" /></p><p>图中sample指在数据集中采样了134k的正样本对，full指使用整个数据集。最后两行是使用NLI任务中的entailment对做正样本，contradiction对做负样本（把neutral对丢了）</p><ul><li>作者发现<strong>使用NLI任务的数据集效果最显著，并且加上hard negative能进一步提升表现</strong></li><li>并且作者还又尝试使用两个encoder，但是表现下降了</li></ul><h3 id="3-2-基本方法"><a href="#3-2-基本方法" class="headerlink" title="3.2 基本方法"></a>3.2 基本方法</h3><ul><li>相比于无监督，有监督将每个样本对<script type="math/tex">(x_i, x_i^+)</script>拓展为了三元组<script type="math/tex">(x_i,x_i^+,x_i^-)</script>，其中<script type="math/tex">x_i^+</script>和<script type="math/tex">x_i^-</script>分别为<script type="math/tex">x_i</script>的entailment样本和contradiction样本，然后采用以下loss：</li></ul><script type="math/tex; mode=display">-\log \frac{e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{i}^{+}\right) / \tau}}{\sum_{j=1}^{N}\left(e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{j}^{+}\right) / \tau}+e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{j}^{-}\right) / \tau}\right)}</script><ul><li>但是从<strong>直观上</strong>来讲，区分难负例（矛盾文本）和Batch内其他负例可能是有益的，所以将有监督学习SimCSE的训练目标变成：</li></ul><script type="math/tex; mode=display">-\log \frac{e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{i}^{+}\right) / \tau}}{\sum_{j=1}^{N}\left(e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{j}^{+}\right) / \tau}+\alpha^{\mathbb{1}_{i}^{j}} e^{\operatorname{sim}\left(\mathbf{h}_{i}, \mathbf{h}_{j}^{-}\right) / \tau}\right)}</script><p>其中<script type="math/tex">1_i^j \in \{0, 1\}</script>仅当<script type="math/tex">i=j</script>时为1</p><ul><li>作者对不同的<script type="math/tex">\alpha</script>进行了实验，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810165606726.png" alt="image-20220810165606726" style="zoom:80%;" /></p><p>其中N/A为不使用hard negative</p><ul><li><strong>由上表可以得到<script type="math/tex">\alpha=1</script>最合适（其实就是又退化回去了，没啥用……），并且将Neural的样本一起作为负例并不能提升表现</strong></li></ul><h1 id="4-各向异性问题"><a href="#4-各向异性问题" class="headerlink" title="4 各向异性问题"></a>4 各向异性问题</h1><ul><li>最近的研究发现了语言表征中的各向异性问题，<strong>即训练后的embeddings仅占据在向量空间中狭窄的部分，严重限制了向量的表现力</strong>。缓解这个问题的一个简单方法是<strong>后处理</strong>，可以<strong>消除主要的主成分或将embeddings映射到各向同性分布</strong>。另一种常见的解决方案是在<strong>训练过程中添加正则项</strong>。 而对比学习的优化目标可以改善缓解各向异性问题，当负例数趋近于无穷大时，对比学习目标的渐近表示为:</li></ul><script type="math/tex; mode=display">-\frac{1}{\tau} \underset{\left(x_{i}, x_{i}^{+}\right) \sim p_{p o s}}{E}\left[f(x)^{T} f\left(x^{+}\right)\right]+\underset{x \sim p_{\text {data }}}{E}\left[\log \underset{x^{-} \sim p_{\text {data }}}{E}\left[e^{f(x)^{T} f\left(x^{-}\right) / \tau}\right]\right]</script><p>其中，<strong>第一项使正例之间更相似，第二项使将负例之间分开。</strong>而第二项<strong>在优化过程中，会压平向量空间的奇异谱，因此对比学习有望缓解表征退化问题，提高句向量表征的均匀性</strong></p><ul><li>并且作者还针对不同的模型、不同的后处理方法、不同的数据扩充方法等，通过alignment和uniformity进行了实验：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810192852943.png" alt="image-20220810192852943" style="zoom:80%;" /></p><p>图中括号中的是再STS任务上的得分</p><ul><li>通过上图，可以得出以下结论：</li></ul><blockquote><ol><li>虽然预训练embeddings具有良好的对齐性，但其均匀性较差</li><li>后处理方法，如BERT-flow和BERT-whitening，大大改善均匀性，但也使其对齐性变差</li><li>无监督SimCSE有效地提高了预训练embeddings的均匀性，同时保持了良好的对齐性</li><li>有监督SimCSE，可以进一步提高对齐性</li></ol></blockquote><h1 id="5-对比试验"><a href="#5-对比试验" class="headerlink" title="5 对比试验"></a>5 对比试验</h1><h3 id="5-1-STS任务上的对比"><a href="#5-1-STS任务上的对比" class="headerlink" title="5.1 STS任务上的对比"></a>5.1 STS任务上的对比</h3><ul><li>作者先在7个STS任务上进行了对比实验，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810170503226.png" alt="image-20220810170503226" style="zoom:70%;" /></p><ul><li>可以发现，无监督和有监督的SimCSE均取得了SOTA的效果，并且同时适用于BERT和RoBERTa</li></ul><h3 id="5-2-Pooling方式"><a href="#5-2-Pooling方式" class="headerlink" title="5.2 Pooling方式"></a>5.2 Pooling方式</h3><ul><li>在实验中，是采用[CLS]的表征进行分类的，但是有其他文章表示使用embedding的平均能提升表现。并且如果采用[CLS]，原始的BERT在其之后添加了一个额外的MLP层，本文对MLP同样有三种pooling方式：(1)、保留MLP层；(2)、丢弃MLP层；(3)、训练时采用MLP层，测试时丢弃。实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810172926336.png" alt="image-20220810172926336" style="zoom:80%;" /></p><ul><li>从结果中得知：<strong>无监督在train中使用MLP，test中丢弃MLP表现最好；有监督不同的pooling方法不是差别不是很大</strong></li><li><strong>作者选择在无监督中使用MLP(train)，而在有监督中使用with MLP</strong></li></ul><h3 id="5-3-召回任务的结果"><a href="#5-3-召回任务的结果" class="headerlink" title="5.3 召回任务的结果"></a>5.3 召回任务的结果</h3><ul><li>作者还使用<script type="math/tex">SBERT_{base}</script>和<script type="math/tex">SimCSE-BERT_{base}</script>进行了一个小规模的召回实验，给定query，找出相似的句子（基于余弦相似度），结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810185441782.png" alt="image-20220810185441782"></p><ul><li>结果是，SimCSE找出的句子质量更高</li></ul><h3 id="5-4-温度超参和相似度函数的选择"><a href="#5-4-温度超参和相似度函数的选择" class="headerlink" title="5.4 温度超参和相似度函数的选择"></a>5.4 温度超参和相似度函数的选择</h3><ul><li>作者尝试使用了不同的<script type="math/tex">\tau</script>超参，并且尝试用点积代替余弦相似度，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810194557958.png" alt="image-20220810194557958"></p><p>N\A表示点积代替余弦相似度</p><ul><li>发现<strong>使用余弦相似度更合适，并且<script type="math/tex">\tau=0.05</script>表现最好</strong></li></ul><h1 id="6-下游任务上的表现"><a href="#6-下游任务上的表现" class="headerlink" title="6 下游任务上的表现"></a>6 下游任务上的表现</h1><ul><li>作者还在各种下游任务上进行了对比，并且加上了MLM任务（BERT中的MLM任务），<strong>避免模型彻底的忘记token-level的知识，并发现加上MLM后可以在除STS任务外的其他下游任务上取得提升</strong>，加上MLM后，训练目标由原本的<script type="math/tex">\ell</script>变成了<script type="math/tex">\ell + \lambda \cdot \ell ^{MLM}</script></li></ul><h3 id="6-1-MLM的对比"><a href="#6-1-MLM的对比" class="headerlink" title="6.1 MLM的对比"></a>6.1 MLM的对比</h3><ul><li>作者对比了在STS任务和其他下游任务上，加与不加MLM的结果对比，以及<script type="math/tex">\lambda</script>超参的选择：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810195101507.png" alt="image-20220810195101507"></p><ul><li>结果说明，<strong>添加token-level对于其他大多数下游任务都有提升，并且<script type="math/tex">\lambda=0.1</script>最为合适，但是这会带来STS任务表现的下降</strong></li></ul><h3 id="6-2-下游任务的对比"><a href="#6-2-下游任务的对比" class="headerlink" title="6.2 下游任务的对比"></a>6.2 下游任务的对比</h3><ul><li>最后作者给出了在各种模型、训练策略、处理方式等因素不同时，在各种下游任务上的表现：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810195709648.png" alt="image-20220810195709648" style="zoom:80%;" /></p><ul><li>可以发现在迁移任务上该方法并没有做到最好，不过这也证明了作者的说法，句子级别的目标可能并不会有益于下游任务的训练，训练好的句子向量表示模型也并不是为了更好的适应下游任务，但是SimCSE也在许多任务上做到了SOTA，特别是带MLM的时候</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>EDA和AEDA</title>
    <link href="/2022/09/24/EDA%E5%92%8CAEDA/"/>
    <url>/2022/09/24/EDA%E5%92%8CAEDA/</url>
    
    <content type="html"><![CDATA[<ul><li>本节主要介绍NLP领域的两种简单数据扩充方法：<strong>EDA和AEDA</strong></li><li>还有许多其他的数据扩充方法， 例如将文本进行back-translation，即将文本翻译一次又翻译回去，从而扩充文本，还可以通过各种深度学习模型进行扩充。<strong>但是这些方法都太过”expensive”，而EDA和AEDA就相比之下比较简单，只需要在输入文本之前一定的预处理即可。</strong></li></ul><h1 id="1-EDA"><a href="#1-EDA" class="headerlink" title="1 EDA"></a>1 EDA</h1><h3 id="1-1-EDA的基本方法"><a href="#1-1-EDA的基本方法" class="headerlink" title="1.1 EDA的基本方法"></a>1.1 EDA的基本方法</h3><ul><li><p><strong>EDA的基本方法包括四种：</strong></p><blockquote><ol><li><strong>Synonym Replacement (SR，同义词替换)：</strong>随机挑选n个词<strong>（不能是停用词）</strong>，然后将每个词随机替换成同义词</li><li><strong>Random Insertion (RI，随机插入)：</strong>挑选随机词<strong>（不能是停用词）</strong>的随机同义词，插入随机位置，进行n次</li><li><strong>Random Swap (RS，随机交换)：</strong>随机挑选两个词，交换位置，进行n次</li><li><strong>Random Deletion (RD，随机删除)：</strong>使用概率p随机删除每个词</li></ol></blockquote></li><li><p>EDA的做法是，<strong>对输入的句子进行改变，但是尽量不改变其句意，也就是使句意和true label尽量对应</strong>，所以使用同义词替换等方法来增加噪音，但不能增加过多。其中，对于长句子，相比于短句子，能吸收更多的噪音，更能保持true label</p></li><li>进行SR和RI时，不是选择随机词进行操作，而是使用同义词，<strong>目的就是为了尽量不改变原始句意</strong></li><li><strong>超参的选择：</strong></li></ul><blockquote><p>假设句子长度为<script type="math/tex">l</script>，则<script type="math/tex">n=\alpha l</script>，<script type="math/tex">\alpha</script>表明了多少比例的词语会被改变。并且对于RD，我们使用<script type="math/tex">p=\alpha</script>。对于每个句子，我们创造<script type="math/tex">n_{aug}</script>个扩充句子</p></blockquote><h3 id="1-2-EDA不同模型上的表现"><a href="#1-2-EDA不同模型上的表现" class="headerlink" title="1.2 EDA不同模型上的表现"></a>1.2 EDA不同模型上的表现</h3><ul><li>可以看到，EDA在RNN和CNN上实现了准确率的提升，并且对于小数据集，提升更为明显</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808144843149.png" alt="image-20220808144843149" style="zoom: 80%;" /></p><h3 id="1-3-不同数据集大小对EDA的影响"><a href="#1-3-不同数据集大小对EDA的影响" class="headerlink" title="1.3 不同数据集大小对EDA的影响"></a>1.3 不同数据集大小对EDA的影响</h3><ul><li>作者对多个数据集进行了测试，并且在最后（图f）给出了在所有数据集上的平均结果，以探究不同大小的数据集对EDA效果的影响：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808145353524.png" alt="image-20220808145353524" style="zoom:90%;" /></p><ul><li>在图f中，不使用EDA的最高准确率是88.3%，是在使用所有数据集时实现的。但是使用EDA时最高准确率为88.6%，<strong>甚至只是用了一半的源数据</strong></li><li><strong>总的来说，EDA对于小数据集的影响更大</strong></li></ul><h3 id="1-4-EDA是否会影响True-Label"><a href="#1-4-EDA是否会影响True-Label" class="headerlink" title="1.4 EDA是否会影响True Label"></a>1.4 EDA是否会影响True Label</h3><ul><li><strong>作者的实验步骤是：</strong>对于一个pro-con分类任务（PC），先不应用EDA进行训练，然后在测试集上，进行数据扩充（每个源数据扩充九个数据），将源数据和扩充数据一起输入模型测试，将最后一个dense层得到的向量使用t-SNE表示，然后得到如下结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808150515348.png" alt="image-20220808150515348" style="zoom:80%;" /></p><ul><li>可以看到<strong>扩充数据的潜在语义空间是接近源数据的</strong>，所以对于多数情况，EDA是不会改变true label的</li></ul><h3 id="1-5-消融实验"><a href="#1-5-消融实验" class="headerlink" title="1.5 消融实验"></a>1.5 消融实验</h3><ul><li>EDA是四种扩充方法的结合，而对于这四种方法，作者通过每次分别只使用一次方法，来探究四种方法各自的贡献和效果。并且对不同的<script type="math/tex">\alpha</script>取值进行选取：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808151914033.png" alt="image-20220808151914033" style="zoom:90%;" /></p><ul><li><p>四种操作都获得了一定的提升，其中：</p><blockquote><ul><li><strong>对于SR：</strong>使用小的<script type="math/tex">\alpha</script>获得了提升，但是过大的<script type="math/tex">\alpha</script>反而降低了表现，推测原因为：过多的替换改变了原本的句意</li><li><strong>对于RI：</strong>提升对于<script type="math/tex">\alpha</script>的改变不是特别敏感，更为稳定，推测原因为：原本的词和相对位置保留了下来</li><li><strong>对于RS：</strong>在<script type="math/tex">\alpha \le 0.2</script>时获得较大提升，但在<script type="math/tex">\alpha \ge 0.3</script>时出现了下降，推测原因为：交换过多的词其实就等同于将整个句子词语的顺序重新排列一遍</li><li><strong>对于RD：</strong>小<script type="math/tex">\alpha</script>有很大的提升，但是大的<script type="math/tex">\alpha</script>十分影响表现，推测原因为：删除过多的词使句子变得无法理解</li></ul></blockquote></li><li><p><strong>通过实验，作者推荐通常取<script type="math/tex">\alpha=0.1</script></strong></p></li></ul><h3 id="1-6-扩充几句最为合适"><a href="#1-6-扩充几句最为合适" class="headerlink" title="1.6 扩充几句最为合适"></a>1.6 扩充几句最为合适</h3><ul><li>其实就是对超参<script type="math/tex">n_{aug}</script>的选择，实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808154726577.png" alt="image-20220808154726577" style="zoom:80%;" /></p><ul><li>可以看到，对于小数据集，<script type="math/tex">n_{aug}</script>最好大一些，而大数据集则不需要那么多扩充数据</li><li>作者还给出了<strong>推荐的超参：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808155215524.png" alt="image-20220808155215524" style="zoom:90%;" /></p><h3 id="1-7-结论"><a href="#1-7-结论" class="headerlink" title="1.7 结论"></a>1.7 结论</h3><ul><li>尽管EDA实现了一定的提升，尤其是在小数据集上，但是仍有一定的<strong>限制</strong>：</li></ul><blockquote><ol><li>通过实验可以发现，<strong>EDA在数据充足时，提升的效果是十分有限的</strong>，基本都是1%不到</li><li>并且就算是使用小数据集，<strong>在使用pre-trained model时，如BERT等，得到的提升也是十分微小的</strong></li></ol></blockquote><ul><li>EDA的<strong>本质作用</strong>可以总结为以下两点：</li></ul><blockquote><ol><li>产生了一定程度的噪音，来<strong>阻止模型过拟合</strong></li><li>通过SR和RI操作，可以产生新的词典，使模型可以<strong>泛化在测试集中而不在训练集中的词</strong></li></ol></blockquote><h1 id="2-AEDA"><a href="#2-AEDA" class="headerlink" title="2 AEDA"></a>2 AEDA</h1><h3 id="2-1-AEDA的基本方法"><a href="#2-1-AEDA的基本方法" class="headerlink" title="2.1 AEDA的基本方法"></a>2.1 AEDA的基本方法</h3><ul><li>其实就是随机位置插入随机标点，<strong>插入次数选择<script type="math/tex">1 \sim \frac{1}{3}sentence\_length</script>的随机数</strong>，插入的标点符号为：<strong>{“.”, “;”, “?”, “:”, “!”, “,”}</strong>，举个栗子：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809125655875.png" alt="image-20220809125655875" style="zoom:67%;" /></p><ul><li>对比一下EDA，<strong>EDA的交换操作改变了文本顺序，并且删除操作会造成信息的损失，从而造成对模型的”misleading”</strong>。而AEDA则会保留文本的顺序和词语。作者还做了详细的实验进行验证和对比</li></ul><h3 id="2-2-EDA和AEDA的对比"><a href="#2-2-EDA和AEDA的对比" class="headerlink" title="2.2 EDA和AEDA的对比"></a>2.2 EDA和AEDA的对比</h3><ul><li>作者分别在CNN和RNN上进行了实验，进行数据扩充时，每个源数据扩充了16个数据，实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220808175040407.png" alt="image-20220808175040407" style="zoom:75%;" /></p><ul><li>可以看到EDA尽在小数据集上有所提升，但是在大数据集上表现更差了。但是AEDA在所有数据集上都有提升，尤其是在小数据集上更为明显。</li><li>作者认为造成这种结果的原因是：EDA的替换和删除操作给模型增加了许多”misleading”的信息</li></ul><blockquote><p>The reason why EDA does not perform well can be attributed to the operations such as deletion and substitution which insert more misleading information to the network as the number of augmentations grows. In contrast, AEDA keeps the original information in all augmentations  </p></blockquote><ul><li>此外，作者还通过不同的数据集，针对数据集大小展开了研究，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809125001403.png" alt="image-20220809125001403"></p><h3 id="2-3-扩充几句最为合适"><a href="#2-3-扩充几句最为合适" class="headerlink" title="2.3 扩充几句最为合适"></a>2.3 扩充几句最为合适</h3><ul><li>作者还探究了每个源数据扩充几句数据最为合适，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809125426286.png" alt="image-20220809125426286" style="zoom:70%;" /></p><ul><li>作者并没有在论文中指出最合适的超参，但是个人觉得大多数时候<strong>扩充一到两句</strong>就够了</li></ul><h3 id="2-4-对于BERT的提升"><a href="#2-4-对于BERT的提升" class="headerlink" title="2.4 对于BERT的提升"></a>2.4 对于BERT的提升</h3><ul><li>作者对于BERT模型，进行了加EDA和AEDA的对比，每个源数据只扩充了一句，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809132749401.png" alt="image-20220809132749401" style="zoom:80%;" /></p><ul><li>EDA反倒下降了表现（有可能是<script type="math/tex">n_{aug}</script>只有1），而AEDA实现了细微的提升（还是十分有限。。。）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BART总结</title>
    <link href="/2022/08/29/BART%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/29/BART%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li><p>作者提出了一种seq2seq的模型，是一种去噪自编码器，大体的设计思路是：<strong>使用随机的噪音破坏文本，然后使用该模型将模型恢复回来</strong>，模型的<strong>结构是BERT的Encoder+GPT的Decoder</strong>，取名叫做BART（Bidirectional and Auto-Regressive Transformers）</p></li><li><p>由于BART是seq2seq的模型，所以相比于BERT，可以拿来做翻译任务。并且通过实验发现，<strong>BART在文本生成和理解任务等方面是优于BERT的</strong></p></li><li><p>这种去噪自编码器的优点是：<strong>在无监督预训练时，可以学得更加鲁棒的特征</strong></p></li></ul><h1 id="1-BART的结构"><a href="#1-BART的结构" class="headerlink" title="1 BART的结构"></a>1 BART的结构</h1><ul><li>BART的结构就是BERT的Encoder+GPT的Decoder，<strong>对于Decoder，将原本的ReLu改为了GeLu。并且参数初始化改为服从<script type="math/tex">N(0, 0.02)</script></strong></li><li>base model分别有6个Encoder和Decoder，large model分别有12个</li><li>同等的规模，BART比BERT的参数量多10%</li><li><strong>BERT和GPT和BART的对比：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809212642716.png" alt="image-20220809212642716" style="zoom:90%;" /></p><p>BERT适合具有<strong>双向表征和可并行化的优点</strong>，但是由于其不是自回归的， 并且每个词是各自独立进行预测的，所以并<strong>不适合文本生成领域</strong>。而GPT由于其自回归性，可以用于文本生成。所以BART就将两者结合，结合两者有点，生成一个seq2seq模型，<strong>使输入和输出不需要对齐</strong>，可以用于文本生成、翻译等任务。</p><h1 id="2-BART的Pre-training"><a href="#2-BART的Pre-training" class="headerlink" title="2 BART的Pre-training"></a>2 BART的Pre-training</h1><ul><li>BART的预训练通过引入噪音破坏文本再恢复文本的方式进行学习，损失采用Decoder的输出和原文本的交叉熵</li><li><strong>BART相较于其他去噪自编码器最大的优点就是：它可以应用任何文本破坏方式，而不是特定的方法</strong></li></ul><blockquote><p>Unlike existing denoising autoencoders, which are tailored to specific noising schemes, BART allows us to apply any type of document corruption</p></blockquote><h3 id="2-1-BART中使用的破坏文本方式"><a href="#2-1-BART中使用的破坏文本方式" class="headerlink" title="2.1 BART中使用的破坏文本方式"></a>2.1 BART中使用的破坏文本方式</h3><ul><li><p><strong>Token Masking：</strong>BERT的Mask策略</p></li><li><p><strong>Token Deletion：</strong>随机删除词</p></li><li><p><strong>Text Infilling：</strong>采样多个文本片段，每个文本片段长度服从<script type="math/tex">\lambda = 3</script>的泊松分布<strong>（长度也可为0）</strong>，每个文本片段用<strong>单个</strong>[MASK] token替换，替换成单个[MASK]能够迫使模型学习到一个片段中所缺失的token数量</p></li><li><p><strong>Sentence Permutation：</strong>按句号将文档分割成多个句子，然后随机打乱这些句子。</p></li><li><p><strong>Document Rotation：</strong>随机均匀地选择一个token，再旋转文档使文档以该token作为起始。该任务的目的是训练模型识别文档开头</p></li><li><p>举个栗子：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809214445327.png" alt="image-20220809214445327" style="zoom:67%;" /></p><ul><li>BART的一个关键优势是噪声的随意性，可以动用任何方式(包括改变长度)对原始文本进行破坏。<strong>这种方式让模型学习过程中更多地考虑句子的整体长度，并对输入进行更大范围的转换，从而将BERT中MLM和NSP目标统一起来。</strong></li></ul><blockquote><p>This approach generalizes the original word masking and next sentence prediction objectives in BERT by forcing the model to reason more about overall sentence length and make longer range transformations to the input  </p></blockquote><h1 id="3-BART的Fine-tuning"><a href="#3-BART的Fine-tuning" class="headerlink" title="3 BART的Fine-tuning"></a>3 BART的Fine-tuning</h1><h3 id="3-1-句子分类任务"><a href="#3-1-句子分类任务" class="headerlink" title="3.1 句子分类任务"></a>3.1 句子分类任务</h3><ul><li>方法类似于使用BERT中的[CLS]。<strong>将相同的句子同时输入Encoder和Decoder，取Decoder最后一个时间步的输出</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809230327711.png" alt="image-20220809230327711" style="zoom:75%;" /></p><ul><li>这种方法很像seq2seq模型翻译任务中的做法，以上图为例，区别在于翻译任务只在Decoder中输入A、B、C、D，而不输入E，然后期望输出A、B、C、D、E。而在此句子分类任务中，输入A、B、C、D、E，期望输出A、B、C、D、E、Label，只取最后一个时间步的Label，用作分类。</li></ul><h3 id="3-2-Token分类和序列生成"><a href="#3-2-Token分类和序列生成" class="headerlink" title="3.2 Token分类和序列生成"></a>3.2 Token分类和序列生成</h3><ul><li><p><strong>Token分类：</strong>将整个文档输入encoder和decoder，每个token用其对应的最上方的decoder输出值用以分类</p></li><li><p><strong>序列生成：</strong>由于Decoder的自回归性，所以很适合序列生成，直接把数据输入进Encoder和Decoder（Decoder中输入的是label数据）即可</p></li></ul><h3 id="3-3-翻译任务"><a href="#3-3-翻译任务" class="headerlink" title="3.3 翻译任务"></a>3.3 翻译任务</h3><ul><li>翻译任务有所不同，<strong>在原本的Encoder前面又额外增加了一个随机初始化的Encoder</strong>，结构如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809232721147.png" alt="image-20220809232721147" style="zoom: 85%;" /></p><ul><li><strong>新加的Encoder作用是：先将外语输入进去，然后通过该Encoder将其编码成带噪音的目标端语言，然后再通过BART降噪，作用和pre-training类似</strong></li></ul><blockquote><p>These layers are trained to essentially translate the foreign language to noised English, by propagation through BART, thereby using BART as a pre-trained target-side language model</p></blockquote><ul><li>步骤：</li></ul><blockquote><ol><li>冻结BART的大部分参数，仅更新新增加的encoder、BART位置嵌入和BART每个encoder第一层的自注意力输入投影矩阵</li><li>将所有模型参数进行少量迭代训练</li></ol></blockquote><h1 id="4-对比试验"><a href="#4-对比试验" class="headerlink" title="4 对比试验"></a>4 对比试验</h1><ul><li>文章对比了不同预训练目标之间的影响，包括：</li></ul><blockquote><ol><li><strong>Language Model：</strong>与GPT类似，训练一个从左到右的Transformer语言模型。该模型相当于BART的decoder，只是没有交叉注意(cross-attention)</li><li><strong>Permuted Language Model：</strong>该模型基于XLNet，采样1/6的token，并以自回归的随机顺序生成。为了与其他模型保持一致，这里没有引入相对位置编码和XLNet中的片段级的循环注意力机制</li><li><p><strong>Masked Language Model：</strong>与BERT相同，15%的token用 [MASK] token替换，训练模型重建出这些被遮蔽掉的token</p></li><li><p><strong>Multitask Masked Language Model：</strong>与 UniLM 一样，使用额外self-attention mask训练带遮蔽的语言模型。自注意力遮蔽按如下比例随机选择:1/6从左到右；1/6从右到左；1/3未遮蔽；剩余的1/3中前50%的未遮蔽，其余的从左到右遮蔽</p></li><li><strong>Masked Seq-to-Seq：</strong>与MASS模型类似，遮蔽一个片段中50%的token，并训练一个序列到序列模型预测被遮蔽的tokens</li></ol></blockquote><ul><li>实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809235547649.png" alt="image-20220809235547649" style="zoom: 67%;" /></p><ul><li>通过实验对比，总结出如下结果：</li></ul><blockquote><ol><li>在不同的任务中，预训练方法的表现有显著差异。换句话说，预训练方法的有效性高度依赖于任务本身。比如，一个简单的语言模型在ELI5数据集上可以夺冠，但是在SQUAD上的结果却是最差的</li><li>遮蔽Token至关重要。只使用旋转文档或句子组合的预训练目标则效果较差，效果较好的都是使用了token的删除或遮蔽作为预训练目标。此外，在生成任务上，删除token似乎比遮蔽token更胜一筹</li><li>从左到右的预训练目标有助于文本生成任务。Masked Language Model和Permuted Language Model在文本生成任务上不如其他模型。而这两种模型在预训练阶段都没有用到从左到右的自回归语言模型</li><li>对于SQuAD而言双向的encoder至关重要。因为上下文在分类决策中至关重要</li><li>预训练目标并不是唯一重要的因素。这里的Permuted Language Model略逊于XLNet，其中一些差异可能是由于没有使用XLNet架构中的其他的改进，如相对位置编码和片段级的循环机制</li><li>Language Model在ELI5数据集上技压群雄，其困惑度远优于其他模型。这表明当输出仅受到输入的松散约束时，BART较为低效</li></ol></blockquote><ul><li>同时实验还对比了几种文本破坏方法对任务的贡献到底有多少，发现<strong>使用Text Infilling或Text Infilling + Sentence Shuffling得到的效果最好</strong></li></ul><h1 id="5-在各种下游任务上的表现"><a href="#5-在各种下游任务上的表现" class="headerlink" title="5 在各种下游任务上的表现"></a>5 在各种下游任务上的表现</h1><ul><li>在此实验中，使用large规模的模型，预训练使用RoBerta的batch size=8000和steps=500000，以及使用BPE。预处理使用了text infilling和sentence permutation，并且mask掉了30%的token，重排所有句子  </li></ul><h3 id="5-1-自然语言理解任务"><a href="#5-1-自然语言理解任务" class="headerlink" title="5.1 自然语言理解任务"></a>5.1 自然语言理解任务</h3><ul><li>结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810000923604.png" alt="image-20220810000923604" style="zoom:80%;" /></p><ul><li>BART在自然语言理解任务上与其他先进模型不相上下。这表明<strong>BART在生成任务上的进一步突破并不是以牺牲自然语言理解性能为代价</strong></li></ul><h3 id="5-2-自然语言生成任务"><a href="#5-2-自然语言生成任务" class="headerlink" title="5.2 自然语言生成任务"></a>5.2 自然语言生成任务</h3><ul><li><p>在微调时，使用了label smooth的交叉熵损失，平滑参数为0.1。并在生成时使用大小为5的束搜索</p></li><li><p>文本摘要任务结果：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810001908759.png" alt="image-20220810001908759" style="zoom:80%;" /></p><ul><li><p>在这两个摘要任务上，BART 在所有度量指标上均优于之前的模型，但与人类的摘要结果相比仍然有差距</p></li><li><p>对话生成任务结果：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810002027643.png" alt="image-20220810002027643" style="zoom:80%;" /></p><ul><li>BART 在对话生成任务上的性能同样优于之前的模型</li><li>抽象QA任务结果：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810002302848.png" alt="image-20220810002302848" style="zoom:80%;" /></p><h3 id="5-3-翻译任务"><a href="#5-3-翻译任务" class="headerlink" title="5.3 翻译任务"></a>5.3 翻译任务</h3><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220810002422747.png" alt="image-20220810002422747" style="zoom:80%;" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RoBERTa总结</title>
    <link href="/2022/08/09/RoBERTa%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/09/RoBERTa%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li>作者评估了BERT中的各种超参和数据集大小以及训练策略等方面，发现<strong>BERT是训练不足的</strong></li></ul><h1 id="1-RoBERTa的主要改变"><a href="#1-RoBERTa的主要改变" class="headerlink" title="1  RoBERTa的主要改变"></a>1  RoBERTa的主要改变</h1><ul><li>作者提出了RoBERTa（A Robustly Optimized BERT Pretraining Approach），是BERT的变体，主要的更改如下：</li></ul><blockquote><ol><li>用更多的数据和更大的batch size，训练更长的时间</li><li>去除了NSP</li><li>在更长的句子上训练</li><li>进行动态的mask</li></ol></blockquote><ul><li>在优化器方面也有细微改变，改变了最大学习率和warmup steps，并且把<script type="math/tex">\beta_2</script>改为了0.98，在更大的batch size上训练时，得到了更稳定的结果</li></ul><h1 id="2-训练策略的改变"><a href="#2-训练策略的改变" class="headerlink" title="2 训练策略的改变"></a>2 训练策略的改变</h1><h3 id="2-1-动态和静态mask"><a href="#2-1-动态和静态mask" class="headerlink" title="2.1 动态和静态mask"></a>2.1 动态和静态mask</h3><ul><li><strong>两种mask策略：</strong></li></ul><blockquote><ol><li>静态mask：原BERT中使用的方法，在数据预处理时，进行mask。在本实验中，为了避免出现每个epoch的mask的位置都相同，在40个epoch中进行了10次随机mask，这样每个mask实例只会出现4次</li><li>动态mask：在每次数据喂入模型时进行mask，这样每次mask的位置都不同</li></ol></blockquote><ul><li>实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809143220226.png" alt="image-20220809143220226" style="zoom:80%;" /></p><ul><li><strong>动态mask相对于静态mask得到了细微的提升（稍微有丁点卵用）</strong></li></ul><h3 id="2-2-模型的输入形式和NSP任务"><a href="#2-2-模型的输入形式和NSP任务" class="headerlink" title="2.2 模型的输入形式和NSP任务"></a>2.2 模型的输入形式和NSP任务</h3><ul><li><strong>使用了4种输入策略：</strong></li></ul><blockquote><ol><li><strong>SEGMENT-PAIR+NSP：</strong>原BERT使用的方法，<strong>输入是一个segment对，每个segment可以包括多个句子</strong>，只要总长度小于512就行，带有NSP Loss</li><li><strong>SENTENCE-PAIR+NSP：</strong>和前者类似，<strong>只是每个segment只能是单个句子</strong>，同样带有NSP Loss。由于两个单句子一般长度都远远不足512，为了实验公平，作者适当的增加了其实验数据</li><li><strong>FULL-SENTENCES：输入是从一个或多个文档中采样的一个full-sentence（可由多个句子组成）</strong>，当采样到文档的最后时，可以继续采下一个文档的句子，但是需要在中间加一个额外的分隔token。<strong>无NSP Loss</strong></li><li><strong>DOC-SENTENCES：和前者类似，但是不能跨文档采样，无NSP Loss</strong>。在靠近文档末尾采样，句子长度会较短，所以同样为了实验公平，适当的增加了数据</li></ol></blockquote><ul><li>实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809150834375.png" alt="image-20220809150834375" style="zoom:75%;" /></p><ul><li>将前两种策略进行对比，<strong>可以发现使用单个句子会降低表现，推测原因为：这样模型无法学到长范围的依赖关系</strong></li></ul><blockquote><p>We find that using individual sentences hurts performance on downstream tasks, which we hypothesize is because the model is not able to learn long-range dependencies.  </p></blockquote><ul><li>再对比前两种和后两种策略，<strong>可以发现移除NSP任务，也可以得到细微的提升</strong></li></ul><blockquote><p>Removing the NSP loss matches or slightly improves downstream task performance.</p></blockquote><ul><li>对比后两种策略，<strong>可以发现不跨文档比跨文档稍好一点</strong></li></ul><h3 id="2-3-使用更大的Batch-Size"><a href="#2-3-使用更大的Batch-Size" class="headerlink" title="2.3 使用更大的Batch Size"></a>2.3 使用更大的Batch Size</h3><ul><li>作者使用相同的数据量，但是不同的batch size，来探究batch size的影响，结构如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809152515016.png" alt="image-20220809152515016" style="zoom:80%;" /></p><p>图中bsz为batch size，ppl为困惑度</p><h3 id="2-4-分词方式"><a href="#2-4-分词方式" class="headerlink" title="2.4 分词方式"></a>2.4 分词方式</h3><ul><li>原版BERT使用char-level的BPE（也就是wordpiece），而本文使用byte-level的BPE，增加了词典大小，和增加了一些参数量，表现还有细微的下降😅，但是基本相同</li></ul><blockquote><ul><li><p>基于 char-level ：原始 BERT 的方式，它通过对输入文本进行启发式的词干化之后处理得到。</p></li><li><p>基于 bytes-level：与 char-level 的区别在于bytes-level 使用 bytes 而不是 unicode 字符作为 sub-word 的基本单位，因此可以编码任何输入文本而不会引入 UNKOWN 标记。</p></li></ul><ul><li>当采用 bytes-level 的 BPE 之后，词表大小从3万（原始 BERT 的 char-level ）增加到5万。这分别为 BERT-base和 BERT-large增加了1500万和2000万额外的参数</li></ul></blockquote><h1 id="3-对比试验"><a href="#3-对比试验" class="headerlink" title="3 对比试验"></a>3 对比试验</h1><ul><li>对于实验用于探究预训练数据量的多少和训练时间对表现的影响，实验采用Large的模型规模，并且RoBERTa采用：动态mask + FULL_SENTENCES without NSP + 大batch size + byte-level BPE，实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809164004895.png" alt="image-20220809164004895" style="zoom:75%;" /></p><ul><li><p><strong>可以看到在相同数据量条件下，RoBERTa相比于BERT有较大提升</strong></p></li><li><p><strong>并且增加数据量可以得到显著的提升，增加训练时间同样可以得到细微提升，并且没有造成过拟合</strong></p></li></ul><h1 id="4-在特定下游任务的表现"><a href="#4-在特定下游任务的表现" class="headerlink" title="4 在特定下游任务的表现"></a>4 在特定下游任务的表现</h1><h3 id="4-1-GLUE"><a href="#4-1-GLUE" class="headerlink" title="4.1 GLUE"></a>4.1 GLUE</h3><ul><li>实验考虑了<script type="math/tex">batch\_size \in \{16, 32\}</script>，<script type="math/tex">lr \in \{1e-5, 2e-5, 3e-5\}</script>，并在前6%的steps使用线性warm up，之后使用线性衰减至0，使用10个epochs，但是设置了early stop，实验结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809170036407.png" alt="image-20220809170036407" style="zoom:75%;" /></p><h3 id="4-2-SQuAD"><a href="#4-2-SQuAD" class="headerlink" title="4.2 SQuAD"></a>4.2 SQuAD</h3><ul><li>在本实验中，XLNET和BERT都加上了QA数据集，但是RoBERTa仅使用了SQuAD。并且XLNET使用了逐层不同的学习率，结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809170501845.png" alt="image-20220809170501845" style="zoom:70%;" /></p><h3 id="4-3-RACE"><a href="#4-3-RACE" class="headerlink" title="4.3 RACE"></a>4.3 RACE</h3><ul><li>一个做阅读理解的数据集，让模型从4个答案中选出一个最合适的。结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809170610509.png" alt="image-20220809170610509" style="zoom:80%;" /></p><h1 id="5-超参"><a href="#5-超参" class="headerlink" title="5 超参"></a>5 超参</h1><ul><li><strong>预训练：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809170735173.png" alt="image-20220809170735173" style="zoom:50%;" /></p><ul><li><strong>微调：</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220809170753600.png" alt="image-20220809170753600" style="zoom:67%;" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码总结（持续更新）</title>
    <link href="/2022/07/17/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/17/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="NLTK用法"><a href="#NLTK用法" class="headerlink" title="NLTK用法"></a>NLTK用法</h1><ul><li>nltk用于<strong>英文</strong>分词分句等应用</li></ul><h3 id="基本的预处理"><a href="#基本的预处理" class="headerlink" title="基本的预处理"></a>基本的预处理</h3><ul><li><strong>分句：nltk.sent_tokenize(text, language=”english”):</strong></li></ul><blockquote><p>输入：一个str段落</p><p>输出：一个list，每个元素是一个str句子</p></blockquote><ul><li><strong>分词：nltk.word_tokenize(text, language=”english”, preserve_line=False):</strong></li></ul><blockquote><p>输入：一个str句子</p><p>输出：一个list，每个元素是一个str词</p></blockquote><ul><li><strong>词性标注（POS_tag）：nltk.postag(tokens)</strong></li></ul><blockquote><p>输入：一个list，每个元素是一个str，一个句子分好词的结果</p><p>输入：一个list，每个元素是一个tuple，tuple[0]是对应的token，tuple[1]是对应的词性，示例：[(‘football’, ‘NN’), (‘is’, ‘VBZ’), (‘a’, ‘DT’), (‘family’, ‘NN’)]</p><p>词性所对应的意义，大致来说<strong>N开头对应名词NOUN，V开头对应动词VERB，J开头对应形容词ADJ，R开头对应副词ADV</strong></p><p>词性具体所对应意义如下：</p><div class="table-container"><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>CC</td><td>连词</td><td>and, or,but, if, while,although</td></tr><tr><td>CD</td><td>数词</td><td>twenty-four, fourth, 1991,14:24</td></tr><tr><td>DT</td><td>限定词</td><td>the, a, some, most,every, no</td></tr><tr><td>EX</td><td>存在量词</td><td>there, there’s</td></tr><tr><td>FW</td><td>外来词</td><td>dolce, ersatz, esprit, quo,maitre</td></tr><tr><td>IN</td><td>介词连词</td><td>on, of,at, with,by,into, under</td></tr><tr><td>JJ</td><td>形容词</td><td>new,good, high, special, big, local</td></tr><tr><td>JJR</td><td>比较级词语</td><td>bleaker braver breezier briefer brighter brisker</td></tr><tr><td>JJS</td><td>最高级词语</td><td>calmest cheapest choicest classiest cleanest clearest</td></tr><tr><td>LS</td><td>标记</td><td>A A. B B. C C. D E F First G H I J K</td></tr><tr><td>MD</td><td>情态动词</td><td>can cannot could couldn’t</td></tr><tr><td>NN</td><td>名词</td><td>year,home, costs, time, education</td></tr><tr><td>NNS</td><td>名词复数</td><td>undergraduates scotches</td></tr><tr><td>NNP</td><td>专有名词</td><td>Alison,Africa,April,Washington</td></tr><tr><td>NNPS</td><td>专有名词复数</td><td>Americans Americas Amharas Amityvilles</td></tr><tr><td>PDT</td><td>前限定词</td><td>all both half many</td></tr><tr><td>POS</td><td>所有格标记 ’</td><td>‘s</td></tr><tr><td>PRP</td><td>人称代词</td><td>hers herself him himself hisself</td></tr><tr><td>PRP$</td><td>所有格</td><td>her his mine my our ours</td></tr><tr><td>RB</td><td>副词</td><td>occasionally unabatingly maddeningly</td></tr><tr><td>RBR</td><td>副词比较级</td><td>further gloomier grander</td></tr><tr><td>RBS</td><td>副词最高级</td><td>best biggest bluntest earliest</td></tr><tr><td>RP</td><td>虚词</td><td>aboard about across along apart</td></tr><tr><td>SYM</td><td>符号</td><td>% &amp; ’ ‘’ ‘’. ) )</td></tr><tr><td>TO</td><td>词to</td><td>to</td></tr><tr><td>UH</td><td>感叹词</td><td>Goodbye Goody Gosh Wow</td></tr><tr><td>VB</td><td>动词</td><td>ask assemble assess</td></tr><tr><td>VBD</td><td>动词过去式</td><td>dipped pleaded swiped</td></tr><tr><td>VBG</td><td>动词现在分词</td><td>telegraphing stirring focusing</td></tr><tr><td>VBN</td><td>动词过去分词</td><td>multihulled dilapidated aerosolized</td></tr><tr><td>VBP</td><td>动词现在式非第三人称时态</td><td>predominate wrap resort sue</td></tr><tr><td>VBZ</td><td>动词现在式第三人称时态</td><td>bases reconstructs marks</td></tr><tr><td>WDT</td><td>Wh限定词</td><td>who,which,when,what,where,how</td></tr><tr><td>WP</td><td>WH代词</td><td>that what whatever</td></tr><tr><td>WP$</td><td>WH代词所有格</td><td>whose</td></tr><tr><td>WRB</td><td>WH副词</td></tr></tbody></table></div></blockquote><ul><li><strong>词形还原Lemmatization：nltk.stem.WordNetLemmatizer().lemmatize(word, pos=”n”)：</strong></li></ul><blockquote><p>这是一个类的内置方法，首先需要创建WordNetLemmatizer对象（假设为wnl），则通过<code>wnl.lemmatize()</code>调用</p><p>输入：word是单个词，pos是其对应的单词词性（n对应noun，v对应verb，a对应adj，r对应adv，s对应satellite adjectives(不咋用)）</p><p>输出：word经过还原后的词，如cars还原为car</p></blockquote><h3 id="NER"><a href="#NER" class="headerlink" title="NER"></a>NER</h3><ul><li>先介绍一下命名实体识别（Named Entity Recognition，NER）是信息提取、问答系统、句法分析、机器翻译等应用领域的重要基础工具，在自然语言处理技术走向实用化的过程中占有重要地位。一般来说，命名实体识别的任务就是识别出待处理文本中三大类（实体类、时间类和数字类）、七小类（人名、机构名、地名、时间、日期、货币和百分比）命名实体。</li><li>nltk中对NER类别的分类如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/20191219223810610.png" alt="img"></p><p>其中LOCATION和GPE有重合，GPE通常表示地理—政治条目，比如城市，州，国家，洲等。LOCATION除了上述内容外，还能表示名山大川等。FACILITY通常表示知名的纪念碑或人工制品等。</p><ul><li><strong>进行NER：ne_chunk(tagged_tokens, binary=False)</strong></li></ul><blockquote><p>输入：tagged_tokens为<code>pos_tag()</code>函数的输出，一个list，每个元素是一个tuple，tuple[0]是对应的token，tuple[1]是对应的词性，示例：[(‘football’, ‘NN’), (‘is’, ‘VBZ’), (‘a’, ‘DT’), (‘family’, ‘NN’)]</p><p>输出：同样的是一个list，每个元素变为了一个封装对象（Tree类），和输入一一对应</p><ul><li><strong>对于该封装对象：</strong></li></ul><p>输出的list中，有些元素是没有NER的结果的，其对应的封装对象没有label属性，<strong>可使用<code>hasattr(ne_word, &#39;label&#39;)</code>函数判断是否有NER结果</strong></p><p>假设一个该对象命名为ne_word，调用<code>ne_word.leaves()</code>可返回一个list，每个元素为一个tuple，tuple[0]为token，tuple[1]为该token的pos_tag。对于NER，list中只有一个tuple，返回结果示例：[(‘FIFA’, ‘NNP’)]</p><p>调用<code>ne_word.label()</code>函数可返回该token对应的NER结果，一定要先使用<code>hasattr()</code>函数才能使用<code>label()</code>函数</p></blockquote><h3 id="计算BLEU"><a href="#计算BLEU" class="headerlink" title="计算BLEU"></a>计算BLEU</h3><ul><li><p><a href="https://zlkqz.top/2022/02/20/NLP%E5%9F%BA%E7%A1%80/#5-%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91">BLEU的定义</a></p></li><li><p><strong>nltk.translate.bleu_score.sentence_bleu(references, hypothesis, …, smoothing_function=None, …)</strong></p></li></ul><blockquote><p>references：参照序列，label。<strong>type=list(list(str))，其中的每个str为词或字</strong></p><p>hypothesis：候选序列，也就是预测出的序列。<strong>type=list(str)，其中的每个str为词或字</strong></p><p>smoothing_function，是论文中使用到的平滑技巧，一般输入<code>nltk.translate.bleu_score.SmoothingFunction().methodi()</code>，最后的i为0~7</p></blockquote><ul><li>另外还可以使用<code>corpus_bleu()</code>计算多个句子的BLEU；用<code>modified_precision()</code>计算修正的n-gram精确度</li></ul><h1 id="Pyltp用法"><a href="#Pyltp用法" class="headerlink" title="Pyltp用法"></a>Pyltp用法</h1><ul><li>Pyltp主要用于中文的预处理等，包括中文分词、词性标注、命名实体识别、依存句法分析、语义角色标注</li><li>使用Pyltp时注意其编码使用的都是utf-8，而Windows终端使用GBK编码，如果出现乱码可以将输出重定向到文件，然后用utf-8编码查看</li><li><strong>分句：pyltp.SentenceSplitter()</strong></li></ul><blockquote><p>使用时先创建实例：<code>sp = SentenceSplitter()</code>，再进行分句：<code>sents = sp.split(doc)</code></p></blockquote><ul><li><strong>分词：pyltp.Segmentor()</strong></li></ul><blockquote><p>Segmentor加载模型可以用<code>load()</code>也可以用<code>load_with_lexicon()</code>，后者还要加一个用户词典的参数</p></blockquote><ul><li><strong>词性标注：pyltp.Postagger()</strong></li></ul><blockquote><p>直接举个栗子吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">sent = <span class="hljs-string">&quot;据韩联社12月28日反映，美国防部发言人杰夫·莫莱尔27日表示，美国防部长盖茨将于2011年1月14日访问韩国。&quot;</span><br><span class="hljs-comment"># 加载模型</span><br>segmentor = Segmentor()<br>segmentor.load_with_lexicon(cws_model_path, lexicon_path)<br>postagger = Postagger()<br>postagger.load(pos_model_path)<br><span class="hljs-comment"># 分词和词性标注</span><br>words = segmentor.segment(sent)<br>postags = postagger.postag(words)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(postags))<br><span class="hljs-comment"># 释放模型</span><br>segmentor.release()<br>postagger.release()<br></code></pre></td></tr></table></figure><p>注意：进行这些处理后返回的都是VectorOfString类，是一个可迭代类，也可用list()转换为列表</p><p>词性标注的词性如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220724143414199.png" alt="image-20220724143414199" style="zoom: 50%;" /></p><p>词性标注也可以添加用户词典</p></blockquote><ul><li><strong>NER识别：pyltp.NamedEntityRecognizer()</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyltp <span class="hljs-keyword">import</span> NamedEntityRecognizer<br>recognizer = NamedEntityRecognizer()<br>recognizer.load(ner_model_path)<br>ner_results = recognizer.recognize(words, postags)<br></code></pre></td></tr></table></figure><p>LTP 采用 BIESO 标注体系。<strong>B 表示实体开始词，I表示实体中间词，E表示实体结束词，S表示单独成实体，O表示不构成命名实体。</strong></p><p>LTP 提供的命名实体类型为：<strong>人名（Nh）、地名（Ns）、机构名（Ni）</strong>。</p><p>B、I、E、S位置标签和实体类型标签之间用一个横线 <code>-</code> 相连；O标签后没有类型标签。</p></blockquote><ul><li><strong>依存句法分析：pyltp.Parser()</strong></li></ul><blockquote><p>依存语法 (Dependency Parsing, DP) 通过分析语言单位内成分之间的依存关系揭示其句法结构。 直观来讲，依存句法分析识别句子中的“主谓宾”、“定状补”这些语法成分，并分析各成分之间的关系</p><p>首先也是创建实例和加载模型，然后<code>parse_results = parser.parse(words, postags)</code>，得到的结果是一个可迭代对象，其中的每一个元素也是个自定义类（假设parse_results[i]为result），调用<code>result.head</code>和<code>result.relation</code>可分别获得words[i]对应的关系词和关系，其中head是返回关系词所对应的索引+1，如果为0则为”Root”，表示无对应关系词</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">relations = [result.relation <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> parse_results]<br>heads = [words[result.head - <span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> result.head <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Root&quot;</span> <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> parse_results]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(words)):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;relations[i]&#125;</span> : (<span class="hljs-subst">&#123;words[i]&#125;</span>, <span class="hljs-subst">&#123;heads[i]&#125;</span>)&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><div align=center><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220724211345194.png" alt="image-20220724211345194" style="zoom: 80%;" /></p><p>依存句法关系如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220724153110907.png" alt="image-20220724153110907" style="zoom:50%;" /></p></blockquote><ul><li><strong>语义角色标注：pyltp.SementicRoleLabeller()</strong></li></ul><blockquote><p>语义角色标注是实现浅层语义分析的一种方式。在一个句子中，谓词是对主语的陈述或说明，指出“做什么”、“是什么”或“怎么样，代表了一个事件的核心，跟谓词搭配的名词称为论元。语义角色是指论元在动词所指事件中担任的角色。主要有：施事者（Agent）、受事者（Patient）、客体（Theme）、经验者（Experiencer）、受益者（Beneficiary）、工具（Instrument）、处所（Location）、目标（Goal）和来源（Source）等<br>进行语义角色标注时首先同样是创建实例，再加载模型，然后调用方法：<code>roles = labeller.label(words, postags, parse_results)</code>。结果得到一个可迭代对象，<strong>其中的每一个元素也是一个自定义类（假设每个元素为role），则<code>role.index</code>为谓语对应的索引，<code>role.arguments</code>又是一个可迭代对象，每个元素对应一个和该谓语对应的语义角色，也是一个自定义类（假设为argument），</strong>那么可以通过<code>argument.name</code>获取角色和谓语的关系，<code>argument.range.start</code>和<code>argument.range.end</code>对应该角色的开始和结束索引（<strong>end要算上的</strong>）</p><p>给个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">roles = labeller.label(words, postags, parse_results)<br><span class="hljs-keyword">for</span> role <span class="hljs-keyword">in</span> roles:<br> arguments = role.arguments<br> index = role.index<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;谓语: <span class="hljs-subst">&#123;words[index]&#125;</span> (索引: <span class="hljs-subst">&#123;index&#125;</span>)&quot;</span>)<br> <span class="hljs-keyword">for</span> argument <span class="hljs-keyword">in</span> arguments:<br>     start, end = argument.<span class="hljs-built_in">range</span>.start, argument.<span class="hljs-built_in">range</span>.end<br>     obj = <span class="hljs-string">&quot;&quot;</span><br>     <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words[start : end+<span class="hljs-number">1</span>]:<br>         obj += word<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;argument.name&#125;</span>: <span class="hljs-subst">&#123;obj&#125;</span> (索引: <span class="hljs-subst">&#123;start&#125;</span>:<span class="hljs-subst">&#123;end&#125;</span>)&quot;</span>)<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220724211302209.png" alt="image-20220724211302209" style="zoom:67%;" /></p><p>语义角色如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220724211544134.png" alt="image-20220724211544134" style="zoom:60%;" /></p></blockquote><h1 id="rouge用法"><a href="#rouge用法" class="headerlink" title="rouge用法"></a>rouge用法</h1><ul><li>rouge和bleu一样也是一种对序列质量的评估标准，但是相比于bleu更关注召回率而非精准率（通过计算F1_score时改变<script type="math/tex">\beta</script>参数），rouge-n计算公式如下：</li></ul><script type="math/tex; mode=display">Rough-N=\frac{\sum_{S \in\{\text { ReferemceSummaries }\}} \sum_{\text {gram }_{n} \in S} \text { Count }_{\text {match }}\left(\text { gram }_{n}\right)}{\sum_{S \in\{\text { ReferenceSummaries }\}} \text { gram }_{n} \in S}</script><ul><li>rouge-1和rouge-2都可通过上述公式计算出来，和bleu中的P1和P2计算公式很像。可以在下面看到，每个rough-N都会输出p和r，其实就是精准率和召回率，两者也就是分母不一样（一个分母是refs的n-gram个数，一个分母是hyps的n-gram个数）</li><li>而rouge-l是rouge-N的改进：</li></ul><script type="math/tex; mode=display">\begin{array}{l}R_{l c s}=\frac{L C S(X, Y)}{m} \\P_{l c s}=\frac{L C S(X, Y)}{n} \\F_{l c s}=\frac{\left(1+\beta^{2}\right) R_{l c s} P_{l c s}}{R_{l c s}+\beta^{2} P_{l c s}}\end{array}</script><p>其中X、Y为hyps和refs，m、n为他们的长度，LCS(X, Y)为X、Y的最长共同序列</p><ul><li><strong>rouge.Rouge.get_scores(hyps, refs, avg=False, ignore_empty=False)</strong></li></ul><blockquote><p><strong>注意：输入的hyps和refs两个字符串，不管是中文英文，都需要每个字或词使用空格间隔</strong></p><p>输出是list(dict(dict))</p></blockquote><ul><li>直接给栗子吧：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rouge <span class="hljs-keyword">import</span> Rouge <br><br>hypothesis = <span class="hljs-string">&quot;the #### transcript is a written version of each day &#x27;s cnn student news program use this transcript to he    lp students with reading comprehension and vocabulary use the weekly newsquiz to test your knowledge of storie s you     saw on cnn student news&quot;</span><br><br>reference = <span class="hljs-string">&quot;this page includes the show transcript use the transcript to help students with reading comprehension and     vocabulary at the bottom of the page , comment for a chance to be mentioned on cnn student news . you must be a teac    her or a student age # # or older to request a mention on the cnn student news roll call . the weekly newsquiz tests     students &#x27; knowledge of even ts in the news&quot;</span><br><br>rouge = Rouge()<br>scores = rouge.get_scores(hypothesis, reference)<br></code></pre></td></tr></table></figure><p><strong>output：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;rouge-1&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;f&quot;</span>: <span class="hljs-number">0.4786324739396596</span>,<br>      <span class="hljs-attr">&quot;p&quot;</span>: <span class="hljs-number">0.6363636363636364</span>,<br>      <span class="hljs-attr">&quot;r&quot;</span>: <span class="hljs-number">0.3835616438356164</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;rouge-2&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;f&quot;</span>: <span class="hljs-number">0.2608695605353498</span>,<br>      <span class="hljs-attr">&quot;p&quot;</span>: <span class="hljs-number">0.3488372093023256</span>,<br>      <span class="hljs-attr">&quot;r&quot;</span>: <span class="hljs-number">0.20833333333333334</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;rouge-l&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;f&quot;</span>: <span class="hljs-number">0.44705881864636676</span>,<br>      <span class="hljs-attr">&quot;p&quot;</span>: <span class="hljs-number">0.5277777777777778</span>,<br>      <span class="hljs-attr">&quot;r&quot;</span>: <span class="hljs-number">0.3877551020408163</span><br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>其中p、r、f分别为精准率、召回率、F1_score</p><h1 id="zhconv用法"><a href="#zhconv用法" class="headerlink" title="zhconv用法"></a>zhconv用法</h1><ul><li><p>该库用于中文简繁体转换，但是也可以用<strong>OpenCC库，精准度更高、覆盖率更高、速度更快</strong></p></li><li><p><strong>逐字转换：zhconv.convert(s, locale, update=None)</strong></p></li><li><p><strong>基于MediaWiki的转换：zhconv.ocnvert_for_mw(s, locale, update=None)</strong></p></li></ul><blockquote><p>两个函数用法相同</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sent2 = <span class="hljs-string">&quot;計算機軟體&quot;</span><br><span class="hljs-built_in">print</span>(convert(sent2, <span class="hljs-string">&quot;zh-hans&quot;</span>))<br></code></pre></td></tr></table></figure><p>locale可为以下值：</p><p><code>zh-cn</code> 大陆简体、<code>zh-tw</code> 台灣正體、<code>zh-hk</code> 香港繁體、<code>zh-sg</code> 马新简体、<code>zh-hans</code> 简体、<code>zh-hant</code> 繁體</p></blockquote><h1 id="gensim用法"><a href="#gensim用法" class="headerlink" title="gensim用法"></a>gensim用法</h1><ul><li>gensim主要用于创建语料库，和计算各种特征（如相似度、tf-idf）等任务</li></ul><h3 id="创建语料库和计算相似度"><a href="#创建语料库和计算相似度" class="headerlink" title="创建语料库和计算相似度"></a>创建语料库和计算相似度</h3><ul><li><strong>创建语料库类：gensim.corpora.Dictionary(texts)</strong></li></ul><blockquote><p>输入：整个语料库，分好句和分好词的结果，一个list，每个元素又是一个list，里面的每个子元素是一个str词</p><p>输出：一个Dictionary对象</p></blockquote><ul><li><strong>将句子转化为词袋形式：Dictionary.doc2bow(text)</strong></li></ul><blockquote><p>输入：分好词的一个句子，一个list，每个元素是一个str词</p><p>输入：一个list，每个元素是一个二元tuple，tuple[0]是句子中存在的词的索引，tuple[1]是其在句子中出现的次数（出现0次的不计入）</p><p>该类的用法和python自带的字典对象基本相同，values、key、item之类的</p></blockquote><ul><li><strong>获取索引字典：Dictionary.token2id</strong></li></ul><blockquote><p>返回一个{token : id}的字典</p></blockquote><ul><li><strong>创建相似度类：gensim.similarities.Similarity(output_prefix, corpus, num_features)</strong></li></ul><blockquote><p>out_prefix是存储这个对象文件的名称</p><p>corpus是整个语料库，但是必须先转化为词袋模型</p><p>num_fuatures是整个词典的数量，一般使用len(dictionary)表示</p><p>对于得到的对象（取名为similarity），具体的用法为：similarity[test]，其中test为要比较的对象，可以是单个句子，也可以是整个语料库</p></blockquote><p><strong>举个栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk <span class="hljs-keyword">import</span> word_tokenize<br><span class="hljs-keyword">from</span> gensim.corpora <span class="hljs-keyword">import</span> Dictionary<br><span class="hljs-keyword">from</span> gensim.similarities <span class="hljs-keyword">import</span> Similarity<br><br>sent1 = <span class="hljs-string">&quot;I love sky, I love sea.&quot;</span><br>sent2 = <span class="hljs-string">&quot;I like running, I love reading.&quot;</span><br>sents = [sent1, sent2]<br><span class="hljs-comment"># 分词</span><br>texts = [word_tokenize(sent) <span class="hljs-keyword">for</span> sent <span class="hljs-keyword">in</span> sents]<br><br><span class="hljs-comment"># 创建字典对象</span><br>dictionary = Dictionary(texts)<br><span class="hljs-comment"># 获得词袋模型表示的词料库</span><br>corpus = [dictionary.doc2bow(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The corpus is : <span class="hljs-subst">&#123;corpus&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 创建相似度对象</span><br>similarity = Similarity(<span class="hljs-string">&quot;Similarity-excise1&quot;</span>, corpus, num_features=<span class="hljs-built_in">len</span>(dictionary))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Created class : <span class="hljs-subst">&#123;similarity&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 计算余弦相似度</span><br>test_corpus = dictionary.doc2bow(word_tokenize(sent1))<br><span class="hljs-built_in">print</span>(similarity[test_corpus])<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220706160148320.png" alt="image-20220706160148320"></p><h3 id="计算TF-IDF"><a href="#计算TF-IDF" class="headerlink" title="计算TF-IDF"></a>计算TF-IDF</h3><ul><li><strong>首先介绍一下tf-idf：</strong></li></ul><p>词频（term frequency，tf）指的是某一个给定的词语在该文件中对应的频率</p><p>逆向文件频率（inverse document frequency，idf）是一个词语普遍重要性的度量，可由文件总数除以包含该词的文件的总数求得</p><p>具体的计算公式如下：</p><script type="math/tex; mode=display">\mathrm{tf}_{\mathrm{i}, \mathrm{j}}=\frac{n_{i, j}}{\sum_{k} n_{k, j}} \\\operatorname{idf}_{\mathrm{i}}=\lg \frac{|D|}{\left|\left\{j: t_{i} \in d_{j}\right\}\right|}\\\operatorname{tfidf}_{i, j}=\mathrm{tf}_{\mathrm{i}, \mathrm{j}} \times \mathrm{idf}_{\mathrm{i}}</script><p>其中<script type="math/tex">tf_{i, j}</script>为<script type="math/tex">word_i</script>在<script type="math/tex">doc_j</script>中出现的词频，<script type="math/tex">n_{i, j}</script>为<script type="math/tex">word_i</script>在<script type="math/tex">doc_j</script>中出现的个数</p><p><script type="math/tex">idf_i</script>为<script type="math/tex">word_i</script>的逆向文件频率，<script type="math/tex">|D|</script>为文档总数，<script type="math/tex">\left|\left\{j: t_{i} \in d_{j}\right\}\right|</script>为包含<script type="math/tex">word_i</script>的文档个数</p><p>对于idf，底数可用2、e、10，并且分母可以+1，避免除以0</p><ul><li><strong>创建tfidf模型类：gensim.models.TfidfModel(corpus)</strong></li></ul><blockquote><p>输入为整个语料库，必须先转化为词袋模型</p><p>在具体使用时，和Similarity类似，tfidf_model[test]，其中test可以是单个句子也可以是整个语料库，返回一个列表，列表中每个元素为一个tuple，tuple[0]为词索引，tuple[1]为对应的tfidf值</p><p><strong>gensim算出来的tf-idf是经过了规范化的，每个句子的tfidf值，是一个单位向量</strong></p></blockquote><p><strong>举个栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># texts的构建是每个段落分词，有三个段落，则len(texts)=3</span><br>texts = [text1, text2, text3]<br>texts = [get_tokens(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts]<br>dictionary = Dictionary(texts)<br>id2token_dict = &#123;v : k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dictionary.token2id.items()&#125;<br>corpus = [dictionary.doc2bow(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts]<br>tfidf_model = TfidfModel(corpus)<br>result = tfidf_model[corpus]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220706210417422.png" alt="image-20220706210417422"></p><h1 id="Pandas用法"><a href="#Pandas用法" class="headerlink" title="Pandas用法"></a>Pandas用法</h1><ul><li><strong>创建DataFrame对象：pd.DataFrame(data, columns, index)</strong></li></ul><blockquote><p>输入：data是一个list, 每个对象是一个tuple或list，tuple的长度和columns的个数对应。data也可以是numpy形式</p><p>index是一个list，是行索引值，可以用于自行设置行索引<strong>（索引没有规定一定是int）</strong></p><p>示例：pd.DataFrame([(1, 2), (3, 4), (5, 6)], columns=[“name”, “NER result”])，输出为：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220711120934316.png" alt="image-20220711120934316" style="zoom: 80%;" /></p></blockquote><ul><li><strong>获取DataFrame特征：DataFrame.describe()</strong></li><li><strong>获取DataFrame的某列：DataFrame[“column_name”]</strong></li></ul><blockquote><p> 这样可获取到column列，结果是一个Series类（<strong>只有一个列则是Series，多个列则是DataFrame</strong>）</p><p> 如果不想出现重复结果，可调用<code>unique()</code>函数，示例：data[“ner_result”].unique()，返回的结果是一个ndarray，也可使用<code>list()</code>将其转换为列表</p><p> 如果想把这个Series类转换为ndarray，则可使用Series.values，这是Series类其中的一个属性，不是方法，类型是一个ndarrary，也可使用<code>list()</code>转换为列表</p></blockquote><ul><li><p><strong>获取DataFrame列名：DataFrame.columns</strong></p></li><li><p><strong>DataFrame根据某列，进行分组：DataFrame.groupby(“column_name”)</strong></p></li></ul><blockquote><p>将DataFrame通过column_name列进行分组</p><p>结果是一个可迭代的DataFrameGroupBy类，该类的用法和DataFrame几乎一样，比如可使用<code>DataFrameGroupBy[&quot;column_name&quot;]</code>将其转换为SeriesGroupby类</p><p>也可转化为list，转换后，其中每一个元素为一个tuple，tuple[0]为column_name列对应的值，tuple[1]为原DataFrame的一部分，根据column_name的值进行截断。如果是将SeriesGroupby类转换为list，则tuple[1]变为一个Series类</p><p>举个例子：<br>input_data为一个DataFrame，值如下：</p><p><div align=center><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220716123006189.png" alt="image-20220716123006189" style="zoom:67%;" /></p><p>现在将input_data根据sent_order列进行分组：input_data.groupby(“sent_order”)，结果如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220716123836380.png" alt="image-20220716123836380" style="zoom: 67%;" /></p><p>只展示了前三个元组，每个元组，tuple[0]为sent_order的值，tuple[1]为对应的DataFrame</p></blockquote><ul><li><strong>应用自定义方法：DaraFrame.apply(func, axis=0, …)</strong></li></ul><blockquote><p>Series、DataFrame和GroupbyDataFrame等均可使用</p><p>func是一个自定义函数</p><p>axis决定func的输入是什么，axis=0则输入为行，axis=1则输入为列</p><p>Series无需指定axis，DataFrame可调节axis更换操作的维度，<strong>DaraFrameGroupby也无需指定，func的输入为分组后的每个DataFrame，最后再将每个分组返回的结果总和起来</strong></p></blockquote><ul><li><strong>DataFrame的count()方法：</strong></li></ul><blockquote><p><code>count()</code>有很多种用法，结果是可以对Series、DataFrame和GroupbyDataFrame等使用，结果是返回一个Series或DataFrame</p><p>下面举几个示例，其中使用的df如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220725142611139.png" alt="image-20220725142611139" style="zoom: 60%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df.count()    <span class="hljs-comment"># DataFrame执行count()，对每一列分别执行count，结果返回一个Series</span><br>df.data[<span class="hljs-string">&quot;length&quot;</span>].count()    <span class="hljs-comment"># Series执行count()，直接返回length列的长度，类型为int</span><br>df.groupy(<span class="hljs-string">&quot;length&quot;</span>).count()   <span class="hljs-comment"># 对DataFrameGroupby类执行，返回一个DataFrame，index为length的各指，colums为出length的其他列执行count的结果</span><br>df.groupy(<span class="hljs-string">&quot;length&quot;</span>)[<span class="hljs-string">&quot;evaluation&quot;</span>].count()  <span class="hljs-comment"># 对SeriesGroupby类执行，则只返回evaluation列的count结果，类型为Series</span><br></code></pre></td></tr></table></figure><p>上述四句语句的执行结果：</p><ul><li>第一句：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220725143928089.png" alt="image-20220725143928089" style="zoom:67%;" /></p><ul><li>第二句：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220725143939723.png" alt="image-20220725143939723" style="zoom:67%;" /></p><ul><li>第三句：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220725143953768.png" alt="image-20220725143953768" style="zoom:50%;" /></p><ul><li>第四句：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220725144005108.png" alt="image-20220725144005108" style="zoom:50%;" /></p></blockquote><ul><li><strong>读取/保存csv文件：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df.to_csv(file_name, index=<span class="hljs-literal">False</span>)    <span class="hljs-comment"># 要加index=False</span><br>pd.read_csv(file_name)<br></code></pre></td></tr></table></figure><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><ul><li><strong>判断空值：DataFrame.isnull()或DataFrame.notnull()</strong></li></ul><blockquote><p>DataFrame和Series都可用，结果也是返回一个DataFrame或Series，和输入一一对应，其中每个值为布尔值</p></blockquote><ul><li><strong>删除缺失值：DataFrame.dropna(axis=0, inplace=False, how=None)</strong></li></ul><blockquote><p>axis：删除行还是列，{0 or ‘index’, 1 or ‘columns’}</p><p>how : 如果等于any则任何值为空都删除，如果等于all则所有值都为空才删除</p></blockquote><ul><li><strong>填充缺失值：DataFrame.fillna(value, method, axis, …)</strong></li></ul><blockquote><p>value：用于填充的值，可以是单个值，或者字典（用于不同列填充不同值的情况，key是列名，value是值）<br>method : 等于”ffill”使用前一个；不为空的值填充forword fill；等于”bfill”使用后一个不为空的值填充backword fill<br>axis : 按行还是列填充，{0 or ‘index’, 1 or ‘columns’}</p></blockquote><h3 id="Padas中DataFrame的增删查改"><a href="#Padas中DataFrame的增删查改" class="headerlink" title="Padas中DataFrame的增删查改"></a>Padas中DataFrame的增删查改</h3><ul><li><strong>增加列：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df = DataFrame(...)    <span class="hljs-comment"># 有三行数据</span><br>cities = [<span class="hljs-string">&quot;成都&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>]<br><span class="hljs-comment"># 三种插入方式</span><br>df.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;city&quot;</span>, citys)    <span class="hljs-comment"># 参数分别为：插入列的位置、列名、插入内容</span><br>df[<span class="hljs-string">&quot;city&quot;</span>] = cities<br>df.loc[:, <span class="hljs-string">&quot;city&quot;</span>] = cities<br></code></pre></td></tr></table></figure><ul><li><strong>增加行：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = DataFrame(...)  <span class="hljs-comment"># 有两列 </span><br>df.loc[<span class="hljs-number">3</span>] = [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]       <span class="hljs-comment"># 如果已经存在index=3的行，则修改值；反之直接添加该行</span><br>df = df.append(df_insert)    <span class="hljs-comment"># 合成两个DataFrame，列要相同才行</span><br></code></pre></td></tr></table></figure><ul><li><strong>loc[]和iloc[]的使用：</strong></li></ul><blockquote><p>两者功能是相同的，区别在于loc中对于列，只能使用列名（str类型）进行搜索，而iloc对于列只能使用整数索引进行搜索，DataFrame的查和改基本都是基于两者的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&quot;column_name&quot;</span>]或df.loc[:, <span class="hljs-string">&quot;column_name&quot;</span>]   <span class="hljs-comment"># 查找column_name列</span><br>df.loc[<span class="hljs-string">&quot;index_name&quot;</span>]    <span class="hljs-comment"># 查找index_name行</span><br>df.loc[<span class="hljs-string">&quot;index_name&quot;</span>, <span class="hljs-string">&quot;column_name&quot;</span>]     <span class="hljs-comment"># 查找(index_name, column_name)处的值</span><br><span class="hljs-comment"># 还可以使用list或者切片来代替，一次操作多行或多列</span><br>df.loc[[<span class="hljs-string">&quot;index_name1&quot;</span>, <span class="hljs-string">&quot;index_name2&quot;</span>], [<span class="hljs-string">&quot;column_name1&quot;</span>, <span class="hljs-string">&quot;column_name2&quot;</span>]]  <span class="hljs-comment"># 同时操作index_name1&amp;2行和column_name1&amp;2列</span><br>df.loc[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&quot;column_name&quot;</span>]    <span class="hljs-comment"># 进行切片，对0、1、2、3行操作</span><br></code></pre></td></tr></table></figure><blockquote><p><code>iloc[]</code>是使用整数列索引，比如：<code>df.iloc[:3, 2:6]</code></p><p>注意<code>loc[]</code>中的切片，是包含了end所指的索引（和list的索引稍有不同），<code>iloc[]</code>是不包含end的索引的</p></blockquote><ul><li><strong>删除：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df.drop(<span class="hljs-number">0</span>, axis=<span class="hljs-number">0</span>)   <span class="hljs-comment"># 删除第0行</span><br><span class="hljs-comment"># 删除列的三种方法</span><br>df.drop(<span class="hljs-string">&quot;column_name&quot;</span>, axis=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">del</span> df[<span class="hljs-string">&quot;column_name&quot;</span>]<br>ndf = df.pop(<span class="hljs-string">&quot;column_name&quot;</span>)<br><span class="hljs-comment"># 使用drop的时候，第一个参数也可以是list，一次操作多行或多列</span><br>df.drop([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], axis=<span class="hljs-number">0</span>)<br>df.drop([<span class="hljs-string">&quot;column_name1&quot;</span>, <span class="hljs-string">&quot;column_name2&quot;</span>], axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="Pickle用法"><a href="#Pickle用法" class="headerlink" title="Pickle用法"></a>Pickle用法</h1><ul><li><p><strong>储存pk文件：pickle.dump(obj, file)</strong></p></li><li><p><strong>加载pk文件：pickle.load(file)</strong></p></li></ul><blockquote><p>可以存储和加载对象，其中<code>dump()</code>中的obj是要存的对象，file是<code>open()</code>函数返回的文件描述符</p><p><code>load()</code>返回值为所存储的对象</p><p>储存的文件后缀为.pk</p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>file_name = <span class="hljs-string">&quot;test.pk&quot;</span><br><span class="hljs-comment"># 存</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(a, f)<br><span class="hljs-comment"># 取</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    b = pickle.load(f)<br>    <br><span class="hljs-comment"># a和b是一样的</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Json用法"><a href="#Json用法" class="headerlink" title="Json用法"></a>Json用法</h1><ul><li><p><strong>json可进行Python对象和json格式之间的互换</strong></p></li><li><p><strong>Python转json：json.dumps(obj, ensure_ascii=True, …, indent=None, …)</strong></p></li><li><strong>json转Python：json.loads(s, …)</strong></li></ul><blockquote><p>obj为Python对象，s为json对象</p><p>ensure_ascii：如果为False，则返回值可以包含非 ASCII</p><p>indent：为json中每个元素的间隔数，如果为0或None，则每个元素之间紧凑排版</p><p><strong>注意：</strong></p><p><strong>1. 以上两个函数只是进行对象的转换，而不会进行保存，所以是一般配合<code>open()</code>、<code>f.write()</code>、<code>f.read()</code>使用，给两个示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 存储json对象</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br> f.write(json.dumps(data, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>))<br><span class="hljs-comment"># 读取json对象</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br> data = json.loads(f.read())<br></code></pre></td></tr></table></figure></blockquote><h1 id="Yaml"><a href="#Yaml" class="headerlink" title="Yaml"></a>Yaml</h1><ul><li><strong>读取yaml文件：</strong><code>config = yaml.safe_load(open(&quot;config.yaml&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;).read())</code></li><li>在.yaml文件中，可用缩进表示层级关系，并且写浮点数不能用python的科学技术法的写法：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_25.png" alt="IMG_25" style="zoom:50%;" /></p><h1 id="Argparse"><a href="#Argparse" class="headerlink" title="Argparse"></a>Argparse</h1><ul><li><strong>基本流程：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&quot;--batch_size&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">1</span>) <br>args = parser.parse_args()<br></code></pre></td></tr></table></figure><ul><li>其中<code>--</code>表示可选参数，在运行命令指定<code>--batch_size=xxx</code>即可</li></ul><h1 id="Matplotlib用法"><a href="#Matplotlib用法" class="headerlink" title="Matplotlib用法"></a>Matplotlib用法</h1><ul><li><strong>折线图：plt.plot(x, y)</strong></li><li><strong>直方图：plt.bar(x, y)</strong></li><li><strong>散点图：plt.scatter(x, y)</strong></li></ul><blockquote><p>上述函数还可以指定颜色、大小等参数：</p><ul><li>color：颜色</li></ul><blockquote><p>可为：”b”：蓝色、”g”：绿色、”r”：红色、”c”：青色、”m”：品红、”y”：黄色、”k”：黑色、”w”：白色</p><p>也只直接用全名，如”blue”</p></blockquote><ul><li>s：点的大小</li><li>linewidth：线宽</li><li><p>linestyle：线样式，如设为”dashed”将线设为虚线</p></li><li><p>label：名字， 若要打印label，则使用<code>plt.legend()</code></p></li></ul></blockquote><ul><li><strong>设置标题：plt.title()</strong></li></ul><blockquote><p>同样可以使用fontsize指定字体大小</p></blockquote><ul><li><strong>设置x、y轴标题：plt.xlabel()和plt.ylabel()</strong></li><li><strong>保存图片：plt.savefig()</strong></li><li><strong>画完图之后记得关闭：plt.close()</strong></li><li><strong>画一条水平的线：plt.hlines(y, xmin, xmax)</strong></li><li><strong>画一条垂直的线：plt.vlines(x, ymin, ymax)</strong></li><li><strong>在指定座标处加注释：plt.text(x, y, s)</strong></li></ul><h1 id="Numpy用法"><a href="#Numpy用法" class="headerlink" title="Numpy用法"></a>Numpy用法</h1><ul><li><strong>获取最大值的位置（索引）np.argmax(a, axis=None, …)：</strong></li></ul><blockquote><p>axis：如果为None, 则代表把整个数组当作一维的，然后返回最大的索引值。如果指定axis，则只在该维度搜索最大值，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>],<br>       [<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.argmax(a)<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>np.argmax(a, axis=<span class="hljs-number">0</span>)<br>array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.argmax(a, axis=<span class="hljs-number">1</span>)<br>array([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>axis指定为哪个维度，则stack哪个维度</p></blockquote><ul><li><strong>减少维度：np.squeeze(a, axis=None)</strong></li></ul><blockquote><p>axis如果为None，则丢弃所有大小为1的维度</p></blockquote><h1 id="Tensorflow用法"><a href="#Tensorflow用法" class="headerlink" title="Tensorflow用法"></a>Tensorflow用法</h1><h3 id="禁用GPU"><a href="#禁用GPU" class="headerlink" title="禁用GPU"></a>禁用GPU</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="hljs-string">&quot;-1&quot;</span><br></code></pre></td></tr></table></figure><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ul><li><strong>填充序列：tf.keras.preprocessing.sequence.pad_sequences(sequences, maxlen=None, dtype=’int32’, padding=’pre’, truncating=’pre’, value=0.)</strong></li></ul><blockquote><p>输入：<br>sequences是要填充的序列</p><p>maxlen是要填充的最大长度，如果为None，则设为所有序列中最长的那个的长度</p><p>padding和truncating可以设为”pre”或者”post”，选择是在序列前面还是后面填充/截断</p><p>value为填充的值</p><p>返回值是一个ndarray</p></blockquote><ul><li><strong>划分训练、测试集：sklearn.model_selection.train_test_split(*arrays, test_size=None, train_size=None, random_state=None, shuffle=True, stratify=None)</strong></li></ul><blockquote><p>arrays是要划分的数据，可以使用list、numpy array、matric、dataframe<strong>（不能用Tensor）</strong>，示例：</p><p><code>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)</code></p><p>train_size和test_size指定一个就行</p><p>random_state为随机种子</p><p>shuffle决定是否打乱数据</p><p>stratify决定是否进行数据分层，stratify不是bool，是直接指定分层的依据变量，即通过什么来分层，一般就是label或者Series（在输入数据是DataFrame时，stratify指定为Series，即根据那一列来分层）</p><p><strong>输入的数据是什么类型，输出的数据就是什么类型，返回值依次为：x_train, x_test, y_train, y_test</strong></p></blockquote><h3 id="各种层"><a href="#各种层" class="headerlink" title="各种层"></a>各种层</h3><ul><li><strong>tf.keras.layers.Dense(units, activation=None, use_bias=True, …)</strong></li><li><strong>tf.keras.layers.Embedding(input_dim, output_dim,…., mask_zero=False, input_length=None)</strong></li></ul><blockquote><p>input_dim：词汇表大小</p><p>output_dim：词嵌入向量的维度</p><p>mask_zero：决定输入值0是否是应被屏蔽的mask“填充”值。如果为True，则使用mask，相应的input_dim也应该为词汇表大小+1（因为增加了一个mask token，索引为0）</p><p>intput_length：输入序列的长度，如果为None，则自动为最长序列的长度</p></blockquote><ul><li><strong>tf.keras.layers.LSTM(units, activation=”tanh”, recurrent_activation=”sigmoid”, …, return_sequences=False)</strong></li></ul><blockquote><p>其中return_sequences决定是否在最后返回所有时间步的输出，若为False只会返回最后一个时间步的输出，如果下一层需要使用到所有时间步的输出则需要设为True</p></blockquote><ul><li><strong>tf.keras.layers.Bidirectional(layer, merge_mode=”concat”, …)</strong></li></ul><blockquote><p>是RNN的双向包装器，可将单向RNN变为双向RNN</p><p>layer是要包装的层，merge_mode决定前后信息汇总的 方式，可为：”sum”、”mul”、”concat”、”ave”、None，如果为None，则不会合并，而是将他们作为列表输出</p></blockquote><ul><li><strong>tf.keras.layers.Softmax(axis=-1)</strong></li></ul><blockquote><p>axis：决定对那个维度执行softmax，默认为最后一个维度</p></blockquote><h3 id="模型的常用方法"><a href="#模型的常用方法" class="headerlink" title="模型的常用方法"></a>模型的常用方法</h3><ul><li><strong>序列容器：tf.keras.models.Sequential()</strong></li></ul><blockquote><p>可以和<code>add()</code>配合使用，也可以里面直接加个列表Sequential([…])</p></blockquote><ul><li><strong>配置模型：model.compile(optimizer=’rmsprop’, loss=None, metrics=None,…)</strong></li></ul><blockquote><p>optimizer：字符串或者Opitimizer实例</p><p>loss：字符串或Loss示例或一个函数</p><p>metrics：字符串或Metric示例或一个函数</p></blockquote><ul><li><strong>训练模型：model.fit(x=None, y=None, batch_size=None, epochs=1, verbose=1, callbacks=None, validation_split=0., validation_data=None, …)</strong></li></ul><blockquote><p>x/y：可以是numpy数组或者Tensor或list或迭代器等，这样x/y应一一对应。x也可为DataSet、Generator、Sequence，但是这种情况下就不应该指定y，因为y已经在x中了</p><p>batch_size如果未指定则默认32</p><p>callbacks：一个列表，每个元素是一个callbacks中的实例，如EarlyStopping类</p><p>validation_split和validaton_data只需要指定一个，前者是验证集所占比例，后者是直接指定验证集<strong>（如果指定了该参数，则x/y只能Tensor或ndarray）</strong></p></blockquote><ul><li><strong>画模型：tf.keras.utils.plot_model(model, to_file=”model.png”, show_shapes=False, show_dtype=False, show_layer_names=True, …)</strong></li></ul><blockquote><p>model是要打印的模型，一个keras model实例</p></blockquote><ul><li><strong>测试模型：model.evaluate(x=None, y=None, batch_size=None, verbose=1, …)</strong></li></ul><blockquote><p>用法和fit基本一样</p></blockquote><ul><li><strong>采用另一种方法训练模型：</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<br>    predictions = model(inputs, training = <span class="hljs-literal">True</span>)<br>    loss = loss_func(labels, predictions)<br>gradients = tape.gradient(loss, model.trainable_variables)<br>optimizer.apply_gradients(<span class="hljs-built_in">zip</span>(gradients, model.trainable_variables))<br></code></pre></td></tr></table></figure></blockquote><h3 id="保存和加载模型"><a href="#保存和加载模型" class="headerlink" title="保存和加载模型"></a>保存和加载模型</h3><ul><li>既有keras保存方式，也有tf原生方式保存方式，<strong>但是前者仅仅适合使用Python环境恢复模型，后者则可以跨平台进行模型部署</strong>。既可以直接保存整个模型，也可以分别保存模型的权重和结构</li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接保存</span><br>model.save(<span class="hljs-string">&quot;model.h5&quot;</span>, save_format = <span class="hljs-string">&quot;h5&quot;</span>)<br>model = tf.keras.models.load_model(<span class="hljs-string">&quot;model.h5&quot;</span>)<br><br><span class="hljs-comment"># 分别保存模型的权重和结构</span><br>json_str = model.to_json()<br>model.save_weights(<span class="hljs-string">&quot;model_weights.h5&quot;</span>, save_format = <span class="hljs-string">&quot;h5&quot;</span>)<br>model = tf.keras.models.model_from_json(json_str)<br>model.<span class="hljs-built_in">compile</span>(...)    <span class="hljs-comment"># 这种方法重新加载后需要重新配置优化器</span><br>model.load_weights（<span class="hljs-string">&quot;model_weights.h5&quot;</span>）<br><br><span class="hljs-comment"># 上面演示的是keras保存方式</span><br><span class="hljs-comment"># 要使用tf原生方式，需要在model.save()和model.save_weights()时添加参数save_format=&quot;tf&quot;，并且更改文件后缀</span><br><span class="hljs-comment"># 演示一下：</span><br>model.save_weights(<span class="hljs-string">&#x27;tf_model_weights.ckpt&#x27;</span>,save_format=<span class="hljs-string">&quot;tf&quot;</span>)<br>model.save(<span class="hljs-string">&#x27;tf_model_savedmodel&#x27;</span>, save_format=<span class="hljs-string">&quot;tf&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><h3 id="模型的反馈"><a href="#模型的反馈" class="headerlink" title="模型的反馈"></a>模型的反馈</h3><ul><li><strong>设置Early Stop：tf.keras.callbacks.EarlyStopping(monitor=’val_loss’, min_delta=0, patience=0, …, restore_best_weights=False)</strong></li></ul><blockquote><p>monitor：要监视的量，如：”val_loss”、”val_accuracy”、”train_loss”等</p><p>min_delta：若小于min_delta的绝对变化，将被视为没有改进</p><p>patience：容忍可以没有提升的epochs数</p><p>restore_best_weights：是否保存整个训练过程中最好的一个epoch</p></blockquote><ul><li><strong>设置学习率衰减：tf.keras.callbacks.ReduceLROnPlateau(monitor=”val_loss”, factor=0.1, patience=10, verbose=0, …, min_delta=0.0001, …, min_lr=0)</strong></li></ul><blockquote><p>当经过patience个epochs仍没有改进，则降低学习率，学习率*factor来降低</p><p>factor：每次降低的倍数</p><p>min_lr：学习率可降低到的最小值</p></blockquote><h3 id="Dataset用法"><a href="#Dataset用法" class="headerlink" title="Dataset用法"></a>Dataset用法</h3><ul><li>在<code>model.fit</code>中需要可以选择分别用list等类型指定x和y，也可以直接使用Dataset等类指定x而忽略y。对于前者，需要将所有数据一次性读入内存，内存负担较大。而后者可以使用TFRecordDataset类进行外存到内存的流式读取，只需要牺牲小部分IO性能，可大大减轻内存的负担</li><li>简单来说，一个.tfrecords文件包含多个样本<strong>（官方建议每个文件大小100-200M）</strong>，每个样本都对应着一个<code>tf.train.Example</code>类，每个样本可能有多个特征，每个特征用<code>tf.train.Feature()</code>封装</li><li>tf.train.Featrue可接收以下三种类型，大多数其他通用类型也可以强制转换成下面的其中一种：</li></ul><blockquote><ol><li><strong>tf.train.BytesList：</strong>string、byte<strong>（非标量数据也使用这个，但是需要先将Tensor序列化）</strong></li><li><strong>tf.train.FloatList：</strong>float、double</li><li><strong>tf.train.Int64List：</strong>bool、enum、int32、unit32、int64、uint64g</li></ol></blockquote><ul><li><strong>首先进行.tfrecords文件的存入：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_tfrecords</span>(<span class="hljs-params">data, label, desfile</span>):</span><br>    <span class="hljs-keyword">with</span> tf.io.TFRecordWriter(desfile) <span class="hljs-keyword">as</span> writer:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>            features = tf.train.Features(<br>                feature = &#123;<br>                    <span class="hljs-string">&quot;data&quot;</span>:tf.train.Feature(bytes_list = tf.train.BytesList(value =[tf.io.serialize_tensor(data[i]).numpy()])),<br>                    <span class="hljs-string">&quot;label&quot;</span>:tf.train.Feature(float_list = tf.train.FloatList(value = label[i])),<br>                &#125;<br>            )<br>            example = tf.train.Example(features = features)<br>            serialized = example.SerializeToString()<br>            writer.write(serialized)<br>   <br><br>save_tfrecords(x_in_sample1, y_in_sample1, <span class="hljs-string">&quot;path1.tfrecords&quot;</span>)<br>save_tfrecords(x_in_sample2, y_in_sample2, <span class="hljs-string">&quot;path2.tfrecords&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><ul><li>首先要用<code>tf.io.TFRecordWriter()</code>打开写入器，data和label是两个列表，每个元素对应一个Example的特征，desfile是文件名</li><li>对于每个Example的特征，使用一个字典表示，字典还需要被<code>tf.train.Features()</code>封装起来，字典的每个值可以是上述三种类型之一，需要使用<code>tf.train.Feature()</code>封装，其中value的值必须为一个list<strong>（注意前者是Features，后者是Feature）</strong>。并且<strong>由于data是非标量的高维数据，需要先使用<code>tf.io.serialize_tensor()</code>进行序列化，然后再使用其numpy值</strong></li><li>最后通过<code>tf.train.Example</code>封装feature，然后调用<code>SerializeToString()</code>函数，将编码后的字符串写入</li></ul></blockquote><ul><li><strong>接下来进行数据读取和使用：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TFR数据反编译</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map_func</span>(<span class="hljs-params">example</span>):</span><br>    feature_description = &#123;<br>        <span class="hljs-string">&#x27;data&#x27;</span>: tf.io.FixedLenFeature([], tf.string),<br>        <span class="hljs-string">&#x27;label&#x27;</span>: tf.io.FixedLenFeature([], tf.float32),<br>    &#125;<br>    parsed_example = tf.io.parse_single_example(example, features=feature_description)<br>    <br>    x_sample = tf.io.parse_tensor(parsed_example[<span class="hljs-string">&#x27;data&#x27;</span>], tf.float32)<br>    y_sample = parsed_example[<span class="hljs-string">&#x27;label&#x27;</span>]<br>    <br>    <span class="hljs-keyword">return</span> x_sample, y_sample<br><br><span class="hljs-comment"># 加载数据集</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_dataset</span>(<span class="hljs-params">filepaths</span>):</span><br>    shuffle_buffer_size = <span class="hljs-number">3000</span><br>    batch_size = <span class="hljs-number">256</span><br><br>    dataset = tf.data.TFRecordDataset(filepaths)<br>    dataset = dataset.shuffle(shuffle_buffer_size)<br>    dataset = dataset.<span class="hljs-built_in">map</span>(map_func=map_func, num_parallel_calls=tf.data.AOTOTUNE)<br>    dataset = dataset.batch(batch_size).prefetch(<span class="hljs-number">64</span>)<br>    <br>    <span class="hljs-keyword">return</span> dataset<br><br><br>train_set = load_dataset([<span class="hljs-string">&quot;path1.tfrecords&quot;</span>,<span class="hljs-string">&quot;path2.tfrecords&quot;</span>])<br>valid_set = load_dataset([<span class="hljs-string">&quot;path3.tfrecords&quot;</span>,<span class="hljs-string">&quot;path4.tfrecords&quot;</span>])<br>model.fit(train_set,epochs=model_epochs, validation_data=valid_set, callbacks=[early_stopping])<br></code></pre></td></tr></table></figure><blockquote><ul><li>首先要生成<code>tf.data.TFRecordDataset</code>类，传入参数是一个list，其中元素是.tfrecords文件名</li><li>每次读取后要先打乱</li><li>之后调用<code>map()</code>，其中指定的函数是<strong>对每个样本操作的</strong>，由于储存时序列化为了二进制字符串，所以数据是什么类型是的信息是丢失了的，解码时需要自己制定数据类型，所以在<code>map()</code>中首先需要指定feature_description，说明每个数据的类型</li><li>然后使用<code>tf.io.parse_single_example()</code>解码单个样本，结果返回一个字典，字典的每个元素对应一个特征，其中<strong>由于data是string类型，由于是编码后的非标量数据，所以还需要使用<code>tf.io.parse_tensor</code>解码一次（非标量数据的shape的编码解码的过程中是会丢失的，所以需要把shape一起储存）</strong></li><li>如果储存的是列表，需要在<code>tf.io.FixedLenFeature()</code>指定shape，也就是(len(list), )</li></ul></blockquote><h1 id="keras-bert用法"><a href="#keras-bert用法" class="headerlink" title="keras_bert用法"></a>keras_bert用法</h1><ul><li><strong>加载预训练模型：keras_bert.load_trained_model_from_checkpoint(config_file, checkpoint_file, training=False, trainable=None, output_layer_num=1, seq_len=int(1e9), kwargs)</strong></li></ul><blockquote><p>config_file和checkpoint_file分别为bert_config.json文件和bert_model.ckpt文件</p><p>training：如果为True，则将返回带有 MLM 和 NSP输出的模型；否则，将返回输入层和最后一个特征提取层。</p><p>trainable：模型是否可训练（也可通过for循环分别制定每层是否可训练）</p><p>seq_len为最大序列长度</p></blockquote><ul><li><strong>编码输入：keras_bert.Tokenizer(token_dict, …)</strong></li></ul><blockquote><p>bert模型的输入有两个，一个是语义token，一个是序列token，需要创建Tokenizer实例，再对句子进行编码，产生两个token</p><p>token_dict：是输入的映射字典，在vocab.txt中可以获取所有token，但是需要自行建立token -&gt; id的字典</p><p>创建Tokenizer实例后，调用<code>Tokenizer.encode(first, second=None, max_len=None)</code>进行编码，结果返回一个list，元素分别为两个list，分别对应两个token</p></blockquote><ul><li><strong>将数据输入模型：</strong></li></ul><blockquote><p>在<code>model.fit()</code>中，由于是多输入，采用<code>x=[train_token_embeddings, train_seq_embeddings]</code>和<code>validation_data=([test_token_embeddings, test_seq_embeddings], test_labels)</code>这种形式进行输入</p></blockquote><ul><li><strong>加载模型时所需要注意的：</strong></li></ul><blockquote><p>加载保存好的模型时同样是使用<code>tf.keras.models.load_model()</code>，但是会出现如下报错：</p><p><strong>ValueError: Unknown layer: TokenEmbedding</strong></p><p>这种情况需要：先<code>from keras_bert import get_custom_objects</code>，再在<code>load_model()</code>时添加参数<code>custom_objects=get_custom_objects()</code></p></blockquote><h1 id="bert4keras用法"><a href="#bert4keras用法" class="headerlink" title="bert4keras用法"></a>bert4keras用法</h1><ul><li><strong>由于keras和tf.keras的兼容问题，所以最开始需要添加环境变量TF_KERAS=1：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;TF_KERAS&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><ul><li>直接看<a href="https://github.com/Sniper970119/bert4keras_document">民间的API文档</a>，写的还可以</li></ul><h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><strong>读取数据</strong></li></ul><blockquote><ul><li>自建一个类，继承<code>torch.utils.data.Dataset</code>，还要实现<code>__init__()</code>、<code>__getitem__(index)</code>、<code>__len__()</code>三个函数</li><li>实例化Dataset，并用<code>torch.utils.data.DataLoader</code>封装：<code>DataLoader(data, batch_size=1)</code></li><li>直接for循环取每个batch：<code>for input_ids, attention_mask, labels in data:</code></li></ul></blockquote><ul><li><strong>搭建模型：</strong></li></ul><blockquote><ol><li>继承<code>torch.nn.Module</code>，并实现<code>__init__()</code>、<code>forward()</code></li></ol></blockquote><ul><li><strong>损失函数：</strong></li></ul><blockquote><ul><li>以交叉熵举例</li><li>创建：<code>loss = torch.nn.CrossEntropyLoss(reduction=&quot;none&quot;).cuda()</code></li><li>其中<code>reduction=Union[“mean”, “sum”, “none”]</code>，表示对每个sample的loss怎么处理</li><li><strong>踩个坑：如果loss的输入（模型的输出置信度）超过两维，如token级别的分类，<code>shape=[batch_size, max_seq_len, num_class]</code>，需要把num_class移到第二维，即执行<code>output.transpose(1, 2)</code>，现在<code>shape=[batch_size, num_class, max_seq_len]</code></strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/IMG_27.png" alt="IMG_27"></p></blockquote><ul><li><strong>优化器：</strong><code>torch.optim.Adam(model.parameters(), lr=0.01</code></li><li><strong>反向传播：</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model.zero_grad()<br>loss.backward()<br>optimizer.step()<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>模型保存和加载：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以选择保存整个模型，也可以选择只保存权重</span><br><span class="hljs-comment"># 保存整个模型：</span><br>torch.save(model, file_path)   <span class="hljs-comment"># file_path以.pt .pth结尾</span><br><span class="hljs-comment"># 加载整个模型</span><br>model = torch.load(file_path)<br><br><span class="hljs-comment"># 保存权重</span><br>torch.save(model.state_dict(), file_path)<br><span class="hljs-comment"># 加载权重</span><br>model = MyModel()<br>model.load_state_dict(torch.load(file_path))<br></code></pre></td></tr></table></figure><ul><li><strong>模型训练、测试模式转换：</strong><code>model.train()</code>、<code>model.eval()</code></li></ul><h3 id="多卡并行"><a href="#多卡并行" class="headerlink" title="多卡并行"></a>多卡并行</h3><ul><li><strong>运行命令：</strong><code>python3 -m torch.distributed.launch --nproc_per_node=2 &#123;file_name&#125;</code></li></ul><blockquote><p>其中nproc_per_node代表GPU数量</p></blockquote><ul><li><strong>命令行参数</strong></li></ul><blockquote><ol><li>进程编号：<code>parser.add_argument(&quot;--local_rank&quot;, type=int, default=-1)</code>，local_rank为0代表主进程</li><li>GPU数量：<code>gpu_num = int(os.environ[&#39;WORLD_SIZE&#39;])</code></li><li>需要手动设置环境变量：<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = “0, ..., gpu_num-1”</code></li></ol></blockquote><ul><li><strong>初始化：</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.cuda.set_device(local_rank)<br><span class="hljs-keyword">if</span> gpu_num &gt; <span class="hljs-number">1</span> :<br> torch.distributed.init_process_group(backend=<span class="hljs-string">&quot;nccl”)</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>读取数据：</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">data = Dataset()<br>data_sampler = torch.utils.data.distributed.DistributedSampler(data)<br>data = DataLoader(data, batch_size=<span class="hljs-number">1</span>, sampler=data_sampler)   <span class="hljs-comment"># 需要在DataLoader封装时指定sampler</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>模型：</strong></li></ul><blockquote><ul><li>模型需要用<code>torch.nn.parallel.DistributedDataParallel</code>封装：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = DDP(model, device_ids=[local_rank], output_device=local_rank, find_unused_parameters=<span class="hljs-literal">False</span>) `<br></code></pre></td></tr></table></figure></li><li>其中find_unused_parameters默认为False，为False效率更高，如果报错则改为True</li></ul></blockquote><ul><li><strong>打乱数据：</strong></li></ul><blockquote><ul><li>在每个epoch开始的时候需要<code>data.sampler.set_epoch(epoch)</code></li><li>是为了让sample打乱数据，使每个epoch的训练数据顺序不同</li></ul></blockquote><ul><li><strong>同步每个进程的数据：</strong></li></ul><blockquote><ul><li>每个进程中的数据是不同步的，如train_loss、val_loss等</li><li>通过<code>torch.distributed.all_reduce(value)</code>来对value进行同步</li><li>同步之后是所有进程该值的和，所以一般需要除以gpu_num</li><li>value必须是Tensor，不能是标量</li></ul></blockquote><ul><li><strong>模型保存和加载：</strong></li></ul><blockquote><ul><li>如果model用DDP封装，保存时保存<code>model.module</code>或者<code>model.module.state_dict()</code></li><li><strong>一般只在主进程进行模型保存、打印、tensorboard记录</strong></li></ul></blockquote><h3 id="Huggingface-Transformers"><a href="#Huggingface-Transformers" class="headerlink" title="Huggingface Transformers"></a>Huggingface Transformers</h3><ul><li><strong>Tokenizer加载：</strong><code>AutoTokenizer.from_pretrained(checkpoint)</code></li><li><strong>Tokenizer编码：</strong></li></ul><blockquote><ul><li><code>tokenizer.encode(text, return_tensors=&quot;pt&quot;)</code>：只返回词典映射后的编码结果，<code>text=str</code></li><li><code>tokenizer(texts, padding=&quot;max_length&quot;, truncation=True,max_length=150, return_tensors=&quot;pt”)</code>：返回一个字典，包括模型所需要的所有输入，一般为input_ids和attention_mask。<code>texts=Union[str, list(str)]</code>，<code>padding=Union[“max_length”, True, False]</code></li><li><strong>tokenizer()的结果如果需要组成batch，字典中的每个Tensor需要将第一维去掉：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> inputs.items():<br>    inputs[key] = val.squeeze(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>Tokenizer解码：</strong><code>tokenizer.decode(ids, skip_special_tokens=True)</code></li></ul><blockquote><p>其中ids为input_ids</p></blockquote><ul><li><strong>指定Tokenizer填充和截断方向：</strong><blockquote><ul><li><code>tokenizer.padding_side=Union[“left”, “right”]</code></li><li><code>tokenizer.truncation_side=Union[“left”, “right”]</code></li></ul></blockquote></li><li><strong>模型：</strong></li></ul><blockquote><ul><li>加载：<code>AutoModel.from_pretrained(checkpoint)</code></li><li>前向计算：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = tokenizer().    <span class="hljs-comment"># inputs是一个dict</span><br>output = model(**inputs)。   <span class="hljs-comment"># 输出的output是一个dict</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>生成式模型进行生成预测：</strong><code>model.generate(ids, max_length=None, num_beams=1,do_sample=False, top_k=1, early_stopping=False, num_return_sequences=1)</code></li></ul><blockquote><ul><li>一些生成模型如BloomForCausalModel自带生成函数</li><li>其中ids为encode之后的结果，每次generate的ids只对应一个句子，无法并行</li><li>需要do_sanple=True，才能启用top_k、top_p</li></ul></blockquote><h3 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h3><ul><li>直接给个🌰：</li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化</span><br>time = “&#123;<span class="hljs-number">0</span>:%Y-%m-%d-%H:%M:%S/&#125;<span class="hljs-string">&quot;.format(datetime.datetime.now())</span><br><span class="hljs-string">tb_path = config[&quot;</span>tb_root_path<span class="hljs-string">&quot;] + time</span><br><span class="hljs-string">print(f&quot;</span>Start Tensorboard <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;tensorboard --logdir=&#123;tb_path&#125; --bind_all&#x27;</span>, view at http://localhost:<span class="hljs-number">6006</span>/<span class="hljs-string">&quot;)</span><br><span class="hljs-string">writer = SummaryWriter(tb_path)</span><br><span class="hljs-string"># 保存标量</span><br><span class="hljs-string">writer.add_scalar(&quot;</span>train/loss<span class="hljs-string">&quot;, loss, step)</span><br></code></pre></td></tr></table></figure><ul><li>运行完之后直接运行<code>tensorboard --logdir=&#123;tb_path&#125; --bind_all</code>，然后访问本地6006端口即可</li><li>在多卡时，一般只在主进程采用tensorboard</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HMM和CRF</title>
    <link href="/2022/06/14/HMM%E5%92%8CCRF/"/>
    <url>/2022/06/14/HMM%E5%92%8CCRF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-隐马尔可夫模型"><a href="#1-隐马尔可夫模型" class="headerlink" title="1 隐马尔可夫模型"></a>1 隐马尔可夫模型</h1><ul><li>隐马尔可夫模型（Hidden Markov Model, HMM）常用于序列标注问题，描述由隐藏的马尔科夫链随机生成观测序列的过程，属于<strong>概率图模型</strong>（用图结构来描述变量之间的关系，属于生成式模型）</li><li>HMM属于<a href="https://zlkqz.site/2022/09/28/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/#6-EM%E7%AE%97%E6%B3%95">贝叶斯网</a>，其两个基本假设其实就是贝叶斯网的假设：<strong>给定父节点集，贝叶斯网假设每个属性与他的非后裔属性独立</strong></li></ul><h3 id="1-1-模型定义"><a href="#1-1-模型定义" class="headerlink" title="1.1 模型定义"></a>1.1 模型定义</h3><ul><li>设<script type="math/tex">Q=  \{q_1, ..., q_N\}</script>是所有可能的状态的集合，<script type="math/tex">V = \{v_1, ..., v_M\}</script>是所有可能的观测的集合。而<script type="math/tex">I = (i_1, ..., i_T)</script>是状态序列，<script type="math/tex">O = (o_1, ..., o_T)</script>是对应的观测序列，模型定义了三种参数：</li></ul><blockquote><ol><li><strong>状态转移矩阵A：</strong></li></ol><script type="math/tex; mode=display">A = [a_{ij}]_{N \times N}</script><p>其中<script type="math/tex">a_{ij}</script>指在时刻t处于状态<script type="math/tex">q_i</script>的条件下转移到在t+1时刻状态为<script type="math/tex">q_j</script>的概率：</p><script type="math/tex; mode=display">a_{ij} = P(i_{t+1}=q_j|i_t=q_i)</script><ol><li><strong>观测概率矩阵B：</strong></li></ol><script type="math/tex; mode=display">B = [b_j(k)]_{N\times M}</script><p>其中<script type="math/tex">b_j(k)</script>指在t时刻处于状态<script type="math/tex">q_j</script>时生成观测<script type="math/tex">v_k</script>的概率：</p><script type="math/tex; mode=display">b_j(k) = P(o_t = v_k|i_t =  q_j)</script><ol><li><strong>初始状态概率向量<script type="math/tex">\pi</script>：</strong></li></ol><script type="math/tex; mode=display">\pi = (\pi_i)</script><p>其中<script type="math/tex">\pi_i</script>是<script type="math/tex">t=1</script>时处于状态<script type="math/tex">q_i</script>的概率：</p><script type="math/tex; mode=display">\pi = P(i_1 = q_i)</script></blockquote><ul><li>一般使用一个三元组表示HMM的参数：</li></ul><script type="math/tex; mode=display">\lambda = (A,B,\pi)</script><ul><li>上面对参数的定义中，隐含了HMM的两个基本假设：</li></ul><blockquote><ol><li><strong>齐次马尔可夫性假设：</strong>假设隐藏的马尔可夫链在任意时刻t的状态只依赖于前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关：</li></ol><script type="math/tex; mode=display">P\left(i_{t} \mid i_{t-1}, o_{t-1}, \cdots, i_{1}, o_{1}\right)=P\left(i_{t} \mid i_{t-1}\right), \quad t=1,2, \cdots, T</script><ol><li><strong>观测独立性假设：</strong>假设任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关：</li></ol><script type="math/tex; mode=display">P\left(o_{t} \mid i_{T}, o_{T}, i_{T-1}, o_{T-1}, \cdots, i_{t+1}, o_{t+1}, i_{t}, i_{t-1}, o_{t-1}, \cdots, i_{1}, o_{1}\right)=P\left(o_{t} \mid i_{t}\right)</script><p><strong>其实这两个假设就是贝叶斯网的假设，只不过结构特殊一点，是一个线性结构</strong></p></blockquote><h3 id="1-2-概率计算"><a href="#1-2-概率计算" class="headerlink" title="1.2 概率计算"></a>1.2 概率计算</h3><ul><li>概率计算即给定模型<script type="math/tex">\lambda = (A,B,\pi)</script>和观测序列<script type="math/tex">O=(o_1, ..., o_T)</script>，计算该观测序列出现的概率<script type="math/tex">P(O|\lambda)</script></li></ul><h4 id="1-2-1-直接计算"><a href="#1-2-1-直接计算" class="headerlink" title="1.2.1 直接计算"></a>1.2.1 直接计算</h4><ul><li>直接计算即列举所有可能的状态序列<script type="math/tex">I</script>，计算：</li></ul><script type="math/tex; mode=display">\begin{aligned}P(O \mid \lambda) &=\sum_{I} P(O \mid I, \lambda) P(I \mid \lambda) \\&=\sum_{i_{1}, i_{2}, \cdots, i_{T}} \pi_{i_{1}} b_{i_{1}}\left(o_{1}\right) a_{i_{1} i_{2}} b_{i_{2}}\left(o_{2}\right) \cdots a_{i_{T-i} i_{T}} b_{i_{T}}\left(o_{T}\right)\end{aligned}</script><ul><li>但是这种方法计算量过大，复杂度为<script type="math/tex">O(TN^T)</script>，所以是不可行的</li></ul><h4 id="1-2-2-前向计算"><a href="#1-2-2-前向计算" class="headerlink" title="1.2.2 前向计算"></a>1.2.2 前向计算</h4><ul><li>给定模型<script type="math/tex">\lambda</script>，定义在时刻t时观测序列为<script type="math/tex">o_1, ..., o_t</script>，且当前状态为<script type="math/tex">q_i</script>的概率为前向概率：</li></ul><script type="math/tex; mode=display">\alpha_t(i) = P(o_1, ..., o_t, i_t=q_i|\lambda)</script><ul><li>算法流程：</li></ul><p>给定模型<script type="math/tex">\lambda</script>和观测序列<script type="math/tex">O=(o_1, ..., o_T)</script></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221028120947404.png" alt="image-20221028120947404" style="zoom:80%;" /></p><h4 id="1-2-3-后向计算"><a href="#1-2-3-后向计算" class="headerlink" title="1.2.3 后向计算"></a>1.2.3 后向计算</h4><ul><li>给定模型<script type="math/tex">\lambda</script>，定义在时刻t时刻状态为<script type="math/tex">q_i</script>的条件下，从t+1到T的部分观测序列为<script type="math/tex">o_{t+1}, ..., o_T</script>的概率为后向概率：</li></ul><script type="math/tex; mode=display">\beta_{t}(i)=P\left(o_{t+1}, o_{t+2}, \cdots, o_{T} \mid i_{t}=q_{i}, \lambda\right)</script><ul><li>算法流程：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221028122410576.png" alt="image-20221028122410576" style="zoom:75%;" /></p><h4 id="1-2-4-常用概率的计算"><a href="#1-2-4-常用概率的计算" class="headerlink" title="1.2.4 常用概率的计算"></a>1.2.4 常用概率的计算</h4><ol><li><strong>计算给定模型<script type="math/tex">\lambda</script>和观测<script type="math/tex">O</script>，在t时刻处于<script type="math/tex">q_i</script>的概率：</strong></li></ol><script type="math/tex; mode=display">\gamma_t(i) = P(i_t = q_i|O, \lambda)</script><blockquote><ul><li>首先运用贝叶斯公式：</li></ul><script type="math/tex; mode=display">\gamma_{t}(i)=P\left(i_{t}=q_{i} \mid O, \lambda\right)=\frac{P\left(i_{t}=q_{i}, O \mid \lambda\right)}{P(O \mid \lambda)}</script><ul><li>由上述的前向后向概率的定义可得：</li></ul><script type="math/tex; mode=display">\alpha_t(i)\beta_t(i) = P(i_t=q_i,O|\lambda)</script><ul><li>于是得到：</li></ul><script type="math/tex; mode=display">\gamma_{t}(i)=\frac{\alpha_{t}(i) \beta_{t}(i)}{P(O \mid \lambda)}=\frac{\alpha_{t}(i) \beta_{t}(i)}{\sum_{j=1}^{N} \alpha_{t}(j) \beta_{t}(j)}</script></blockquote><ol><li><strong>计算给定模型<script type="math/tex">\lambda</script>和观测<script type="math/tex">O</script>，在t时刻处于状态<script type="math/tex">q_i</script>并且在t+1时刻处于状态<script type="math/tex">q_j</script>的概率：</strong></li></ol><script type="math/tex; mode=display">\xi_{t}(i, j)=P\left(i_{t}=q_{i}, i_{t+1}=q_{j} \mid O, \lambda\right)</script><blockquote><ul><li>同样先运用贝叶斯公式：</li></ul><script type="math/tex; mode=display">\xi_{t}(i, j)=\frac{P\left(i_{t}=q_{i}, i_{t+1}=q_{j}, O \mid \lambda\right)}{P(O \mid \lambda)}=\frac{P\left(i_{t}=q_{i}, i_{t+1}=q_{j}, O \mid \lambda\right)}{\sum_{i=1}^{N} \sum_{j=1}^{N} P\left(i_{t}=q_{i}, i_{t+1}=q_{j}, O \mid \lambda\right)}</script><ul><li>其中：</li></ul><script type="math/tex; mode=display">P\left(i_{t}=q_{i}, i_{t+1}=q_{j}, O \mid \lambda\right)=\alpha_{t}(i) a_{i j} b_{j}\left(o_{t+1}\right) \beta_{t+1}(j)</script><ul><li>所以：</li></ul><script type="math/tex; mode=display">\xi_{t}(i, j)=\frac{\alpha_{t}(i) a_{i j} b_{j}\left(o_{t+1}\right) \beta_{t+1}(j)}{\sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{t}(i) a_{i j} b_{j}\left(o_{t+1}\right) \beta_{t+1}(j)}</script></blockquote><h3 id="1-3-学习算法"><a href="#1-3-学习算法" class="headerlink" title="1.3 学习算法"></a>1.3 学习算法</h3><ul><li>在观测序列和状态序列都给定的时候，训练集足够大时，可以直接通过极大似然估计来估计模型参数，即<strong>直接通过频数来估计概率</strong></li><li><p>我们主要讨论的是只给定观测序列时的情况，<strong>此时状态序列为隐变量</strong>，所以使用<a href="https://zlkqz.site/2022/09/28/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/#6-EM%E7%AE%97%E6%B3%95">EM算法</a></p></li><li><p>首先是E步，即计算Q函数：</p></li></ul><script type="math/tex; mode=display">Q(\lambda, \bar{\lambda}) = \sum_{I}\log P(O,I|\lambda)P(I|O,\bar{\lambda}) = \sum_{I}\log P(O,I|\lambda)\frac{P(O,I|\bar{\lambda})}{P(O|\bar{\lambda})}</script><p>其中<script type="math/tex">\bar{\lambda}</script>是HMM参数的当前估计值，<script type="math/tex">\lambda</script>是要极大化的值，作为下次迭代的新参数</p><ul><li>由于分母中的<script type="math/tex">P(O|\bar{\lambda})</script>和要更新的参数<script type="math/tex">\lambda</script>无关，所以直接去掉，Q函数直接化为：</li></ul><script type="math/tex; mode=display">Q(\lambda, \bar{\lambda})=\sum_{I} \log P(O, I \mid \lambda) P(O, I \mid \bar{\lambda})</script><ul><li>其中：</li></ul><script type="math/tex; mode=display">P(O, I \mid \lambda)=\pi_{i_{1}} b_{i_{1}}\left(o_{1}\right) a_{i_{i} i_{2}} b_{i_{2}}\left(o_{2}\right) \cdots a_{i_{T-1} i_{T}} b_{i_{T}}\left(o_{T}\right)</script><ul><li>所以：</li></ul><script type="math/tex; mode=display">\begin{aligned}Q(\lambda, \bar{\lambda})=& \sum_{I} \log \pi_{i} P(O, I \mid \bar{\lambda}) +\sum_{I}\left(\sum_{t=1}^{T-1} \log a_{i, i_{i}+1}\right) P(O, I \mid \bar{\lambda})+\sum_{I}\left(\sum_{t=1}^{T} \log b_{i_{i}}\left(o_{t}\right)\right) P(O, I \mid \bar{\lambda})\end{aligned}</script><ul><li>然后是M步，即最大化Q函数，而最大化Q函数的问题，可以化为分别最大化上式中Q函数中的三项：</li></ul><blockquote><ol><li>最大化<script type="math/tex">\sum_{I} \log \pi_{i} P(O, I \mid \bar{\lambda})</script>，可以先将其化为：</li></ol><script type="math/tex; mode=display">\sum_{I} \log \pi_{i_{0}} P(O, I \mid \bar{\lambda})=\sum_{i=1}^{N} \log \pi_{i} P\left(O, i_{1}=i \mid \bar{\lambda}\right)</script><p>由于存在约束<script type="math/tex">\sum_{i=1}^N\pi_i =1</script>，所以可以使用拉格朗日乘子法进行求解，最后得到：</p><script type="math/tex; mode=display">\pi_{i}=\frac{P\left(O, i_{1}=i \mid \bar{\lambda}\right)}{P(O \mid \bar{\lambda})}</script><ol><li>最大化<script type="math/tex">\sum_{I}\left(\sum_{t=1}^{T-1} \log a_{i, i_{i}+1}\right) P(O, I \mid \bar{\lambda})</script>，化为：</li></ol><script type="math/tex; mode=display">\sum_{I}\left(\sum_{t=1}^{T-1} \log a_{i_{i} i_{t+1}}\right) P(O, I \mid \bar{\lambda})=\sum_{i=1}^{N} \sum_{j=1}^{N} \sum_{t=1}^{T-1} \log a_{i j} P\left(O, i_{t}=i, i_{t+1}=j \mid \bar{\lambda}\right)</script><p>运用拉格朗日乘子法，最后得到：</p><script type="math/tex; mode=display">a_{i j}=\frac{\sum_{t=1}^{T-1} P\left(O, i_{t}=i, i_{t+1}=j \mid \bar{\lambda}\right)}{\sum_{t=1}^{T-1} P\left(O, i_{t}=i \mid \bar{\lambda}\right)}</script><ol><li>最大化<script type="math/tex">\sum_{I}\left(\sum_{t=1}^{T} \log b_{i_{i}}\left(o_{t}\right)\right) P(O, I \mid \bar{\lambda})</script>，化为：</li></ol><script type="math/tex; mode=display">\sum_{I}\left(\sum_{t=1}^{T} \log b_{i_{i}}\left(o_{t}\right)\right) P(O, I \mid \bar{\lambda})=\sum_{j=1}^{N} \sum_{t=1}^{T} \log b_{j}\left(o_{t}\right) P\left(O, i_{t}=j \mid \bar{\lambda}\right)</script><p>运用拉格朗日乘子法，最后得到：</p><script type="math/tex; mode=display">b_{j}(k)=\frac{\sum_{t=1}^{T} P\left(O, i_{t}=j \mid \bar{\lambda}\right) I\left(o_{t}=v_{k}\right)}{\sum_{t=1}^{T} P\left(O, i_{t}=j \mid \bar{\lambda}\right)}</script></blockquote><ul><li>算法流程：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221028132201642.png" alt="image-20221028132201642" style="zoom:67%;" /></p><h3 id="1-4-预测算法"><a href="#1-4-预测算法" class="headerlink" title="1.4 预测算法"></a>1.4 预测算法</h3><ul><li>序列模型常用<strong>维特比算法</strong>来进行预测，算法流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221028132500929.png" alt="image-20221028132500929" style="zoom:67%;" /></p><h1 id="2-条件随机场"><a href="#2-条件随机场" class="headerlink" title="2 条件随机场"></a>2 条件随机场</h1><ul><li>条件随机场（Conditional Random Field, CRF）和HMM一样，同样属于概率图模型，是给定一组输入随机变量条件下，另一组输出是随机变量的条件概率分布模型</li><li>有一种特殊且最常用的CRF为线性链条件随机场，其结构和数学推导和HMM十分相似，但是仍有一些区别，稍后介绍</li></ul><h3 id="2-1-马尔可夫随机场"><a href="#2-1-马尔可夫随机场" class="headerlink" title="2.1 马尔可夫随机场"></a>2.1 马尔可夫随机场</h3><ul><li><p><strong>概率图模型</strong>是由图结构来描述变量之间的关系的模型，而采用有向无环图结构被称为<strong>贝叶斯网</strong>，采用无向图则被称为<strong>概率无向图模型或马尔可夫随机场</strong></p></li><li><p>设有联合概率分布<script type="math/tex">P(Y)</script>，<script type="math/tex">Y \in \mathcal{Y}</script>是一组随机变量。由无向图<script type="math/tex">G = (V,E)</script>表示概率分布<script type="math/tex">P(Y)</script>，即在G中，结点<script type="math/tex">v \in V</script>表示一个随机变量<script type="math/tex">Y_v</script>，<script type="math/tex">Y = (Y_v)_{v \in V}</script>，而边<script type="math/tex">e \in E</script>表示随机变量间的概率依赖关系</p></li><li>首先定义无向图模型内的马尔可夫性：</li></ul><blockquote><ol><li><strong>成对马尔可夫性：</strong>设u和v是图中任意两个没有边连接的结点，其对应的随机变量分别为<script type="math/tex">Y_u, Y_v</script>，其他所有结点为O，对应随机变量<script type="math/tex">Y_O</script>。成对马尔可夫性指给定<script type="math/tex">Y_O</script>的条件下，<script type="math/tex">Y_u, Y_v</script>是条件独立的：</li></ol><script type="math/tex; mode=display">P\left(Y_{u}, Y_{v} \mid Y_{o}\right)=P\left(Y_{u} \mid Y_{o}\right) P\left(Y_{v} \mid Y_{o}\right)</script><ol><li><strong>局部马尔可夫性：</strong>设v为图中任意一个结点，W是与v相连的所有结点，O是除v和W之外的所有结点。局部马尔可夫性指给定<script type="math/tex">Y_W</script>的条件下<script type="math/tex">Y_v, Y_O</script>是条件独立的：</li></ol><script type="math/tex; mode=display">P\left(Y_{v}, Y_{o} \mid Y_{W}\right)=P\left(Y_{v} \mid Y_{W}\right) P\left(Y_{o} \mid Y_{W}\right)</script><p>也可以为表示为：</p><script type="math/tex; mode=display">P(Y_v|Y_W) = P(Y_v|Y_W, Y_O)</script><ol><li><strong>全局马尔可夫性：</strong>A、B是在图中被结点集合C分开的任意结点集合（如下图所示）。全局马尔可夫性指给定<script type="math/tex">Y_C</script>条件下<script type="math/tex">Y_A,Y_B</script>条件独立：</li></ol><script type="math/tex; mode=display">P\left(Y_{A}, Y_{B} \mid Y_{C}\right)=P\left(Y_{A} \mid Y_{C}\right) P\left(Y_{B} \mid Y_{C}\right)</script><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221029144742544.png" alt="image-20221029144742544" style="zoom:67%;" /></p><p><strong>上述三种马尔可夫性是等价的</strong></p></blockquote><ul><li>而马尔可夫随机场，不仅要满足使用无向图，还需要满足马尔可夫性。显然，CRF属于马尔可夫随机场</li></ul><h3 id="2-2-团和极大团"><a href="#2-2-团和极大团" class="headerlink" title="2.2 团和极大团"></a>2.2 团和极大团</h3><ul><li><p>无向图中的任意一个强连通子集都称为<strong>团（clique）</strong>，而一个团不能再加任意一个结点使其仍为团，则这种团为<strong>极大团（maximal clique）</strong></p></li><li><p>联合概率分布可以用每个团的<strong>势函数（potential function）</strong>的乘积来表示，但是一个图中的团很多，且有些随机变量同时属于多个团，所以简化来说，可以直接使用<strong>极大团的势函数成绩</strong>：</p></li></ul><script type="math/tex; mode=display">P(Y)=\frac{1}{Z} \prod_{C} \Psi_{C}\left(Y_{C}\right)</script><p>其中C为极大团集，Z为规范化因子，<script type="math/tex">\Psi</script>为势函数，要求势函数是严格正的，一般定义为指数函数：</p><script type="math/tex; mode=display">\Psi_{C}\left(Y_{C}\right)=\exp \left\{-E\left(Y_{C}\right)\right\}</script><h3 id="2-3-模型定义"><a href="#2-3-模型定义" class="headerlink" title="2.3 模型定义"></a>2.3 模型定义</h3><ul><li>设随机变量<script type="math/tex">X,Y</script>，如果对任意结点v满足马尔可夫性（下式为局部马尔可夫性）：</li></ul><script type="math/tex; mode=display">P\left(Y_{v} \mid X, Y_{w}, w \neq v\right)=P\left(Y_{v} \mid X, Y_{w}, w \sim v\right)</script><p>则称条件概率<script type="math/tex">P(Y|X)</script>为条件随机场</p><ul><li>另外有CRF的特例：<strong>线性链条件随机场</strong>，满足马尔可夫性：</li></ul><script type="math/tex; mode=display">\begin{array}{c}P\left(Y_{i} \mid X, Y_{1}, \cdots, Y_{i-1}, Y_{i+1}, \cdots, Y_{n}\right)=P\left(Y_{i} \mid X, Y_{i-1}, Y_{i+1}\right) \\i=1,2, \cdots, n \text { (在 } i=1 \text { 和 } n \text { 时只考虑单边) }\end{array}</script><p>则称条件概率<script type="math/tex">P(Y|X)</script>为条件随机场，图结构如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221029152606453.png" alt="image-20221029152606453" style="zoom: 67%;" /></p><ul><li>CRF定义中没有要求X的结构，但是一般假设X和Y有相同的图结构，比如线性链条件随机场：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221029152749755.png" alt="image-20221029152749755" style="zoom:67%;" /></p><p>在标注问题中（如NER），X表示输入观测序列，Y表示对应的输出标记序列或状态序列</p><h3 id="2-4-CRF的参数"><a href="#2-4-CRF的参数" class="headerlink" title="2.4 CRF的参数"></a>2.4 CRF的参数</h3><ul><li>现在开始介绍的CRF都默认为线性链CRF</li><li>前面说过，马尔科夫场的概率可以用极大团的势函数来表示：</li></ul><script type="math/tex; mode=display">P(Y)=\frac{1}{Z} \prod_{C} \Psi_{C}\left(Y_{C}\right) = \frac{1}{Z}\exp \sum_C-E\left(Y_{C}\right) = \frac{1}{Z}\exp \sum_CF_C\left(Y_{C}\right)</script><ul><li>对于线性链CRF，每一个<script type="math/tex">y_{i-1}, y_i</script>构成一个极大团，所以：</li></ul><script type="math/tex; mode=display">P(Y|X) = \frac{1}{Z}\exp \sum_{t=1}^TF_t(y_{t-1},y_t,x)</script><p>其中T为时间步数，<script type="math/tex">x</script>为X的取值，是整个观测序列。<strong>由于每个极大团的结构都相同</strong>，所以可以<strong>简化为每个极大团的势函数都一样</strong>：</p><script type="math/tex; mode=display">P(Y|X) = \frac{1}{Z}\exp \sum_{t=1}^TF(y_{t-1},y_t,x)</script><ul><li>而对于每个<script type="math/tex">F(y_{t-1},y_t,x)</script>，可以表示为三个函数的和：</li></ul><script type="math/tex; mode=display">F(y_{t-1},y_t,x) = F_1(y_{t-1}, x) + F_1(y_t, x) + F_2(y_{t-1}, y_t, x)</script><p>其中<script type="math/tex">F_1</script>就称为<strong>状态函数</strong>，<script type="math/tex">F_2</script>称为<strong>转移函数</strong>。由于<script type="math/tex">F_1(y_{t-1},x)</script>在上一个时间步已经出现过了，所以可以直接去掉：</p><script type="math/tex; mode=display">F(y_{t-1},y_t,x) = F_1(y_t, x) + F_2(y_{t-1}, y_t, x)</script><ul><li>那么可以引入特征函数来定义<script type="math/tex">F_1, F_2</script>：</li></ul><script type="math/tex; mode=display">F_1 = \sum_{l=1}^{K_2}\mu_ls_l(y_t, x) \\F_2 = \sum_{k=1}^{K_1}\lambda_kt_k(y_{t-1}, y_t, x)</script><ul><li>所以条件概率就表示为：</li></ul><script type="math/tex; mode=display">P(Y|X) = \frac{1}{Z}\exp \sum_{t=1}^T(\sum_{k=1}^{K_1}\lambda_kt_k(y_{t-1}, y_t, x) + \sum_{l=1}^{K_2}\mu_ls_l(y_t, x))</script><ul><li>而可以把关于时间步的求和放入括号中：</li></ul><script type="math/tex; mode=display">P(Y|X) = \frac{1}{Z}\exp(\sum_{k=1}^{K_1}\lambda_k\sum_{t=1}^Tt_k(y_{t-1}, y_t, x)+\sum_{l=1}^{K_2}\mu_l\sum_{t=1}^Ts_l(y_t, x))</script><ul><li>将两种特征函数和其权重合起来：</li></ul><script type="math/tex; mode=display">f_{k}\left(y_{t-1}, y_{t}, x\right)=\left\{\begin{array}{l}t_{k}\left(y_{t-1}, y_{t}, x\right), \quad k=1,2, \cdots, K_{1} \\s_{l}\left(y_{t}, x\right), \quad k=K_{1}+l ; l=1,2, \cdots, K_{2}\end{array}\right.  \\w_{k}=\left\{\begin{array}{ll}\lambda_{k}, & k=1,2, \cdots, K_{1} \\\mu_{l}, & k=K_{1}+l ; l=1,2, \cdots, K_{2}\end{array}\right.</script><p>然后对特征函数在各个时间步进行求和，记作：</p><script type="math/tex; mode=display">f_{k}(y, x)=\sum_{t=1}^{T} f_{k}\left(y_{t-1}, y_{t}, x\right), \quad k=1,2, \cdots, K</script><ul><li>所以条件概率化简为：</li></ul><script type="math/tex; mode=display">P(y \mid x)=\frac{1}{Z(x)} \exp \sum_{k=1}^{K} w_{k} f_{k}(y, x)</script><ul><li>上式采用向量化表示，引入：</li></ul><script type="math/tex; mode=display">\begin{array}{c}w=\left(w_{1}, w_{2}, \cdots, w_{K}\right)^{\mathrm{T}} \\F(y, x)=\left(f_{1}(y, x), f_{2}(y, x), \cdots, f_{K}(y, x)\right)^{\mathrm{T}}\end{array}</script><p>所以条件概率的向量化表示为：</p><script type="math/tex; mode=display">\begin{array}{l}P_{w}(y \mid x)=\frac{\exp (w \cdot F(y, x))}{Z_{w}(x)} \\Z_{w}(x)=\sum_{y} \exp (w \cdot F(y, x))\end{array}</script><p><strong>其中特征函数<script type="math/tex">F(y,x)</script>是事先设计好给出的，而学习的目标即学习权重<script type="math/tex">w</script>，最大化特征函数的总得分</strong></p><h3 id="2-5-概率计算"><a href="#2-5-概率计算" class="headerlink" title="2.5 概率计算"></a>2.5 概率计算</h3><ul><li>和前面HMM一样，同样运用前向后向算法的变量来进行概率计算，首先定义一个矩阵，<strong>为了方便讨论，我们又引入了两个时间步的状态序列<script type="math/tex">y_0 = start, y_{T+1} = stop</script>，实际前文的讨论中也隐含了<script type="math/tex">y_0 = start</script>：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{c}M_{t}(x)=\left[M_{t}\left(y_{t-1}, y_{t} \mid x\right)\right] \\M_{t}\left(y_{t-1}, y_{t} \mid x\right)=\exp \sum_{k=1}^{K} w_{k} f_{k}\left(y_{t-1}, y_{t}, x\right)\end{array}</script><p>设<script type="math/tex">y_t</script>有m个取值，则矩阵<script type="math/tex">M_t(x)</script>里面的<script type="math/tex">y_t,y_{t-1}</script>分别取不同的m个值，所以<script type="math/tex">M_t(x)</script>是一个<script type="math/tex">m \times m</script>阶矩阵</p><ul><li>有了上述定义，可以将条件概率进一步写为矩阵形式：</li></ul><script type="math/tex; mode=display">P_{w}(y \mid x)=\frac{1}{Z_{w}(x)} \prod_{t=1}^{T} M_{t}\left(y_{t-1}, y_{t} \mid x\right)</script><p>其中<script type="math/tex">Z_w(x)</script>是T+1个矩阵乘积的第(start, end)元素：</p><script type="math/tex; mode=display">Z_{w}(x)=\left(M_{1}(x) M_{2}(x) \cdots M_{T+1}(x)\right)_{\text {start,stop }}</script><ul><li>现在来定义<strong>前向概率，<script type="math/tex">\alpha_t(y_t|x)</script>为在时刻t时观测序列为<script type="math/tex">x_1, ..., x_t</script>，且当前状态为<script type="math/tex">y_t</script>的概率</strong>：</li></ul><script type="math/tex; mode=display">\alpha_{t}\left(y_{t} \mid x\right)=\alpha_{t-1}\left(y_{t-1} \mid x\right) M_{t}\left(y_{t-1}, y_{t} \mid x\right) \quad t=1,...,T+1 \\\alpha_{0}(y \mid x)=\left\{\begin{array}{ll}1, & y=\operatorname{start} \\0, & \text { 否则 }\end{array}\right.</script><p>因为<script type="math/tex">y_t</script>有m个取值，所以可以定义m维向量<script type="math/tex">\alpha_t(x)</script>：</p><script type="math/tex; mode=display">\alpha_{t}^{\mathrm{T}}(x)=\alpha_{t-1}^{\mathrm{T}}(x) M_{t}(x) \\\alpha_0(x) = \mathbb{1}（单位向量）</script><ul><li>同样可以定义<strong>后向概率，<script type="math/tex">\beta_t(y_t|x)</script>为在时刻t观测序列为<script type="math/tex">x_{t+1}, ..., x_T</script>，且当前状态为<script type="math/tex">y_t</script>的概率：</strong></li></ul><script type="math/tex; mode=display">\beta_{t}\left(y_{t} \mid x\right)=M_{t}\left(y_{t}, y_{t+1} \mid x\right) \beta_{t+1}\left(y_{t+1} \mid x\right) \\\beta_{t+1}\left(y \mid x\right)=\left\{\begin{array}{ll}1, & y=\text { stop } \\0, & \text { 否则 }\end{array}\right.</script><p>同样有向量形式：</p><script type="math/tex; mode=display">\beta_{t}(x)=M_{t+1}(x) \beta_{t+1}(x) \\\beta_{T+1}(x) = \mathbb{1}  (单位向量)</script><ul><li>得到了前后向概率，就可以得到<strong>在时刻t状态是<script type="math/tex">y_t</script>的概率：</strong></li></ul><script type="math/tex; mode=display">P\left(Y_{t}=y_{t} \mid x\right)=\frac{\alpha_{t}\left(y_{t} \mid x\right) \beta_{t}\left(y_{t} \mid x\right)}{Z(x)}</script><ul><li>以及<strong>在时刻t-1状态是<script type="math/tex">y_{t-1}</script>并且在时刻t状态是<script type="math/tex">y_t</script>的概率：</strong></li></ul><script type="math/tex; mode=display">P\left(Y_{t-1}=y_{t-1}, Y_{t}=y_{t} \mid x\right)=\frac{\alpha_{t-1}\left(y_{t-1} \mid x\right) M_{t}\left(y_{t-1}, y_{t} \mid x\right) \beta_{t}\left(y_{t} \mid x\right)}{Z(x)}</script><ul><li>上述两个式子的<script type="math/tex">Z(x)</script>可以用更简单的形式表达：</li></ul><script type="math/tex; mode=display">Z(x) = \alpha_n^T(x)\mathbb{1} = \mathbb{1}\beta_1(x)</script><h3 id="2-6-学习和预测"><a href="#2-6-学习和预测" class="headerlink" title="2.6 学习和预测"></a>2.6 学习和预测</h3><ul><li><p>预测算法和HMM一样，使用<strong>维特比算法</strong></p></li><li><p>学习算法其实就是<a href="https://zlkqz.site/2022/10/27/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/#3-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95">最大熵模型的学习</a></p></li></ul><h1 id="3-HMM和CRF的区别"><a href="#3-HMM和CRF的区别" class="headerlink" title="3 HMM和CRF的区别"></a>3 HMM和CRF的区别</h1><ul><li>CRF和HMM的数学推导几乎是一样的，但是差异在于：</li></ul><blockquote><ol><li>HMM属于贝叶斯网络，而CRF属于马尔可夫场，前者的假设和约束更加的严格，比如CRF并没有像HMM一样完全依赖上一步的状态，HMM的观测变量的生成是独立的</li><li>上述我们讨论的仅仅只是线性链CRF，但是CRF还可以有其他的图结构，并且<strong>实际上可以任意选定特征函数的个数和形式，特征函数的不确定也是CRF能和深度学习融合的最主要原因，模型可以自己学习特征函数，并且不用显示地表达出来</strong></li></ol></blockquote><h1 id="4-CRF和深度学习模型的结合"><a href="#4-CRF和深度学习模型的结合" class="headerlink" title="4 CRF和深度学习模型的结合"></a>4 CRF和深度学习模型的结合</h1><ul><li><p>以BiLSTM+CRF做NER任务举例</p></li><li><p>如果不用CRF而是直接在模型的后面接一个Softmax，鉴于所选取的基模型的强大的特征抽取能力，这已经可以有比较好的分类效果，<strong>但是NER任务是存在一些约束的</strong>，比如BIO格式中，B-Person后面不可能跟I-Organization。<strong>Softmax的分类是每个时间步相互独立的，所以可能会出现上述的问题</strong></p></li><li><p><strong>而CRF层可以加入一些约束来保证最终预测结果是有效的，这些约束可以在训练数据时被CRF层自动学习得到</strong></p></li><li><p>首先介绍一下模型结构：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-0650e1511e7d4419c9528a8d08ea61fd_720w.webp" alt="img" style="zoom:80%;" /></p><p>BiLSTM的输出经过Dense层，<strong>转化为每个Label对应的score（图中浅黄色部分），这个score即CRF中的状态得分<script type="math/tex">\sum \mu s</script></strong>，然后将其输入CRF，CRF层维护了一个转移矩阵（Transition Matrix），这也是CRF层中需要学习的参数，假设总共有包括START和END在内的7个label，则转移矩阵为：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-2064e34cece3be4e852b1ace6bbca2ba_720w.webp" alt="img" style="zoom:67%;" /></p><p><strong>每个元素代表了相邻时间步之间进行状态转移的score，这个score即CRF中的转移得分<script type="math/tex">\sum\lambda t</script></strong>，并且上述矩阵已经学到了一些有用的约束：</p><blockquote><ol><li>句子的第一个单词应该是“B-” 或 “O”，而不是“I”。（从“START”-&gt;“I-Person 或 I-Organization”的转移分数很低）</li><li>“B-label1 I-label2 I-label3…”，在该模式中，类别1,2,3应该是同一种实体类别。比如，“B-Person I-Person” 是正确的，而“B-Person I-Organization”则是错误的。（“B-Organization” -&gt; “I-Person”的分数很低）</li><li>O I-label”是错误的，命名实体的开头应该是“B-”而不是“I-”</li></ol></blockquote><ul><li>每个输入有N中可能的结果，即N条路径，比如（加粗的为真实路径）：</li></ul><blockquote><ol><li>START B-Person B-Person B-Person B-Person B-Person END</li><li>START B-Person I-Person B-Person B-Person B-Person END</li><li><strong>START B-Person I-Person O B-Organization O END</strong></li></ol><p>……</p><p>   N. O O O O O O O</p></blockquote><ul><li>训练目标即最大化真实路径的得分，可得损失函数：</li></ul><script type="math/tex; mode=display">Loss =-\log \frac{P_{\text {Real Path }}}{P_{1}+P_{2}+\ldots+P_{N}}  =-\log \frac{e^{s_{\text {Realpath }}}}{e^{s_{1}+e^{s_{2}}+\ldots+e^{s_{N}}}}  \\ =-\left(S_{\text {RealPath }}-\log \left(e^{S_{1}}+e^{S_{2}}+\ldots+e^{S_{N}}\right)\right)</script><p>其中<script type="math/tex">S_i</script>为一条路径对应的得分，是通过Softmax实现最大化的</p><ul><li><p>值得一提的是，计算分母中的所有路径的得分和<script type="math/tex">-\log (e^{S_1} + ... + e^{S_N})</script>不需要列举所有可能路径，可以用一种动态规划的方法降低计算复杂度</p></li><li><p>另外，在进行预测的时候，同样是使用维特比算法</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最大熵模型</title>
    <link href="/2022/05/26/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/05/26/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-最大熵模型"><a href="#1-最大熵模型" class="headerlink" title="1 最大熵模型"></a>1 最大熵模型</h1><h3 id="1-1-最大熵原理"><a href="#1-1-最大熵原理" class="headerlink" title="1.1 最大熵原理"></a>1.1 最大熵原理</h3><ul><li><p><strong>最大熵原理：</strong>学习概率模型时，在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型的集合，所以最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型</p></li><li><p>假设离散变量<script type="math/tex">X</script>的概率分布为<script type="math/tex">P(X)</script>，则其熵为：</p></li></ul><script type="math/tex; mode=display">H(P) = -\sum_xP(x)\log P(x)</script><p>熵的取值范围：<script type="math/tex">0 \le H(P) \le \log|X|</script>，在<script type="math/tex">X</script>为均匀分布时熵取得最大</p><ul><li>所以在没有任何约束时，<script type="math/tex">X</script>直接取均匀分布，熵即可达到最大</li><li><strong>条件熵：</strong>在已知X的情况下，求Y的条件熵：</li></ul><script type="math/tex; mode=display">H(Y|X) = \sum_{x}p(x)H(Y|X=x) = -\sum_xp(x)\sum_yp(y|x)log(p(y|x))</script><h3 id="1-2-模型约束"><a href="#1-2-模型约束" class="headerlink" title="1.2 模型约束"></a>1.2 模型约束</h3><ul><li>前面说到最大熵原理是在约束的模型集合中寻找熵最大的，那么介绍一下最大熵模型的约束为什么</li><li>假设是一个分类模型<script type="math/tex">P(Y|X)</script>，首先给定训练集<script type="math/tex">T = \{(x_1, y_1), ...,(x_N, y_N)\}</script>，那么可以由统计得到经验分布：</li></ul><script type="math/tex; mode=display">\begin{array}{l}\tilde{P}(X=x, Y=y)=\frac{v(X=x, Y=y)}{N} \\\tilde{P}(X=x)=\frac{v(X=x)}{N}\end{array}</script><ul><li><strong>特征函数：</strong><script type="math/tex">f(x, y)</script>用于描述输入x和输出y之间的某个事实：</li></ul><script type="math/tex; mode=display">f(x, y)=\left\{\begin{array}{ll}1, & x \text { 与 } y \text { 满足某一事实 } \\0, & \text { 否则 }\end{array}\right.</script><p>特征函数的形式很多样，可以是对数据中字、词的统计信息作为输入，甚至可以直接用某些模型（如BERT）的输出作为输入</p><ul><li>那么特征函数关于经验分布<script type="math/tex">\tilde{P}(X,Y)</script>的期望值为：</li></ul><script type="math/tex; mode=display">E_{\tilde{P}}(f) = \sum_{x,y}\tilde{P}(x,y)f(x,y)</script><ul><li>特征函数关于模型<script type="math/tex">P(X|Y)</script>和经验分布<script type="math/tex">\tilde{P}(X)</script>的期望值为：</li></ul><script type="math/tex; mode=display">E_P(f) = \sum_{x,y}\tilde{P}(x)P(y|x)f(x,y)</script><ul><li><strong>而最大熵模型的假设为这两个期望值相等，即：</strong></li></ul><script type="math/tex; mode=display">E_P(f) = E_{\tilde{P}}(f)</script><p>这就是最大熵模型的约束，有几个特征函数就有几个约束</p><h3 id="1-3-模型定义"><a href="#1-3-模型定义" class="headerlink" title="1.3 模型定义"></a>1.3 模型定义</h3><ul><li>假设满足所有约束条件的模型集合为<script type="math/tex">\mathcal{C} \equiv\left\{P \in \mathcal{P} \mid E_{P}\left(f_{i}\right)=E_{\tilde{P}}\left(f_{i}\right), \quad i=1,2, \cdots, n\right\}</script>，定义在概率分布<script type="math/tex">P(Y|X)</script>上的条件熵为：</li></ul><script type="math/tex; mode=display">H(P)=-\sum_{x, y} \tilde{P}(x) P(y \mid x) \log P(y \mid x)</script><p>则模型集合<script type="math/tex">\mathcal{C}</script>中<script type="math/tex">H(P)</script>最大的模型就称为最大熵模型</p><h1 id="2-最大熵模型的学习"><a href="#2-最大熵模型的学习" class="headerlink" title="2 最大熵模型的学习"></a>2 最大熵模型的学习</h1><ul><li>根据上面所述，现在问题就变为了一个带约束的最优化问题：</li></ul><script type="math/tex; mode=display">\begin{array}{ll}\max _{P \in \mathrm{C}} & H(P)=-\sum_{x, y} \tilde{P}(x) P(y \mid x) \log P(y \mid x) \\\text { s.t. } & E_{P}\left(f_{i}\right)=E_{\tilde{P}}\left(f_{i}\right), \quad i=1,2, \cdots, n \\& \sum_{y} P(y \mid x)=1\end{array}</script><ul><li>上述问题可使用拉格朗日优化，引入拉格朗如乘子并得到对偶问题进行求解，具体过程可参考<a href="https://zlkqz.site/2022/09/26/SVM/#2-2-%E5%8E%9F%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96%E5%88%B0%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98">SVM的学习</a>，<strong>首先引入拉格朗日乘子<script type="math/tex">w_0, w_1, ...,w_n</script>得到拉格朗日函数：</strong></li></ul><script type="math/tex; mode=display">L(P, w) \equiv-H(P)+w_{0}\left(1-\sum_{y} P(y \mid x)\right)+\sum_{i=1}^{n} w_{i}\left(E_{\tilde{P}}\left(f_{i}\right)-E_{P}\left(f_{i}\right)\right)</script><ul><li><strong>然后将原始问题<script type="math/tex">\min _{P \in \mathbf{C}} \max _{w} L(P, w)</script>转化为对偶问题<script type="math/tex">\max _{w} \min _{P \in \mathbf{C}} L(P, w)</script>，先只考虑里面的最小化问题<script type="math/tex">\min _{P \in \mathbf{C}} L(P, w)</script>，求偏导<script type="math/tex">\frac{\partial L(P,w)}{\partial P(y|x)} = 0</script>，最后可以解得：</strong></li></ul><script type="math/tex; mode=display">P_{w}(y \mid x)=\frac{1}{Z_{w}(x)} \exp \left(\sum_{i=1}^{n} w_{i} f_{i}(x, y)\right)</script><p>其中<script type="math/tex">w_i</script>为每个特征函数对应的权重，也是拉格朗日优化时的拉格朗日乘子。<script type="math/tex">Z_w(x)</script>为规范化因子：</p><script type="math/tex; mode=display">Z_{w}(x)=\sum_{y} \exp \left(\sum_{i=1}^{n} w_{i} f_{i}(x, y)\right)</script><ul><li>那么接下来的任务变成了外部的极大化问题，即将上述<script type="math/tex">P_w(y|x)</script>带入<script type="math/tex">L(P,w)</script>得到<script type="math/tex">\Psi(w)</script>，然后寻找：</li></ul><script type="math/tex; mode=display">w^{*}=\underset{w}{\arg \max } \Psi(w)</script><ul><li><strong>而上述对偶函数的极大化等价于最大熵模型的极大似然估计</strong></li></ul><blockquote><p><strong>证明：</strong></p><p>当概率分布<script type="math/tex">P(y|x)</script>是最大熵模型时，对数似然函数为：</p><script type="math/tex; mode=display">\begin{aligned}L_{\tilde{P}}\left(P_{w}\right) &=\log\prod_{x,y}P(y|x)^{\tilde{P}(x,y)} = \sum_{x, y} \tilde{P}(x, y) \log P(y \mid x) \\&=\sum_{x, y} \tilde{P}(x, y) \sum_{i=1}^{n} w_{i} f_{i}(x, y)-\sum_{x, y} \tilde{P}(x, y) \log Z_{w}(x) \\&=\sum_{x, y} \tilde{P}(x, y) \sum_{i=1}^{n} w_{i} f_{i}(x, y)-\sum_{x} \tilde{P}(x) \log Z_{w}(x)\end{aligned}</script><p>而上述对偶函数<script type="math/tex">\Psi(w)</script>中，有一项<script type="math/tex">w_{0}\left(1-\sum_{y} P(y \mid x)\right)</script>，由于<script type="math/tex">w</script>中并没有包含<script type="math/tex">w_0</script>，所以这一项可以直接去掉，不影响优化，所以：</p><script type="math/tex; mode=display">\begin{aligned}\Psi(w)=& \sum_{x, y} \tilde{P}(x) P_{w}(y \mid x) \log P_{w}(y \mid x) +\sum_{i=1}^{n} w_{i}\left(\sum_{x, y} \tilde{P}(x, y) f_{i}(x, y)-\sum_{x, y} \tilde{P}(x) P_{w}(y \mid x) f_{i}(x, y)\right) \\=& \sum_{x, y} \tilde{P}(x, y) \sum_{i=1}^{n} w_{i} f_{i}(x, y)+\sum_{x, y} \tilde{P}(x) P_{w}(y \mid x)\left(\log P_{w}(y \mid x)-\sum_{i=1}^{n} w_{i} f_{i}(x, y)\right) \\=& \sum_{x, y} \tilde{P}(x, y) \sum_{i=1}^{n} w_{i} f_{i}(x, y)-\sum_{x, y} \tilde{P}(x) P_{w}(y \mid x) \log Z_{w}(x) \\=& \sum_{x, y} \tilde{P}(x, y) \sum_{i=1}^{n} w_{i} f_{i}(x, y)-\sum_{x} \tilde{P}(x) \log Z_{w}(x)\end{aligned}</script><p>由上述两个式子可以得到：</p><script type="math/tex; mode=display">\Psi(w)=L_{\tilde{p}}\left(P_{w}\right)</script></blockquote><h1 id="3-优化算法"><a href="#3-优化算法" class="headerlink" title="3 优化算法"></a>3 优化算法</h1><ul><li>现在我们是要最大化似然函数或者对偶函数，但是<strong>该函数并没有显式的解析解</strong>（有解析解，但是找不到），所以需要运用一些优化算法</li><li>值得庆幸的是，对偶函数的目标函数具有很好的性质，<strong>他是光滑的凸函数，因此多种最优化方法都适用，并且保证能找到全局最优解</strong></li></ul><h3 id="3-1-改进的迭代尺度法"><a href="#3-1-改进的迭代尺度法" class="headerlink" title="3.1 改进的迭代尺度法"></a>3.1 改进的迭代尺度法</h3><ul><li>算法流程：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221027204416341.png" alt="image-20221027204416341" style="zoom:80%;" /></p><ul><li>这一算法的关键是(a)，即求解<script type="math/tex">\delta_i</script>，如果<script type="math/tex">f\#(x,y)</script>是常数，即对于任意x,y，都有<script type="math/tex">f\#(x,y) = M</script>，那么：</li></ul><script type="math/tex; mode=display">\delta_{i}=\frac{1}{M} \log \frac{E_{\tilde{p}}\left(f_{i}\right)}{E_{p}\left(f_{i}\right)}</script><p>如果<script type="math/tex">f\#(x,y)</script>不为常数，最简单有效的是<strong>牛顿法</strong>，将(a)中需要求解的方程表示为<script type="math/tex">g(\delta_i) = 0</script>，然后通过牛顿法最小化<script type="math/tex">g(\delta_i)</script>，每次迭代的公式为：</p><script type="math/tex; mode=display">\delta_{i}^{(k+1)}=\delta_{i}^{(k)}-\frac{g\left(\delta_{i}^{(k)}\right)}{g^{\prime}\left(\delta_{i}^{(k)}\right)}</script><h3 id="3-2-拟牛顿法"><a href="#3-2-拟牛顿法" class="headerlink" title="3.2 拟牛顿法"></a>3.2 拟牛顿法</h3><ul><li>算法流程：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221027205121849.png" alt="image-20221027205121849" style="zoom:80%;" /></p><h1 id="4-牛顿法和拟牛顿法"><a href="#4-牛顿法和拟牛顿法" class="headerlink" title="4 牛顿法和拟牛顿法"></a>4 牛顿法和拟牛顿法</h1><ul><li>上面提到了牛顿法和拟牛顿法，这节就简要介绍以下其原理</li><li>他们都是<strong>求解无约束最优化问题</strong>的常用方法，有收敛速度快的优点</li></ul><h3 id="4-1-牛顿法"><a href="#4-1-牛顿法" class="headerlink" title="4.1 牛顿法"></a>4.1 牛顿法</h3><ul><li>考虑最优化：<script type="math/tex">\min_{x \in R^n}f(x)</script>，假设<script type="math/tex">f(x)</script>具有二阶连续偏导数，若第k次迭代之为<script type="math/tex">x^{(k)}</script>，则可将<script type="math/tex">f(x)</script>在<script type="math/tex">x^{(k)}</script>处进行二阶泰勒展开：</li></ul><script type="math/tex; mode=display">f(x)=f\left(x^{(k)}\right)+g_{k}^{\mathrm{T}}\left(x-x^{(k)}\right)+\frac{1}{2}\left(x-x^{(k)}\right)^{\mathrm{T}} H\left(x^{(k)}\right)\left(x-x^{(k)}\right)</script><p>其中<script type="math/tex">g_k = g(x^{(k)}) = \nabla f(x^{(k)})</script>是<script type="math/tex">f(x)</script>的梯度在<script type="math/tex">x^{(k)}</script>的值，<script type="math/tex">H(x^{k})</script>是黑塞矩阵<script type="math/tex">H(x)=\left[\frac{\partial^{2} f}{\partial x_{i} \partial x_{j}}\right]_{n \times n}</script>在<script type="math/tex">x^{(k)}</script>的值</p><ul><li>函数<script type="math/tex">f(x)</script>有极值的必要条件是一阶导数为0，即<script type="math/tex">\nabla f(x) = 0</script>。特别的当<script type="math/tex">H(x)</script>为正定矩阵时，该点为极小值点</li><li><p>牛顿法的每次迭代，从<script type="math/tex">x^{(k)}</script>开始，将目标函数的极小值点作为下次迭代的<script type="math/tex">x^{(k+1)}</script>，其满足<script type="math/tex">\nabla f(x^{(k+1)}) = 0</script></p></li><li><p>而将上面的泰勒展开求梯度，得到：</p></li></ul><script type="math/tex; mode=display">\nabla f(x) = g_k + H_k(x - x^{(k)}) = 0</script><p>其中<script type="math/tex">H_k = H(x^{(k)})</script></p><ul><li>所以得到：</li></ul><script type="math/tex; mode=display">x^{(k+1)} = x^{(k)} - H_k^{-1}g_k = x^{(k)} + p_k</script><ul><li>将上面的流程总结：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221027212238000.png" alt="image-20221027212238000" style="zoom:80%;" /></p><h3 id="4-2-拟牛顿法"><a href="#4-2-拟牛顿法" class="headerlink" title="4.2 拟牛顿法"></a>4.2 拟牛顿法</h3><ul><li>由于计算黑塞矩阵的逆<script type="math/tex">H^{-1}</script>比较复杂，所以考虑使用一个n阶矩阵<script type="math/tex">G_k</script>来代替<script type="math/tex">H_k^{-1}</script>，这就是拟牛顿法的思想</li><li>由上面牛顿法中的<script type="math/tex">\nabla f(x^{(k+1)}) = 0</script>的方程可得：</li></ul><script type="math/tex; mode=display">g_{k+1} - g_k = H_k(x^{(k)} - x^{(k)})</script><p>设<script type="math/tex">y_k = g_{k+1} - g_k, \delta_k = x^{(k)} - x^{(k)}</script>，上式可写为：</p><script type="math/tex; mode=display">y_k = H_k\delta_k  \\H_k^{-1}y_k = \delta_k</script><p>上式称为<strong>拟牛顿条件</strong></p><ul><li><p>而上面说过，要保证<script type="math/tex">H_k</script>是正定矩阵，才能保证驻点一定是极小值点。所以<script type="math/tex">H_k</script>同时满足拟牛顿条件和正定矩阵两个条件</p></li><li><p><strong>而近似矩阵<script type="math/tex">G_k</script>同样满足这两个条件，即可将其作为近似的矩阵</strong></p></li></ul><h4 id="4-2-1-DFP算法"><a href="#4-2-1-DFP算法" class="headerlink" title="4.2.1 DFP算法"></a>4.2.1 DFP算法</h4><ul><li>现在重点就变成了如何对<script type="math/tex">G_k</script>进行更新，才能保证<script type="math/tex">G_{k+1}</script>同样满足条件</li><li>假设G的更新是加上两个附加项构成的，即：</li></ul><script type="math/tex; mode=display">G_{k+1} = G_k + P_k + Q_k</script><ul><li>这时：</li></ul><script type="math/tex; mode=display">G_{k+1}y_k = G_ky_k + P_ky_k + Q_ky_k</script><p>为使<script type="math/tex">G_{k+1}</script>满足拟牛顿条件，<script type="math/tex">P_k, Q_k</script>要满足：</p><script type="math/tex; mode=display">\begin{array}{c}P_{k} y_{k}=\delta_{k} \\Q_{k} y_{k}=-G_{k} y_{k}\end{array}</script><ul><li>这样的矩阵不难找出，例如：</li></ul><script type="math/tex; mode=display">\begin{array}{c}P_{k}=\frac{\delta_{k} \delta_{k}^{\mathrm{T}}}{\delta_{k}^{\mathrm{T}} y_{k}} \\Q_{k}=-\frac{G_{k} y_{k} y_{k}^{\mathrm{T}} G_{k}}{y_{k}^{\mathrm{T}} G_{k} y_{k}}\end{array}</script><ul><li>所以更新公式为：</li></ul><script type="math/tex; mode=display">G_{k+1}=G_{k}+\frac{\delta_{k} \delta_{k}^{\mathrm{T}}}{\delta_{k}^{\mathrm{T}} y_{k}}-\frac{G_{k} y_{k} y_{k}^{\mathrm{T}} G_{k}}{y_{k}^{\mathrm{T}} G_{k} y_{k}}</script><ul><li>总结一下DFP算法的算法流程：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221027214008428.png" alt="image-20221027214008428" style="zoom:80%;" /></p><h4 id="4-2-2-BFGS算法"><a href="#4-2-2-BFGS算法" class="headerlink" title="4.2.2 BFGS算法"></a>4.2.2 BFGS算法</h4><ul><li><p>BFGS算法比DFS算法更加常用，后者是用<script type="math/tex">G_k</script>逼近<script type="math/tex">H^{-1}</script>，而BFGS是用<script type="math/tex">B_k</script>逼近<script type="math/tex">H</script></p></li><li><p>算法流程：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221027214231809.png" alt="image-20221027214231809" style="zoom:80%;" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>集成学习</title>
    <link href="/2022/05/17/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/17/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><ul><li>集成学习（ensemble learning）通过构建并结合多个学习器来完成学习任务。其中每个<strong>个体学习器</strong>如果都使用同样的算法，则称这种集成是<strong>同质</strong>的，同质集成中的个体学习器亦称<strong>基学习器</strong>，反之则为<strong>异质</strong>的</li><li><p>集成学习的相比于单一学习器可获得更优越的泛化性能，这对<strong>弱学习器（泛化性能略优于随机猜测的学习器）</strong>尤为明显</p></li><li><p><strong>对于每个个体学习器，要有一定的准确性，即学习器不能太坏，也要有多样性，即学习器间具有差异</strong></p></li><li><p>做一个简单的分析：</p></li></ul><blockquote><ul><li>考虑一个二分类问题，假设<strong>每个基学习器的错误率相互独立</strong>且为<script type="math/tex">\epsilon</script>，即对每个基学习器<script type="math/tex">h_i</script>有：</li></ul><script type="math/tex; mode=display">P(h_i(x) \neq f(x)) = \epsilon</script><ul><li>假设集成时使用简单投票法结合T个基学习器：</li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\operatorname{sign}\left(\sum_{i=1}^{T} h_{i}(\boldsymbol{x})\right)</script><ul><li>由于每个基学习器的错误率相互独立，则由Hoeffding不等式可知，集成错误率为：</li></ul><script type="math/tex; mode=display">\begin{aligned}P(H(\boldsymbol{x}) \neq f(\boldsymbol{x})) &=\sum_{k=0}^{\lfloor T / 2\rfloor}C_T^k(1-\epsilon)^{k} \epsilon^{T-k} \\& \leqslant \exp \left(-\frac{1}{2} T(1-2 \epsilon)^{2}\right)\end{aligned}</script><ul><li><strong>由上式可得：随着T的增大，集成的错误率降指数级下降，最终趋于0</strong></li></ul></blockquote><ul><li>在上面的分析中提到了一个关键的假设：基学习器的误差相互独立。但是在现实任务中是不可能的。目前的集成学习方法可大致分为两类：</li></ul><blockquote><ol><li>个体学习器之间存在强依赖关系，必须串行生成的序列化方法，代表是Boosting</li><li>个体学习器之间不存在强依赖关系，可同时生成的并行化方法，代表是Bagging和随机森林（RF）</li></ol></blockquote><h1 id="2-Boosting"><a href="#2-Boosting" class="headerlink" title="2 Boosting"></a>2 Boosting</h1><ul><li>Boosting是一族可将弱学习器提升为强学习器的算法，工作机制为：<strong>先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器，如此重复直至得到事先指定的T</strong></li><li>从偏差-方差的角度看，<strong>Boosting主要关注降低偏差</strong></li></ul><h3 id="2-1-AdaBoost"><a href="#2-1-AdaBoost" class="headerlink" title="2.1 AdaBoost"></a>2.1 AdaBoost</h3><h4 id="2-1-1-算法流程"><a href="#2-1-1-算法流程" class="headerlink" title="2.1.1 算法流程"></a>2.1.1 算法流程</h4><ul><li>其中最著名的代表就是AdaBoost，考虑一个二分类任务，其算法流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221015122613734.png" alt="image-20221015122613734" style="zoom:80%;" /></p><p>其中的<script type="math/tex">D_t</script>为样本权重分布，反应了每个样本对基学习器的重要程度（反映在对loss的贡献上）。<script type="math/tex">\alpha_t</script>为每个基学习器的权重。在每次更新样本权重分布的时候提升分类错误样本的权重，其中<script type="math/tex">Z_t</script>是一个规范化因子</p><h4 id="2-1-2-损失函数"><a href="#2-1-2-损失函数" class="headerlink" title="2.1.2 损失函数"></a>2.1.2 损失函数</h4><ul><li>AdaBoost是基于加法模型，即基于学习器的线性组合：</li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\sum_{t=1}^{T} \alpha_{t} h_{t}(\boldsymbol{x})</script><p>来最小化指数损失函数：</p><script type="math/tex; mode=display">\ell_{\exp }(H \mid \mathcal{D})=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H(\boldsymbol{x})}\right]</script><p>其实<strong>指数函数是分类任务原本0/1损失函数的一致的替代损失函数</strong>（因为其拥有更好的数学性质）</p><blockquote><p><strong>证明：</strong></p><ul><li>求<script type="math/tex">H(x)</script>关于损失函数的偏导：</li></ul><script type="math/tex; mode=display">\frac{\partial \ell_{\exp }(H \mid \mathcal{D})}{\partial H(\boldsymbol{x})}=-e^{-H(\boldsymbol{x})} P(f(\boldsymbol{x})=1 \mid \boldsymbol{x})+e^{H(\boldsymbol{x})} P(f(\boldsymbol{x})=-1 \mid \boldsymbol{x})</script><ul><li>偏导数为0可求得极点：</li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\frac{1}{2} \ln \frac{P(f(x)=1 \mid \boldsymbol{x})}{P(f(x)=-1 \mid \boldsymbol{x})}</script><ul><li>因此有：</li></ul><script type="math/tex; mode=display">\begin{array}{l}sign(H(x)) =\left\{\begin{array}{l}1, \quad P(f(x)=1 \mid \boldsymbol{x})>P(f(x)=-1 \mid \boldsymbol{x}) \\-1, \quad P(f(x)=1 \mid \boldsymbol{x})<P(f(x)=-1 \mid \boldsymbol{x})\end{array}\right. \\=\underset{y \in\{-1,1\}}{\arg \max } P(f(x)=y \mid \boldsymbol{x})\end{array}</script></blockquote><h4 id="2-1-3-基学习器的权重"><a href="#2-1-3-基学习器的权重" class="headerlink" title="2.1.3 基学习器的权重"></a>2.1.3 基学习器的权重</h4><ul><li>在通过<script type="math/tex">D_t</script>产生<script type="math/tex">h_t</script>后，该基分类器的权重<script type="math/tex">\alpha_t</script>应使得<script type="math/tex">\alpha_th_t</script>最小化指数损失函数（在<script type="math/tex">D_t</script>分布上而非D分布）：</li></ul><script type="math/tex; mode=display">\begin{aligned}\ell_{\exp }\left(\alpha_{t} h_{t} \mid \mathcal{D}_{t}\right) &=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}_{t}}\left[e^{-f(\boldsymbol{x}) \alpha_{t} h_{t}(\boldsymbol{x})}\right] \\&=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}_{t}}\left[e^{-\alpha_{t}} \mathbb{I}\left(f(\boldsymbol{x})=h_{t}(\boldsymbol{x})\right)+e^{\alpha_{t}} \mathbb{I}\left(f(\boldsymbol{x}) \neq h_{t}(\boldsymbol{x})\right)\right] \\&=e^{-\alpha_{t}} P_{\boldsymbol{x} \sim \mathcal{D}_{t}}\left(f(\boldsymbol{x})=h_{t}(\boldsymbol{x})\right)+e^{\alpha_{t}} P_{\boldsymbol{x} \sim \mathcal{D}_{t}}\left(f(\boldsymbol{x}) \neq h_{t}(\boldsymbol{x})\right) \\&=e^{-\alpha_{t}}\left(1-\epsilon_{t}\right)+e^{\alpha_{t}} \epsilon_{t}\end{aligned}</script><ul><li>关于<script type="math/tex">\alpha_t</script>求导：</li></ul><script type="math/tex; mode=display">\frac{\partial \ell_{\exp }\left(\alpha_{t} h_{t} \mid \mathcal{D}_{t}\right)}{\partial \alpha_{t}}=-e^{-\alpha_{t}}\left(1-\epsilon_{t}\right)+e^{\alpha_{t}} \epsilon_{t} = 0 \\\alpha_t = \frac{1}{2}\ln(\frac{1 - \epsilon_t}{\epsilon_t})</script><h4 id="2-1-4-样本权重分布的更新"><a href="#2-1-4-样本权重分布的更新" class="headerlink" title="2.1.4 样本权重分布的更新"></a>2.1.4 样本权重分布的更新</h4><ul><li>在获得<script type="math/tex">H_{t-1}</script>后样本分布将进行调整，使下一轮的<script type="math/tex">h_t</script>能纠正<script type="math/tex">H_{t-1}</script>的一些错误，理想情况下能纠正<script type="math/tex">H_{t-1}</script>的全部错误，即最小化<script type="math/tex">\ell_{\exp }\left(H_{t-1}+\alpha_th_{t} \mid \mathcal{D}\right)</script>，可简化为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\ell_{\exp }\left(H_{t-1}+h_{t} \mid \mathcal{D}\right) &=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x})\left(H_{t-1}(\boldsymbol{x})+h_{t}(\boldsymbol{x})\right)}\right] \\&=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})} e^{-f(\boldsymbol{x}) h_{t}(\boldsymbol{x})}\right]\end{aligned}</script><p>其中的<script type="math/tex">e^{-f(x)h_t(x)}</script>可用泰勒展示近似：</p><script type="math/tex; mode=display">\begin{aligned}\ell_{\exp }\left(H_{t-1}+h_{t} \mid \mathcal{D}\right) & \simeq \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\left(1-f(\boldsymbol{x}) h_{t}(\boldsymbol{x})+\frac{f^{2}(\boldsymbol{x}) h_{t}^{2}(\boldsymbol{x})}{2}\right)\right] \\&=\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\left(1-f(\boldsymbol{x}) h_{t}(\boldsymbol{x})+\frac{1}{2}\right)\right]\end{aligned}</script><ul><li>于是理想的基学习器为：</li></ul><script type="math/tex; mode=display">\begin{array}{l}h_{t}(\boldsymbol{x})=\underset{h}{\arg \min } \ell_{\exp }\left(H_{t-1}+h \mid \mathcal{D}\right) \\=\underset{h}{\arg \max } \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})} f(\boldsymbol{x}) h(\boldsymbol{x})\right] \\=\underset{h}{\arg \max } \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[\frac{e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\right]} f(\boldsymbol{x}) h(\boldsymbol{x})\right]\end{array}</script><p>注意最后添加的分母是一个常数。令<script type="math/tex">D_t</script>表示分布：</p><script type="math/tex; mode=display">\mathcal{D}_{t}(\boldsymbol{x})=\frac{\mathcal{D}(\boldsymbol{x}) e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\right]}</script><p>则：</p><script type="math/tex; mode=display">\begin{aligned}h_{t}(\boldsymbol{x}) &=\underset{h}{\arg \max } \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[\frac{e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\right]} f(\boldsymbol{x}) h(\boldsymbol{x})\right] \\&=\underset{h}{\arg \max } \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}_{t}}[f(\boldsymbol{x}) h(\boldsymbol{x})]\end{aligned}</script><ul><li>而由于<script type="math/tex">f(\boldsymbol{x}) h(\boldsymbol{x})=1-2 \mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))</script>，所以：</li></ul><script type="math/tex; mode=display">h_{t}(\boldsymbol{x})=\underset{h}{\arg \min } \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}_{t}}[\mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))]</script><p><strong>所以理想的<script type="math/tex">h_t</script>将在<script type="math/tex">D_t</script>分布下最小化分类误差</strong>。因此，弱分类器将基于分布<script type="math/tex">D_t</script>来训练</p><ul><li>考虑由<script type="math/tex">D_t</script>推导到<script type="math/tex">D_{t-1}</script>：</li></ul><script type="math/tex; mode=display">\begin{aligned}\mathcal{D}_{t+1}(\boldsymbol{x}) &=\frac{\mathcal{D}(\boldsymbol{x}) e^{-f(\boldsymbol{x}) H_{t}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t}(\boldsymbol{x})}\right]} \\&=\frac{\mathcal{D}(\boldsymbol{x}) e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})} e^{-f(\boldsymbol{x}) \alpha_{t} h_{t}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t}(\boldsymbol{x})}\right]} \\&=\mathcal{D}_{t}(\boldsymbol{x}) \cdot e^{-f(\boldsymbol{x}) \alpha_{t} h_{t}(\boldsymbol{x})} \frac{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t-1}(\boldsymbol{x})}\right]}{\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[e^{-f(\boldsymbol{x}) H_{t}(\boldsymbol{x})}\right]}\end{aligned}</script><p>恰好对应算法流程总的更新公式</p><h3 id="2-2-调整数据分布的方法"><a href="#2-2-调整数据分布的方法" class="headerlink" title="2.2 调整数据分布的方法"></a>2.2 调整数据分布的方法</h3><ul><li>在上述算法流程中，是通过对每个样本赋予不同的权重来调整数据分布，称为<strong>重赋权法（re-weighting）</strong></li><li><p>但是某些基学习算法无法接受带权样本，这时可采样<strong>重采样法（re-sampling）</strong>，即在每一轮中根据样本分布对训练集进行重新采样，然后根据采样到的样本进行训练。<strong>一般而言，两种算法没有显著的优劣差别</strong></p></li><li><p>注意在算法流程中，如果得到的<script type="math/tex">\epsilon_t > 0.5</script>，则整个算法就终止了，如果采用的是重赋权法，可能导致过早停止致使因基学习器过少而导致的性能不佳。但是如果使用重采样法，可以通过重启动避免过早的停止，即如果当前分布训练出来的基学习器不好，则抛弃，然后重新采样再训练</p></li></ul><h1 id="3-Bagging"><a href="#3-Bagging" class="headerlink" title="3 Bagging"></a>3 Bagging</h1><ul><li>欲得到泛化性能强的集成，个体学习器之间应该尽可能相互独立，虽然在现实任务中无法得到，但是可以设法令其具有较大差异。一种方法就是改变每个个体学习器的训练数据集，使每个训练集差异较大，但是又不能过大（每个训练集之间都没有交集），这样只用到了很少的训练数据进行训练。</li><li><p>所以可用<strong>自助采样法（bootstrap sampling）</strong>：给定包含m个样本的数据集，每次随机取出一个样本后，又把该样本放回去，使得下次采样同样有可能采到该样本，这样采样m次得到一个同样大小的数据集。使用这样的采样方法，初始数据集中约有63.2%的样本出现在采样集中</p></li><li><p>自助采样法还有一个优点就是：对于每个基学习器，仅使用了约63.2%的样本，剩下的样本正好可作为每个基学习器的验证集</p></li><li>从偏差-方差分解的角度看，<strong>Bagging主要关注降低方差</strong>（即在不同数据集上表现的稳定性）。因此他在不剪枝的决策树、神经网络等易受样本扰动的学习器上效用更为明显</li></ul><h3 id="3-1-算法流程"><a href="#3-1-算法流程" class="headerlink" title="3.1 算法流程"></a>3.1 算法流程</h3><ul><li>算法是采样出T个采样集，然后基于每个采样集训练出一个基学习器（所以可以并行操作）。最后进行简单投票（即每个基学习器使用相同权重），流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221015150202207.png" alt="image-20221015150202207" style="zoom:80%;" /></p><p>Bagging的时间复杂度约等于一个基学习器的时间复杂度，所以他是一个很高效的算法。另外，AdaBoost需进行一些算法的更改才可应用于多分类和回归任务，而Bagging算法可直接应用</p><h3 id="3-2-随机森林"><a href="#3-2-随机森林" class="headerlink" title="3.2 随机森林"></a>3.2 随机森林</h3><ul><li>随机森林（Random Forest，RF）是Bagging的一个扩展变体，其在以决策树为基学习器构建Bagging的基础上，进一步在决策树的训练过程中引入<strong>随机属性选择</strong>。</li><li><p>具体来说，<strong>在每个结点选择一个划分属性时，传统决策树是从所有当前结点中（假设有d个）选择一个最优的，而RF先随机选择k个属性的子集，然后再在该子集中选择一个最优的</strong>。推荐<script type="math/tex">k=\log_2d</script></p></li><li><p>RF使用了非常小的额外计算开销，但却在许多任务中展现出了强大的性能。其不仅像Bagging一样通过<strong>样本扰动</strong>来增加基学习器的多样性，还通过<strong>属性扰动</strong>进一步增加多样性，这就使得最终集成的泛化性能可通过个体学习器之间的差异度的增加而进一步增加</p></li><li>RF的收敛性和Bagging类似，但起始性能相对较差，最终结果更佳：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221018114212479.png" alt="image-20221018114212479" style="zoom:70%;" /></p><h1 id="4-结合策略"><a href="#4-结合策略" class="headerlink" title="4 结合策略"></a>4 结合策略</h1><h3 id="4-1-集成的好处"><a href="#4-1-集成的好处" class="headerlink" title="4.1 集成的好处"></a>4.1 集成的好处</h3><ul><li><strong>统计方面：</strong>因为学习任务的假设空间很大，所以可能有多个假设在训练集上性能一样，使用单学习器可能因为误选导致泛化性能不佳，结合多个学习器则会减少这一风险</li><li><strong>计算方面：</strong>算法可能会陷入局部最小点，而多次运行后结合可降低这种风险</li><li><strong>表示方面：</strong>某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221018115801453.png" alt="image-20221018115801453" style="zoom:70%;" /></p><h3 id="4-2-平均法"><a href="#4-2-平均法" class="headerlink" title="4.2 平均法"></a>4.2 平均法</h3><ul><li><p>针对回归任务</p></li><li><p><strong>简单平均法：</strong></p></li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\frac{1}{T} \sum_{i=1}^{T} h_{i}(\boldsymbol{x})</script><ul><li><strong>加权平均法：</strong></li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\sum_{i=1}^{T} w_{i} h_{i}(\boldsymbol{x})</script><ul><li><p>加权平均法的权重一般是通过训练数据学习而得，现实任务中的训练样本通常不充分或存在噪声，所以<strong>学出的权重不一定可靠</strong>。因此，<strong>加权平均法未必优于简单平均法</strong></p></li><li><p>一般而言，<strong>个体学习器性能相差较大时使用加权平均，性能相近时使用简单平均</strong></p></li></ul><h3 id="4-3-投票法"><a href="#4-3-投票法" class="headerlink" title="4.3 投票法"></a>4.3 投票法</h3><ul><li><p>针对分类任务</p></li><li><p>规定第<script type="math/tex">i</script>个学习器<script type="math/tex">h_i</script>在样本x上的预测输出表示为<script type="math/tex">(h_i^1(x), ..., h_i^N(x))</script>，N为类别个数</p></li><li><strong>绝对多数投票法：</strong></li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=\left\{\begin{array}{ll}c_{j}, & \text { if } \sum_{i=1}^{T} h_{i}^{j}(\boldsymbol{x})>0.5 \sum_{k=1}^{N} \sum_{i=1}^{T} h_{i}^{k}(\boldsymbol{x}) \\\text { reject, } & \text { otherwise }\end{array}\right.</script><p>即某类得到票数过半，才预测为该类，否则拒绝预测</p><ul><li><strong>相对多数投票法：</strong></li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=c_{j}^{\arg \max } \sum_{i=1}^{T} h_{i}^{j}(\boldsymbol{x})</script><ul><li><strong>加权投票法：</strong></li></ul><script type="math/tex; mode=display">H(\boldsymbol{x})=c_{j}^{\arg \max } \sum_{i=1}^{T} w_{i} h_{i}^{j}(\boldsymbol{x}) .</script><ul><li>上面的式子中并没有限制个体学习器输出值的类型，一般为类标记（<script type="math/tex">h_i^j(x) \in \{0,1\}</script>）或类概率（<script type="math/tex">h_i^j(x) \in [0,1]</script>）。不能类型的输出不能混用，一般基于类概率效果往往比类标记更好。<strong>若基学习器的类型不同，其类概率之间不能直接进行比较，需要先转化为类标记</strong></li></ul><h3 id="4-4-学习法"><a href="#4-4-学习法" class="headerlink" title="4.4 学习法"></a>4.4 学习法</h3><ul><li><strong>当训练数据很多时</strong>，一种更为强大的结合策略是学习法，即通过另一个学习器来进行结合。其中Stacking是一种典型代表。把个体学习器称为<strong>初级学习器</strong>，用于结合的学习器称为<strong>次级学习器</strong>或<strong>元学习器</strong></li><li>Stacking算法先从初始数据集中训练出多个初级学习器，然后以此生成一个新的数据集：初级学习器的输出被当作样例输入特征，而初始样本的label仍作为新数据集的label，算法流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221018165945814.png" alt="image-20221018165945814" style="zoom:70%;" /></p><ul><li>但是上述算法流程有个问题：<strong>次级训练集是利用初级学习器产生的，若直接用初级学习器的训练集来产生次级训练集，则过拟合风险较大</strong>，因此一般采用交叉验证或留一法，用初级学习器未使用的样本来产生次级学习器的训练样本</li></ul><blockquote><ul><li>以k折交叉验证法为例，训练集为D，对于每个初级学习器都会有k折（所以一共会迭代<script type="math/tex">T * k</script>次），在第<script type="math/tex">i</script>个学习器的第<script type="math/tex">j</script>折的时候，令<script type="math/tex">D_j</script>和<script type="math/tex">\bar{D}_{j}=D \backslash D_{j}</script>为此时的验证集和训练集，通过<script type="math/tex">\bar{D}_j</script>训练出<script type="math/tex">h_i</script>后，在使用<script type="math/tex">D_j</script>进行验证和生成次级训练集</li></ul></blockquote><ul><li>次级学习器的输入和学习算法有很大的影响，效果比较好的是：<strong>将初级学习器的输出类概率作为输入，再采用多响应线性回归（MLR）作为次级学习算法</strong></li></ul><blockquote><ul><li><strong>MLR：</strong>对每个类分别进行<strong>线性回归</strong>，训练样例要输入进每一个回归模型，若训练样例属于该类，则对应回归的输出label为1，若不属于该类，label则为0。预测时取输出值最大的那个类</li></ul></blockquote><h1 id="5-多样性"><a href="#5-多样性" class="headerlink" title="5 多样性"></a>5 多样性</h1><h3 id="5-1-误差-分歧分解"><a href="#5-1-误差-分歧分解" class="headerlink" title="5.1 误差-分歧分解"></a>5.1 误差-分歧分解</h3><ul><li>以一个回归问题使用加权平均法进行集成为例，对于样例x，定义学习器<script type="math/tex">h_i</script>的<strong>分歧（ambiguity）</strong>为：</li></ul><script type="math/tex; mode=display">A\left(h_{i} \mid \boldsymbol{x}\right)=\left(h_{i}(\boldsymbol{x})-H(\boldsymbol{x})\right)^{2}</script><p>集成的分歧为：</p><script type="math/tex; mode=display">\begin{aligned}\bar{A}(h \mid \boldsymbol{x}) &=\sum_{i=1}^{T} w_{i} A\left(h_{i} \mid \boldsymbol{x}\right) \\&=\sum_{i=1}^{T} w_{i}\left(h_{i}(\boldsymbol{x})-H(\boldsymbol{x})\right)^{2}\end{aligned}</script><p><strong>上式表征了个体学习器之间在样本x上的不一致性，即在一定程度上反映了个体学习器之间的多样性</strong></p><ul><li>个体学习器和集成后的MSE误差为：</li></ul><script type="math/tex; mode=display">\begin{array}{l}E\left(h_{i} \mid \boldsymbol{x}\right)=\left(f(\boldsymbol{x})-h_{i}(\boldsymbol{x})\right)^{2} \\E(H \mid \boldsymbol{x})=(f(\boldsymbol{x})-H(\boldsymbol{x}))^{2}\end{array}</script><p>并且表示出个体学习器误差的加权平均：</p><script type="math/tex; mode=display">\bar{E}(h \mid \boldsymbol{x})=\sum_{i=1}^{T} w_{i} \cdot E\left(h_{i} \mid \boldsymbol{x}\right)</script><ul><li>由上式可得：</li></ul><script type="math/tex; mode=display">\begin{aligned}\bar{A}(h \mid \boldsymbol{x}) &=\sum_{i=1}^{T} w_{i} E\left(h_{i} \mid \boldsymbol{x}\right)-E(H \mid \boldsymbol{x}) \\&=\bar{E}(h \mid \boldsymbol{x})-E(H \mid \boldsymbol{x})\end{aligned}</script><ul><li>上式对于所有x都成立，引入概率密度函数<script type="math/tex">p(x)</script>，则在全样本上可将上式扩展成：</li></ul><script type="math/tex; mode=display">\sum_{i=1}^{T} w_{i} \int A\left(h_{i} \mid \boldsymbol{x}\right) p(\boldsymbol{x}) d \boldsymbol{x}=\sum_{i=1}^{T} w_{i} \int E\left(h_{i} \mid \boldsymbol{x}\right) p(\boldsymbol{x}) d \boldsymbol{x}-\int E(H \mid \boldsymbol{x}) p(\boldsymbol{x}) d \boldsymbol{x} .</script><ul><li>同样，将泛化误差和分歧扩展在全样本上：</li></ul><script type="math/tex; mode=display">\begin{array}{l}E(h_i) = E_{i}=\int E\left(h_{i} \mid \boldsymbol{x}\right) p(\boldsymbol{x}) d \boldsymbol{x} \\A(h_i) = A_{i}=\int A\left(h_{i} \mid \boldsymbol{x}\right) p(\boldsymbol{x}) d \boldsymbol{x} \\E(H) = E=\int E(H \mid \boldsymbol{x}) p(\boldsymbol{x}) d \boldsymbol{x}\end{array}</script><p>再取个学习器的加权误差和加权分歧：</p><script type="math/tex; mode=display">\bar{E}=\sum_{i=1}^{T} w_{i} E_{i} \\\bar{A}=\sum_{i=1}^{T} w_{i} A_{i}</script><ul><li>通过上面这些式子可以得到：</li></ul><script type="math/tex; mode=display">E=\bar{E}-\bar{A}</script><p>这个式子表明：<strong>个体学习器准确率越高、多样性越大，则集成效果越好</strong></p><h3 id="5-2-多样性度量"><a href="#5-2-多样性度量" class="headerlink" title="5.2 多样性度量"></a>5.2 多样性度量</h3><ul><li>简单介绍几个多样性的度量标准，给定数据集<script type="math/tex">D=\left\{\left(\boldsymbol{x}_{1}, y_{1}\right),\left(\boldsymbol{x}_{2}, y_{2}\right), \ldots,\left(\boldsymbol{x}_{m}, y_{m}\right)\right\}</script>，假定为二分类任务，则两个分类器的预测结果列联表为：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221018180852374.png" alt="image-20221018180852374" style="zoom:80%;" /></p><p>该表中，比如c为<script type="math/tex">h_i</script>预测为负类而<script type="math/tex">h_j</script>预测为正类的样本数</p><ul><li><strong>不合度量（disagreement measure）：</strong></li></ul><script type="math/tex; mode=display">d i s_{i j}=\frac{b+c}{m}</script><p>值越大多样性越大</p><ul><li><strong>相关系数（correlation coefficient）：</strong></li></ul><script type="math/tex; mode=display">\rho_{i j}=\frac{a d-b c}{\sqrt{(a+b)(a+c)(c+d)(b+d)}}</script><p>若<script type="math/tex">h_i, h_j</script>无关，则值为0，若正相关则值为正，若负相关则值为负。绝对值越大，相关性越强</p><ul><li><strong>Q-统计量（Q-statistic）：</strong></li></ul><script type="math/tex; mode=display">Q_{i j}=\frac{a d-b c}{a d+b c}</script><p>和<script type="math/tex">\rho_{ij}</script>类似</p><ul><li><strong><script type="math/tex">\kappa</script>-统计量（k-statistic）：</strong></li></ul><script type="math/tex; mode=display">\kappa=\frac{p_{1}-p_{2}}{1-p_{2}}</script><p>其中<script type="math/tex">p_i</script>为两个分类器取得一致的概率，<script type="math/tex">p_2</script>为两个分类器偶然达成一致的概率，可由数据集D直接统计估算：</p><script type="math/tex; mode=display">p_1 = \frac{a+d}{a+b+c+d} \\p_2 = \frac{(a+b)(a+c) + (c+d)(b+d)}{(a+b+c+d)^2}</script><p>若两个分类器在D上完全一致，则<script type="math/tex">\kappa = 1</script>，若只是偶然达成一致，<script type="math/tex">\kappa = 0</script>，<script type="math/tex">\kappa</script>一般非负，尽在两个分类器达成一致的概率甚至低于偶然性的情况下取负值。<script type="math/tex">\kappa</script>越大，多样性越小</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树总结</title>
    <link href="/2022/05/07/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2022/05/07/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><ul><li>一颗决策树包括一个根结点、若干内部结点和若干叶结点，叶结点对应于决策结果，易知：</li></ul><blockquote><ul><li>每个非叶节点表示一个特征属性测试。</li><li>每个分支代表这个特征属性在某个值域上的输出。</li><li>每个叶子节点存放一个类别。</li><li>每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。</li></ul></blockquote><ul><li><p><strong>决策树的构造：</strong>决策树的构造是一个递归的过程，有三种情形会导致递归返回：</p><ol><li>当前结点包含的样本全属于同一类别，这时直接将该节点标记为叶节点，并设为相应的类别</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别</li><li>当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。</li></ol><p>算法的基本流程如下图所示：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/5bc728ecc27fe.png" alt="2.png" style="zoom:80%;" /></p></li></ul><h1 id="2-划分算法"><a href="#2-划分算法" class="headerlink" title="2 划分算法"></a>2 划分算法</h1><ul><li>各种算法的不同之处在于用什么指标来选择属性，来对每个结点划分</li></ul><h3 id="2-1-ID3算法"><a href="#2-1-ID3算法" class="headerlink" title="2.1 ID3算法"></a>2.1 ID3算法</h3><ul><li><strong>信息熵</strong>是度量样本集合程度的最常用的一种指标，设当前样本集合<script type="math/tex">D</script>中第<script type="math/tex">k</script>类样本所占比例为<script type="math/tex">p_k</script>，则<script type="math/tex">D</script>的信息熵定义为：</li></ul><script type="math/tex; mode=display">\operatorname{Ent}(D)=-\sum_{k=1}^{|\mathcal{Y}|} p_{k} \log _{2} p_{k}</script><p> Ent(D)的值越小，D的纯度越高</p><ul><li>假设属性a有V个可能的取值<script type="math/tex">\{a^1, ..., a^V\}</script>，若用a进行划分，则会产生V个分支结点，其中第v个分支包含的数据集为在D中取<script type="math/tex">a = a^v</script>的样本集，记为<script type="math/tex">D^v</script>，则选择使用a进行划分的<strong>信息增益</strong>为： </li></ul><script type="math/tex; mode=display">\operatorname{Gain}(D, a)=\operatorname{Ent}(D)-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Ent}\left(D^{v}\right)</script><p>其中<script type="math/tex">|D^v|/|D|</script>表示给不同的分支赋予权重，即样本数越多的分支结点影响越大。一般而言信息增益越大，代表使用a进行划分获得的“纯度提升”越大。而ID3算法就是选择<script type="math/tex">a_{*}=\underset{a \in A}{\arg \max } \operatorname{Gain}(D, a)</script></p><h3 id="2-2-C4-5算法"><a href="#2-2-C4-5算法" class="headerlink" title="2.2 C4.5算法"></a>2.2 C4.5算法</h3><ul><li><strong>信息增益准则对可取值数目较多的属性有所偏好</strong>，为减少这种偏好可能带来的不好影响，可以改用<strong>增益率</strong>来进行划分。增益率定义如下：</li></ul><script type="math/tex; mode=display">\begin{array}{c}\text { Gain_ratio }(D, a)=\frac{\operatorname{Gain}(D, a)}{\operatorname{IV}(a)} \\\operatorname{IV}(a)=-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \log _{2} \frac{\left|D^{v}\right|}{|D|}\end{array}</script><p>其中IV(a)成为属性a的<strong>固有值</strong>，属性a可能取值越多，则IV(a)越大。</p><ul><li><strong>但是增益率准则对可取值数目较少的属性有所偏好</strong>。所以C4.5算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：<strong>先从候选属性中找出信息增益高于平均水平的属性，在从中选择增益率最高的</strong></li></ul><h3 id="2-3-CART算法"><a href="#2-3-CART算法" class="headerlink" title="2.3 CART算法"></a>2.3 CART算法</h3><ul><li>CART算法采用<strong>基尼指数</strong>来选择划分属性，数据集D的纯度可用<strong>基尼值</strong>来度量：</li></ul><script type="math/tex; mode=display">\begin{aligned}\operatorname{Gini}(D) &=\sum_{k=1}^{|\mathcal{Y}|} \sum_{k^{\prime} \neq k} p_{k} p_{k^{\prime}} \\&=1-\sum_{k=1}^{|\mathcal{Y}|} p_{k}^{2}\end{aligned}</script><p>直观来说，Gini(D)反映了从数据集D中随机抽取两个样本，其标记不一致的概率。因此，Gini(D)越小，则数据集纯度越高</p><ul><li>属性a的基尼指数定义为：</li></ul><script type="math/tex; mode=display">\text { Gini_index }(D, a)=\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Gini}\left(D^{v}\right)</script><p>每次选择基尼指数最小的属性<script type="math/tex">a_{*}=\underset{a \in A}{\arg \min } \text { Gini_index }(D, a)</script></p><h1 id="3-剪枝"><a href="#3-剪枝" class="headerlink" title="3 剪枝"></a>3 剪枝</h1><ul><li><p>剪枝(pruning)是决策树学习算法对付 “过拟合” 的主要手段.。在决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得 “太好”了，以致于把训练集自身 的一些特点当作所有数据都具有的一般性质而导致过拟合。因此, 可通过主动去掉一些分支来降低过拟合的风险</p></li><li><p>剪枝的基本策略有：</p><blockquote><ul><li><p><strong>预剪枝：</strong>指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点</p></li><li><p><strong>后剪枝：</strong>先从训练集生成一棵完成的决策树，然后自底向上地对非叶结点（每个属性）进行考察，若将该结点对应的子树替换成叶结点能带来决策树泛化性能提升，则将该子树替换成叶结点</p></li></ul></blockquote></li><li><p>下面将根据下图（未剪枝的决策树）来讲解预剪枝和后剪枝：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220921212202836.png" alt="未剪枝决策树" style="zoom:67%;" /></p><h3 id="3-1-预剪枝"><a href="#3-1-预剪枝" class="headerlink" title="3.1 预剪枝"></a>3.1 预剪枝</h3><ul><li><strong>预剪枝步骤：</strong><blockquote><ol><li>在生成决策树的时候，最开始是在根节点，基于信息增益准则，选择属性脐部进行划分。</li><li>首先将该结点当成叶结点，然后根据其包含的数据集，决定该结点类别（选择数据集中最多的类别，好瓜or坏瓜），然后用该决策树在验证集上跑，得出准确率<script type="math/tex">acc_i</script>。</li><li>然后选择用脐部进行属性划分，得到三个分支，再分别将这三个分支当作叶结点，并确定每个叶结点的类别，再用该决策树跑一遍验证集，得到准确率<script type="math/tex">acc_j</script></li><li>若<script type="math/tex">acc_i < acc_j</script>则划分，反之不划分（两者相等时，由于“奥卡姆剃刀准则”，是不进行划分的）</li><li>重复上述步骤，直到属性选完</li></ol></blockquote></li></ul><p>预剪枝得到的决策树如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220921214432617.png" alt="预剪枝得到的决策树" style="zoom:73%;" /></p><ul><li>预剪枝不仅降低了过拟合的风险，还减少了训练和测试时间开销。但是由于预剪枝基于“贪心“本质禁止展开这些分支，<strong>所以可能会带来欠拟合的风险</strong>。并且一些分支可能刚展开时泛化性能会下降，但是后续划分会导致泛化性能提升</li></ul><h3 id="3-2-后剪枝"><a href="#3-2-后剪枝" class="headerlink" title="3.2 后剪枝"></a>3.2 后剪枝</h3><ul><li><strong>后剪枝步骤：</strong></li></ul><blockquote><ol><li>剪枝顺序是自底向上，用例子中的图，则是依次考察6、5、2、3、1结点</li><li>每次考察都将该节点替换为叶结点，然后通过对应数据集确定类别，再在验证集上跑，若准确率得到提升或不变，则执行剪枝</li></ol></blockquote><p>后剪枝得到的决策树如下：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220921215744390.png" alt="后剪枝得到的决策树" style="zoom:73%;" /></p><ul><li>一般来说，后剪枝欠拟合的风险很小，泛化性能往往优于预剪枝。但是要自底向上对所有非叶结点进行考察，所以训练开销要大得多</li></ul><h1 id="4-连续值处理"><a href="#4-连续值处理" class="headerlink" title="4 连续值处理"></a>4 连续值处理</h1><ul><li>在对连续值处理时，可采用<strong>连续属性离散化技术</strong>，最简单的策略是采用<strong>二分法</strong>，C4.5决策树算法正使用了这种机制</li><li>给定数据集D和连续属性a，将a在D上的取值从小到大排列<script type="math/tex">{a^1, ..., a^n}</script>。基于划分点t可将数据集D分为<script type="math/tex">D^+_t</script>和<script type="math/tex">D^-_t</script>，分别代表在属性a上大于t和不大于t的样本。显然对相邻的取值<script type="math/tex">a^i</script>和<script type="math/tex">a^{i+1}</script>，选择<script type="math/tex">t \in [a^i, a^{i+1})</script>的划分结果都是相同的，所以可以考察n-1个候选划分点：</li></ul><script type="math/tex; mode=display">T_{a}=\left\{\frac{a^{i}+a^{i+1}}{2} \mid 1 \leqslant i \leqslant n-1\right\}</script><p>即把<script type="math/tex">[a^i, a^{i+1})</script>的中位点作为候选划分点，然后就可以像离散值一样处理，比如计算信息增益：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{Gain}(D, a) &=\max _{t \in T_{a}} \operatorname{Gain}(D, a, t) \\&=\max _{t \in T_{a}} \operatorname{Ent}(D)-\sum_{\lambda \in\{-,+\}} \frac{\left|D_{t}^{\lambda}\right|}{|D|} \operatorname{Ent}\left(D_{t}^{\lambda}\right)\end{aligned}</script><ul><li>在选择划分点的时候，可以不使用中位点，而是将中位点换成在训练集中出现过的不大于中位点的最大值，从而使得最终决策树使用的划分点在训练集中出现过</li></ul><h1 id="5-缺失值处理"><a href="#5-缺失值处理" class="headerlink" title="5 缺失值处理"></a>5 缺失值处理</h1><ul><li>当存在属性值缺失的时候，有两个问题需要解决：(1).如何在属性值缺失的情况下进行划分属性的选择；(2).给定划分属性，若样本在该属性值上缺失，则如何划分该样本</li><li>给定数据集D和属性a，<script type="math/tex">\tilde{D}</script>表示属性a的值不缺失的样本子集，<script type="math/tex">\tilde{D}^v</script>表示<script type="math/tex">\tilde{D}</script>的a属性取值为<script type="math/tex">a^v</script>的样本子集，<script type="math/tex">\tilde{D}_k</script>表示<script type="math/tex">\tilde{D}</script>的类别为k的子集。我们可以为每个样本赋予一个权重<script type="math/tex">w_x</script><strong>（训练开始时将根节点所有样本权重初始化为1）</strong>，并定义：</li></ul><script type="math/tex; mode=display">\rho=\frac{\sum_{\boldsymbol{x} \in \tilde{D}}{ }^{w_{\boldsymbol{x}}}}{\sum_{\boldsymbol{x} \in D} w_{\boldsymbol{x}}}</script><script type="math/tex; mode=display">\tilde{p}_{k}=\frac{\sum_{\boldsymbol{x} \in \tilde{D}_{k}} w_{\boldsymbol{x}}}{\sum_{\boldsymbol{x} \in \tilde{D}} w_{\boldsymbol{x}}} \quad(1 \leqslant k \leqslant|\mathcal{Y}|)</script><script type="math/tex; mode=display">\tilde{r}_{v}=\frac{\sum_{\boldsymbol{x} \in \tilde{D}^{v}} w_{\boldsymbol{x}}}{\sum_{\boldsymbol{x} \in \tilde{D}} w_{\boldsymbol{x}}} \quad(1 \leqslant v \leqslant V)</script><p>直观地看，对于属性a，<script type="math/tex">\rho</script>表示五确实样本所占比例，<script type="math/tex">\tilde{p}_k</script>表示无缺失样本中第k类样本所占比例，<script type="math/tex">\tilde{r}_v</script>表示无缺失样本中在属性a上取值<script type="math/tex">a^v</script>的样本所占比例</p><ul><li>基于上述定义，可将信息增益的公式推广为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\operatorname{Gain}(D, a) &=\rho \times \operatorname{Gain}(\tilde{D}, a) \\&=\rho \times\left(\operatorname{Ent}(\tilde{D})-\sum_{v=1}^{V} \tilde{r}_{v} \operatorname{Ent}\left(\tilde{D}^{v}\right)\right) \\& \operatorname{Ent}(\tilde{D})=-\sum_{k=1}^{|\mathcal{Y}|} \tilde{p}_{k} \log _{2} \tilde{p}_{k}\end{aligned}</script><ul><li><strong>若样本<script type="math/tex">x</script>在a上的取值已知，则正常划入子结点，样本权值仍然保持为<script type="math/tex">w_x</script>；若在a上的取值未知，则将该样本划入所有子结点，样本权值在每个分支上分别调整为<script type="math/tex">\tilde{r}_{v} \cdot w_{\boldsymbol{x}}</script></strong></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>贝叶斯分类器</title>
    <link href="/2022/04/26/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <url>/2022/04/26/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-贝叶斯决策论"><a href="#1-贝叶斯决策论" class="headerlink" title="1 贝叶斯决策论"></a>1 贝叶斯决策论</h1><ul><li>假设有N个可能的类别<script type="math/tex">\mathcal{Y} = \{c_1, ..., c_N\}</script>，$\lambda_{ij}$是将一个$c_i$类样本误分类为$c_j$类的损失，则在样本x上的条件风险为：</li></ul><script type="math/tex; mode=display">R\left(c_{i} \mid \boldsymbol{x}\right)=\sum_{j=1}^{N} \lambda_{i j} P\left(c_{j} \mid \boldsymbol{x}\right)</script><ul><li>我们的任务是寻找一个判定准则<script type="math/tex">h: \mathcal{X} \mapsto \mathcal{Y}</script>以最小化总体风险：</li></ul><script type="math/tex; mode=display">R(h)=\mathbb{E}_{\boldsymbol{x}}[R(h(\boldsymbol{x}) \mid \boldsymbol{x})]</script><ul><li>显然，对每个样本x，若能最小化条件风险<script type="math/tex">R(h(x) | x)</script>，则总体风险$R(h)$也被最小化。这就产生了<strong>贝叶斯判定准则（Bayes decision rule）</strong>：为最小化总体风险，只需在每个样本上选择那个能使条件风险最小的类别标记，即：</li></ul><script type="math/tex; mode=display">h^{*}(\boldsymbol{x})=\underset{c \in \mathcal{Y}}{\arg \min } R(c \mid \boldsymbol{x})</script><p><strong>此时，$h^*$称为贝叶斯最优分类器</strong></p><ul><li>具体来说，若目标是最小化分类错误率，则误判损失可以写为0/1损失：</li></ul><script type="math/tex; mode=display">\lambda_{ij}  = \begin{cases}0, if \quad i = j \\1, otherwise\end {cases}</script><ul><li>则此时条件风险为：</li></ul><script type="math/tex; mode=display">R(c|x) = 1 - P(c|x)</script><ul><li>所以贝叶斯最优分类器为：</li></ul><script type="math/tex; mode=display">h^*(x) = arg\ max_{c \in \mathcal{Y}}P(c|x)</script><p><strong>即对每个样本x，选择能使后验概率$P(c|x)$最大的类别标记</strong></p><ul><li>所以首先要获得后验概率，然而这在现实任务中难以直接获得，所以机器学习的任务是<strong>基于有限的训练样本集尽可能准确地估计出后验概率</strong>，大体有两种策略：</li></ul><blockquote><ul><li><strong>判别式模型（discriminative models）：</strong>直接建模后验概率$P(c|x)$来预测c，决策树、SVM、神经网络等都是判别式模型</li><li><strong>生成式模型（generative models）：</strong>先对联合概率分布$P(x, c)$建模，再由此得到后验概率$P(c|x)$</li></ul></blockquote><ul><li>对于生成式模型，必然考虑贝叶斯定理：</li></ul><script type="math/tex; mode=display">P(c|x) = \frac{P(x, c)}{P(x)} \\ = \frac{P(c)P(x|c)}{P(x)}</script><p>其中，$P(c)$是先验概率，$P(x|c)$是似然，$P(x)$是用于归一化的证据因子，与类标记无关，所以建模的时候都是把分母$P(x)$直接去掉。所以现在，<strong>估计后验概率$P(c|x)$的任务就会转化为如何基于训练集D来估计先验概率$P(c)$和似然$P(x|c)$ </strong>。在训练集足够大的时候可以直接用样本频率代替$P(c)$。而$P(x|c)$显然是无法通过频率估计的（不同属性的组合结果太多）</p><blockquote><p>基于有限训练样本直接估计联合概率，在计算上将会遭遇组合爆炸问题，在数据上将会遭遇样本稀疏问题。属性数越多，问题越严重</p></blockquote><h1 id="2-极大似然估计"><a href="#2-极大似然估计" class="headerlink" title="2 极大似然估计"></a>2 极大似然估计</h1><ul><li><p>求解$P(x|c)$的一个方法就是使用极大似然估计（MLE），这需要先假定其<strong>具有一种确定的概率分布形式</strong>，再基于训练样本对概率分布的参数进行估计</p></li><li><p>具体来说，记关于类别c的似然为$P(x|c)$，假设$P(x|c)$具有确定的形式并且被参数向量$\theta_c$唯一确定，我们的任务就是通过训练集估计参数$\theta_c$，为明确起见，将$P(x|c)$记为$P(x|\theta_c)$。令$D_c$为数据集D中第c类样本的集合，假设这些样本独立同分布，则参数$\theta_c$关于$D_c$的似然是：</p></li></ul><script type="math/tex; mode=display">P(D_c|\theta_c) = \prod_{x \in D_c}P(x|\theta_c)</script><ul><li>然后再对上式取负对数得到$LL(\theta_c)$，最后得到极大估计值<script type="math/tex">\hat{\theta_c}</script>：</li></ul><script type="math/tex; mode=display">\hat{\boldsymbol{\theta}}_{c}=\underset{\boldsymbol{\theta}_{c}}{\arg \max } L L\left(\boldsymbol{\theta}_{c}\right)</script><h1 id="3-朴素贝叶斯分类器"><a href="#3-朴素贝叶斯分类器" class="headerlink" title="3 朴素贝叶斯分类器"></a>3 朴素贝叶斯分类器</h1><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><ul><li><p>上面已经说过最大的困难在于$P(x|c)$难以从有限的样本中估计而得。而朴素贝叶斯采用了<strong>属性条件独立性假设：对已知类别，假设所有属性相互独立</strong></p></li><li><p>则生成式模型的目标可以重写为：</p></li></ul><script type="math/tex; mode=display">P(c \mid \boldsymbol{x})=\frac{P(c) P(\boldsymbol{x} \mid c)}{P(\boldsymbol{x})}=\frac{P(c)}{P(\boldsymbol{x})} \prod_{i=1}^{d} P\left(x_{i} \mid c\right)</script><p>其中d为属性个数，$x_i$为样本$x$在第$i$个属性上的取值</p><ul><li>所以朴素贝叶斯分类器的表达式为：</li></ul><script type="math/tex; mode=display">h_{n b}(\boldsymbol{x})=\underset{c \in \mathcal{Y}}{\arg \max } P(c) \prod_{i=1}^{d} P\left(x_{i} \mid c\right)</script><ul><li>上式的概率都可以通过统计频率获得：</li></ul><script type="math/tex; mode=display">P(c) = \frac{|D_c|}{|D|} \\ P(x_i|c) = \frac{|D_{c, x_i}|}{|D_c|}</script><p>其中<script type="math/tex">D_c</script>为类别为c的样本集，<script type="math/tex">D_{c, x_i}</script>为类别为c并在第<script type="math/tex">i</script>个属性上取值<script type="math/tex">x_i</script>的样本集。若是对于连续属性可考虑概率密度函数，比如<script type="math/tex">p\left(x_{i} \mid c\right) \sim \mathcal{N}\left(\mu_{c, i}, \sigma_{c, i}^{2}\right)</script>，<script type="math/tex">\mu_{c, i}</script>和<script type="math/tex">\sigma^2_{c, i}</script>分别是第c类样本在第<script type="math/tex">i</script>个属性上取值的均值和方差</p><h3 id="3-2-引入先验分布"><a href="#3-2-引入先验分布" class="headerlink" title="3.2 引入先验分布"></a>3.2 引入先验分布</h3><ul><li>在上面计算概率时，若某个属性值在训练集中没有与某个类同时出现过，则会导致0乘，频率估计将会出现问题。所以要进行平滑处理，常用<strong>拉普拉斯修正（Laplacian correction）</strong></li><li>具体来说，令N表示可能的类别数，$N_i$表示第$i$个属性可能的取值数，则上面的概率计算式可以修正为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\hat{P}(c) &=\frac{\left|D_{c}\right|+1}{|D|+N} \\\hat{P}\left(x_{i} \mid c\right) &=\frac{\left|D_{c, x_{i}}\right|+1}{\left|D_{c}\right|+N_{i}}\end{aligned}</script><ul><li>显然，拉普拉斯是<strong>引入了一个均匀分布的先验分布</strong>，避免了上述的0乘问题，并且在训练集变大时，修正过程索隐入的先验分布的影响也会逐渐变得可忽略，使得估值逐渐趋于实际概率值</li></ul><h1 id="4-半朴素贝叶斯分类器"><a href="#4-半朴素贝叶斯分类器" class="headerlink" title="4 半朴素贝叶斯分类器"></a>4 半朴素贝叶斯分类器</h1><ul><li>朴素贝叶斯是采用了属性条件独立性假设，但是在现实任务中往往很难成立，于是尝试对这种假设进行一定的放松，由此产生了半朴素贝叶斯分类器。<strong>基本思想是适当考虑一部分属性间的相互依赖信息，从而既不需进行完全联合概率计算，又不至于彻底忽略了比较强的属性依赖关系</strong></li><li><strong>独依赖估计（One-Dependent Estimator, OED）</strong>是半朴素贝叶斯分类器最常用的一种策略，就是<strong>假设每个属性在类别之外最多仅依赖一个其他属性</strong>，即：</li></ul><script type="math/tex; mode=display">P(c \mid \boldsymbol{x}) \propto P(c) \prod_{i=1}^{d} P\left(x_{i} \mid c, p a_{i}\right)</script><p>其中$pa_i$为$x_i$的父属性，若$pa_i$已知，则可以通过前面的方法计算<script type="math/tex">P(x_i|c, pa_i)</script>，所以问题就转化为如何确定每个属性的父属性</p><h3 id="4-1-SPODE"><a href="#4-1-SPODE" class="headerlink" title="4.1 SPODE"></a>4.1 SPODE</h3><ul><li>SPODE（Super-Parent ODE）方法是<strong>假设所有属性都依赖于同一个属性，成为超父，然后通过交叉验证等模型选择方法来确定超父属性</strong></li></ul><h3 id="4-2-TAN"><a href="#4-2-TAN" class="headerlink" title="4.2 TAN"></a>4.2 TAN</h3><ul><li>TAN（Tree Augmented naive Bayes）是在最大带权生成树的基础上构建的依赖关系，具体步骤如下：</li></ul><blockquote><ol><li>计算任意两个属性之间的条件互信息（conditional mutual information）：</li></ol><script type="math/tex; mode=display">I\left(x_{i}, x_{j} \mid y\right)=\sum_{x_{i}, x_{j} ; c \in \mathcal{Y}} P\left(x_{i}, x_{j} \mid c\right) \log \frac{P\left(x_{i}, x_{j} \mid c\right)}{P\left(x_{i} \mid c\right) P\left(x_{j} \mid c\right)}</script><ol><li>以属性作为结点构建完全图，每两个节点之间边的权重为<script type="math/tex">I(x_i, x_j|y)</script></li><li>构建此完全图的最大带权生成树，挑选根节点，并将边置为有向</li><li>加入类别结点y，增加y到每个属性的有向边</li></ol></blockquote><ul><li>以下是朴素贝叶斯（NB）和两种ODE的对比：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220926174528428.png" alt="image-20220926174528428" style="zoom:80%;" /></p><h3 id="4-3-AODE"><a href="#4-3-AODE" class="headerlink" title="4.3 AODE"></a>4.3 AODE</h3><ul><li>AODE（Averaged One-Dependent Estimator）是一种基于集成学习的ODE，与SPODE通过模型选择确定超父属性不同，<strong>AODE尝试将每个属性作为超父来构建SPODE，然后将那些具有足够训练数据支撑的SPODE集成起来作为最终结果</strong>，即：</li></ul><script type="math/tex; mode=display">P(c \mid \boldsymbol{x}) \propto \sum_{\substack{i=1 \\\left|D_{x_{i}}\right| \geqslant m^{\prime}}}^{d} P\left(c, x_{i}\right) \prod_{j=1}^{d} P\left(x_{j} \mid c, x_{i}\right)</script><p>其中<script type="math/tex">D_{x_i}</script>是在第$i$个属性上取值为$x_i$的样本集合，$m^{\prime}$为阈值（默认为30）</p><ul><li>概率统计公式如下：</li></ul><script type="math/tex; mode=display">\begin{aligned}\hat{P}\left(c, x_{i}\right) &=\frac{\left|D_{c, x_{i}}\right|+1}{|D|+ N \times N_{i}} \\\hat{P}\left(x_{j} \mid c, x_{i}\right) &=\frac{\left|D_{c, x_{i}, x_{j}}\right|+1}{\left|D_{c, x_{i}}\right|+N_{j}}\end{aligned}</script><ul><li>注意：SPODE是假设类别和超父属性相互独立，所以连乘项前面是乘$P(c)$；而AODE则没有假设两者独立，所以连乘项前是乘$P(c|x_i)$</li></ul><h1 id="5-贝叶斯网"><a href="#5-贝叶斯网" class="headerlink" title="5 贝叶斯网"></a>5 贝叶斯网</h1><ul><li><p>贝叶斯网亦称信念网，借助有向无环图（DAG）来刻画属性之间的依赖关系，并使用条件概率表（CPT）来描述属性间的联合概率分布</p></li><li><p>具体来说，一个贝叶斯网B由结构G和参数<script type="math/tex">\Theta</script>构成，即<script type="math/tex">B = <G, \Theta></script>。G是一个有向无环图，每个节点对应一个属性，若两个属性有直接依赖关系，则由一条边连接起来。<script type="math/tex">\Theta</script>定量描述这种依赖关系，假设属性<script type="math/tex">x_i</script>的父节点集为<script type="math/tex">\pi_i</script>，则<script type="math/tex">\Theta</script>包含了每个属性的条件概率表<script type="math/tex">\theta_{x_i|\pi_i} = P_B(x_i|\pi_i)</script>。如下图：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220927112128167.png" alt="image-20220927112128167"  /></p><h3 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h3><ul><li>贝叶斯网有效的表达了属性间的条件独立性，<strong>给定父节点集，贝叶斯网假设每个属性与他的非后裔属性独立</strong>，那么属性<script type="math/tex">x_1, ...,x_d</script>的联合概率分布为：</li></ul><script type="math/tex; mode=display">P_{B}\left(x_{1}, x_{2}, \ldots, x_{d}\right)=\prod_{i=1}^{d} P_{B}\left(x_{i} \mid \pi_{i}\right)=\prod_{i=1}^{d} \theta_{x_{i} \mid \pi_{i}}</script><ul><li>贝叶斯网中有3种典型的依赖关系：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220927161634626.png" alt="image-20220927161634626"></p><p>1、同父结构中，给定父节点$x_1$的值，则$x_3$和$x_4$条件独立</p><blockquote><p><strong>证明：</strong></p><script type="math/tex; mode=display">P(x_1, x_3, x_4) = P(x_1)P(x_3|x_1)P(x_4|x_1) \\P(x_3, x_4| x_1) = P(x_1, x_3, x_4) / P(x_1)</script><p>联立上述两式：</p><script type="math/tex; mode=display">P(x_3, x_4| x_1) = P(x_3|x_1)P(x_4|x_1)</script></blockquote><p>2、顺序结构中，给定x的值，则y和z条件独立</p><blockquote><p><strong>证明：</strong></p><script type="math/tex; mode=display">P(x, y, z) = P(z)P(x|z)P(y|x) = P(x)P(z|x)P(y|x) \\P(z, y | x) = P(x, y, z) / P(x)</script><p>联立上述两式：</p><script type="math/tex; mode=display">P(z, y | x) = P(z|x)P(y|x)</script></blockquote><p>3、V型结构中，给定$x_4$的取值，则$x_1$和$x_2$必不独立；但是若$x_4$取值完全未知，则$x_1$和$x_2$却是相互独立的（<strong>边际独立性</strong>）</p><blockquote><p><strong>证明：</strong></p><script type="math/tex; mode=display">P(x_1, x_2) = \sum_{x_4}P(x_1, x_2, x_4) = \sum_{x_4}P(x_1)P(x_2)P(x_4|x_1, x_2) = P(x_1)P(x_2)</script></blockquote><h3 id="5-2-有向分离"><a href="#5-2-有向分离" class="headerlink" title="5.2 有向分离"></a>5.2 有向分离</h3><ul><li>可以使用<strong>有向分离（D-separation）</strong>分析有向图中变量间的条件独立性</li><li>首先要把有向图转化为无向图，由此产生的无向图称为道德图：</li></ul><blockquote><ol><li>找出有向图中的所有V型结构，在V型结构的两个父节点之间加上一条无向边</li><li>然后将所有有向边改为无向边</li></ol></blockquote><ul><li>基于道德图能直观迅速地找到变量间地条件独立性。假定道德图中有变量$x,y$和变量集合<script type="math/tex">z = \{z_i\}</script>。若变量x和y能在图上被z分开，即从道德图中将变量集合z去除后，x和y分属两个连通分支，则称x和y被有向分离，<script type="math/tex">x \perp y | z</script>成立</li></ul><h3 id="5-3-学习"><a href="#5-3-学习" class="headerlink" title="5.3 学习"></a>5.3 学习</h3><ul><li><p>贝叶斯网学习的首要任务是根据训练数据来找出结构最恰当的贝叶斯网。<strong>评分搜索</strong>是求解的常用方法，具体来说，先定义一个评分函数，以此来评估贝叶斯网与训练数据的契合程度，然后基于这个评分函数来寻找结构最优的贝叶斯网</p></li><li><p>常用评分函数通常基于信息论准则，此类准则将学习问题看作一个数据压缩任务，学习的目标是找到一个能以最短编码长度描述训练数据的模型，此时<strong>编码的长度包括了描述模型自身所需的字节长度和使用该模型描述数据所需的字节长度</strong>。对贝叶斯网学习而言,模型就是一个贝叶斯网</p></li><li>每个贝叶斯网描述了一个在训练数据上的概率分布，<strong>自有一套编码机制能使那些经常出现的样本有更短的编码</strong>。于是应<strong>选择那个综合编码长度(包括描述网络和编码数据)最短的贝叶斯网</strong>，这就是<strong>最小描述长度(Minimal Description Length,MDL)准则</strong></li><li>若给定训练集<script type="math/tex">D = \{x_1, ..., x_m\}</script>（每个样本向量中是包含了类别的），则贝叶斯网<script type="math/tex">B = <G, \Theta></script>在D上的评分函数可以写为：</li></ul><script type="math/tex; mode=display">s(B \mid D)=f(\theta)|B|-L L(B \mid D)</script><p>其中|B|是贝叶斯网络的参数个数，$f(\theta)$表示描述每个参数$\theta$所需的编码位数；而第二项<script type="math/tex">L L(B \mid D)=\sum_{i=1}^{m} \log P_{B}\left(x_{i}\right)</script>是贝叶斯网B的对数似然。<strong>显然第一项是计算编码贝叶斯网B所需的编码位数，第二项是计算B所对应的概率分布$P_B$对D描述的有多好</strong></p><blockquote><ul><li>若$f(\theta)=1$，则得到AIC评分函数：</li></ul><script type="math/tex; mode=display">\operatorname{AIC}(B \mid D)=|B|-L L(B \mid D)</script><ul><li>若$f(\theta) = \frac{1}{2}\log m$，则得到BIC评分函数：</li></ul><script type="math/tex; mode=display">\operatorname{BIC}(B \mid D)=\frac{\log m}{2}|B|-L L(B \mid D)</script></blockquote><ul><li>若贝叶斯网B的网络结构G固定，则评分函数第一项为常数，那么最小化$s(B|D)$等价于对参数$\Theta$的极大似然估计，而此时每个参数<script type="math/tex">\theta_{x_i|\pi_i}</script>可以直接从D中通过频率统计获得。<strong>所以，要最小化评分函数，只需对网络每种结构进行搜索，而候选结构的最优参数可直接在训练数据D上计算得到</strong></li></ul><blockquote><p>但是搜索所有可能的结构是一个NP难问题。但是可以采用一些策略求得近似解，比如：</p><ol><li>贪心法，从某个网络结构出发，每次调整一条边（增加、删除、调整方向），直到评分函数不再降低</li><li>添加约束，比如将网络结构限定为树形结构（比如TAN）</li></ol></blockquote><h3 id="5-4-推断"><a href="#5-4-推断" class="headerlink" title="5.4 推断"></a>5.4 推断</h3><ul><li><p>贝叶斯网训练好之后就能用来回答“查询”（query），即通过一些属性变量的观测值来推测其他属性变量的取值（类别也算作一个变量）。例如在西瓜问题中，若我们观测到西瓜色泽青绿、敲声浊响、根蒂蜷缩，想知道它是否成熟、甜度如何。<strong>这样通过已知变量观测值来推测待查询变量的过程称为“推断”（inference），已知变量观测值称为“证据”（evidence）</strong></p></li><li><p>理想情况下是直接通过贝叶斯网定义的联合概率分布来计算后验概率，但是在节点多、连接稠密时，难以进行这样的精确推断，这时需借助<strong>近似推断</strong>，尝试用<strong>吉布斯采样（Gibbs sampling）</strong></p></li><li><p>具体来说，<script type="math/tex">Q = \{Q_1, ..., Q_n\}</script>表示带查询变量，<script type="math/tex">E = \{E_1, ..., E_k\}</script>表示证据变量，其取值为<script type="math/tex">e = \{e_1, ..., e_k\}</script>。我们的任务是计算后验概率<script type="math/tex">P(Q=q|E=e)</script>，其中<script type="math/tex">q = \{q_1, ..., q_n\}</script>代表查询变量的一组取值</p></li><li><p>吉布斯采样步骤如下：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220927213559671.png" alt="image-20220927213559671" style="zoom:80%;" /></p><blockquote><p>一开始先产生一个与证据$E = e$一致的样本$q^0$作为初始点，然后经过T次迭代，每次迭代都对非证据变量（即Z）逐个采样，然后由贝叶斯的概率分布推断其取值。若经过T次采样得到的与q一致的样本共有$n_q$个，则可近似估算出后验概率：</p><script type="math/tex; mode=display">P(\mathbf{Q}=\mathbf{q} \mid \mathbf{E}=\mathbf{e}) \simeq \frac{n_{q}}{T}</script></blockquote><h1 id="6-EM算法"><a href="#6-EM算法" class="headerlink" title="6 EM算法"></a>6 EM算法</h1><ul><li>上面的讨论中，都是认定训练样本是完整的，但是现实应用中往往有的属性值未知，这些未观测变量称为<strong>隐变量（latent variable）</strong>，在这种存在隐变量的情况下进行参数估计，可使用EM算法</li></ul><h3 id="6-1-基本思想"><a href="#6-1-基本思想" class="headerlink" title="6.1 基本思想"></a>6.1 基本思想</h3><ul><li>EM 算法的核心思想非常简单，分为两步：Expectation-Step 和 Maximization-Step。E-Step 主要通过观察数据和现有模型来估计参数，然后用这个估计的参数值来计算似然函数的期望值；而 M-Step 是寻找似然函数最大化时对应的参数。由于算法会保证在每次迭代之后似然函数都会增加，所以函数最终会收敛</li><li>于是以随机初始值$\Theta^0$为起点，执行以下步骤直至收敛：</li></ul><blockquote><ol><li>基于$\Theta^t$推断隐变量Z的期望，记为$Z^t$</li><li>基于已观测变量X和$Z^t$对参数$\Theta$做最大似然估计，记为<script type="math/tex">\Theta^{t+1}</script></li></ol></blockquote><h3 id="6-2-举个栗子"><a href="#6-2-举个栗子" class="headerlink" title="6.2 举个栗子"></a>6.2 举个栗子</h3><ul><li>有两枚硬币A、B，随机抛掷结果如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-4e19d89b47e21cf284644b0576e9af0f_720w.jpg" alt="img" style="zoom:80%;" /></p><p>很容易估计出两枚硬币抛掷正面的概率：</p><script type="math/tex; mode=display">\begin{array}{l}\theta_{A}=24 / 30=0.8 \\\theta_{B}=9 / 20=0.45\end{array}</script><ul><li>现在加入隐变量，抹去每次投掷的硬币标记，即不知道这次投的是A还是B：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-caa896173185a8f527c037c122122258_720w.jpg" alt="img" style="zoom:80%;" /></p><p>这种情况又如何估计$\theta_A, \theta_B$呢。我们多出了一个隐变量<script type="math/tex">Z = \{z_1, ..., z_5\}</script>，代表每次投掷的硬币类型。我们需要Z才能估计参数$\theta_A, \theta_B$，而又需要$\theta_A, \theta_B$才能估计Z。其解决方法就是先随机初始化$\theta_A, \theta_B$ ，然后用去估计 Z， 然后基于 Z 按照最大似然概率去估计新的$\theta_A, \theta_B$，循环至收敛。</p><ul><li>现在随机初始化<script type="math/tex">\theta_A = 0.6, \theta_B = 0.5</script>，以第一轮投掷来说，硬币A投出5H5T结果的概率是<script type="math/tex">C_{10}^5 0.6^5 * 0.4^5</script>，而B投出5H5T的概率为<script type="math/tex">C_{10}^5 0.5^5 * 0.5^5</script>，由此可以算出本次使用A或B硬币的概率：</li></ul><script type="math/tex; mode=display">\begin{array}{l}P_{A}=\frac{0.6^{5} * 0.4^{5}}{\left(0.6^{5} * 0.4^{5}\right)+\left(0.5^{5} * 0.5^{5}\right)}=0.45 \\P_{B}=\frac{0.5^{5} * 0.5^{5}}{\left(0.6^{5} * 0.4^{5}\right)+\left(0.5^{5} * 0.5^{5}\right)}=0.55\end{array}</script><p>对其他轮进行同样的操作，得到：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-b325de65a5bcac196fc0939f346410d7_720w.jpg" alt="img" style="zoom:80%;" /></p><p><strong>这一步我们实际上是估计出了 Z 的概率分布，这部就是 E-Step</strong></p><ul><li>结合硬币 A 的概率和上一张投掷结果，我们利用期望可以求出硬币 A 和硬币 B 的贡献。以第二轮硬币 A 为例子，计算方式为：</li></ul><script type="math/tex; mode=display">\begin{array}{l}H: 0.80 * 9=7.2 \\T: 0.80 * 1=0.8\end{array}</script><p>对其他轮和硬币B进行同样的操作，得到：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-9b6e8c50c0761c6ac19909c26e0a71d4_720w.jpg" alt="img" style="zoom:80%;" /></p><ul><li>然后用极大似然估计来估计新的$\theta_A, \theta_B$：</li></ul><script type="math/tex; mode=display">\begin{aligned}\theta_{A} &=\frac{21.3}{21.3+8.6}=0.71 \\\theta_{B} &=\frac{11.7}{11.7+8.4}=0.58\end{aligned}</script><p><strong>这步就对应了 M-Step，重新估计出了参数值。</strong></p><ul><li>如此反复迭代，我们就可以算出最终的参数值。</li></ul><h3 id="6-3-算法流程"><a href="#6-3-算法流程" class="headerlink" title="6.3 算法流程"></a>6.3 算法流程</h3><ul><li>给定观测变量Y、隐变量Z，模型参数为<script type="math/tex">\theta</script></li></ul><blockquote><ol><li>首先选定参数的初始值<script type="math/tex">\theta^{(0)}</script>，开始迭代</li><li>E步：在第<script type="math/tex">i+1</script>次迭代时，已知<script type="math/tex">\theta^{(i)}</script>，计算：</li></ol><script type="math/tex; mode=display">\begin{aligned}Q\left(\theta, \theta^{(i)}\right) &=E_{Z}\left[\log P(Y, Z \mid \theta) \mid Y, \theta^{(i)}\right] \\&=\sum_{Z} \log P(Y, Z \mid \theta) P\left(Z \mid Y, \theta^{(i)}\right)\end{aligned}</script><ol><li>M步：求得使<script type="math/tex">Q(\theta, \theta^{(i)})</script>最大化的<script type="math/tex">\theta</script>，作为<script type="math/tex">\theta^{(i+1)}</script>：</li></ol><script type="math/tex; mode=display">\theta^{(i+1)}=\arg \max _{\theta} Q\left(\theta, \theta^{(i)}\right)</script><ol><li>重复上述的E步和M步，直至收敛</li></ol></blockquote><ul><li><strong>注意：</strong>初始值是可以随机选择的，但是<strong>EM算法对初值敏感</strong>，EM有可能收敛到局部最优点</li></ul><h3 id="6-4-算法推导"><a href="#6-4-算法推导" class="headerlink" title="6.4 算法推导"></a>6.4 算法推导</h3><ul><li>面对一个含隐变量的概率模型，目标是最大化：</li></ul><script type="math/tex; mode=display">\begin{aligned}L(\theta) &=\log P(Y \mid \theta)=\log \sum_{Z} P(Y, Z \mid \theta) \\&=\log \left(\sum_{Z} P(Y \mid Z, \theta) P(Z \mid \theta)\right)\end{aligned}</script><ul><li>在第<script type="math/tex">i+1</script>次迭代时，我们是希望有所提升，即得到的<script type="math/tex">\theta</script>的似然<script type="math/tex">L(\theta)</script>要大于当前的似然<script type="math/tex">L(\theta^{(i)})</script>，所以将两者相减：</li></ul><script type="math/tex; mode=display">\begin{aligned}L(\theta)-L\left(\theta^{(i)}\right) &= \log \left(\sum_{Z} P(Y \mid Z, \theta) P(Z \mid \theta)\right)-\log P\left(Y \mid \theta^{(i)}\right)\\& =\log \left(\sum_{Z} P\left(Y \mid Z, \theta^{(i)}\right) \frac{P(Y \mid Z, \theta) P(Z \mid \theta)}{P\left(Y \mid Z, \theta^{(i)}\right)}\right)-\log P\left(Y \mid \theta^{(i)}\right) \\& \geqslant \sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log \frac{P(Y \mid Z, \theta) P(Z \mid \theta)}{P\left(Z \mid Y, \theta^{(i)}\right)}-\log P\left(Y \mid \theta^{(i)}\right) \\&=\sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log \frac{P(Y \mid Z, \theta) P(Z \mid \theta)}{P\left(Z \mid Y, \theta^{(i)}\right) P\left(Y \mid \theta^{(i)}\right)}\end{aligned}</script><p>上述放缩用到了<strong>Jensen不等式</strong></p><ul><li>令：</li></ul><script type="math/tex; mode=display">B\left(\theta, \theta^{(i)}\right) \hat{=} L\left(\theta^{(i)}\right)+\sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log \frac{P(Y \mid Z, \theta) P(Z \mid \theta)}{P\left(Z \mid Y, \theta^{(i)}\right) P\left(Y \mid \theta^{(i)}\right)}</script><p>那么：</p><script type="math/tex; mode=display">L(\theta) \geqslant B\left(\theta, \theta^{(i)}\right)</script><p>即<script type="math/tex">B(\theta, \theta^{(i)})</script>为<script type="math/tex">L(\theta)</script>的下界，并且在<script type="math/tex">\theta=\theta^{(i)}</script>时取等号：</p><script type="math/tex; mode=display">L\left(\theta^{(i)}\right)=B\left(\theta^{(i)}, \theta^{(i)}\right)</script><ul><li>所以，增大下界<script type="math/tex">B(\theta, \theta^{(i)})</script>，同样可以使得<script type="math/tex">L(\theta)</script>增大，而为了<script type="math/tex">L(\theta)</script>增大得最多，选择<script type="math/tex">\theta^{(i+1)}</script>使得<script type="math/tex">B(\theta, \theta^{(i)})</script>达到极大：</li></ul><script type="math/tex; mode=display">\theta^{(i+1)}=\arg \max _{\theta} B\left(\theta, \theta^{(i)}\right)</script><ul><li>由上式就可以推出<script type="math/tex">Q(\theta, \theta^{(i)})</script>函数：</li></ul><script type="math/tex; mode=display">\begin{aligned}\theta^{(i+1)} &=\arg \max _{\theta}\left(L\left(\theta^{(i)}\right)+\sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log \frac{P(Y \mid Z, \theta) P(Z \mid \theta)}{P\left(Z \mid Y, \theta^{(i)}\right) P\left(Y \mid \theta^{(i)}\right)}\right) \\&=\arg \max _{\theta}\left(\sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log (P(Y \mid Z, \theta) P(Z \mid \theta))\right) \\&=\arg \max _{\theta}\left(\sum_{Z} P\left(Z \mid Y, \theta^{(i)}\right) \log P(Y, Z \mid \theta)\right) \\&=\arg \max _{\theta} Q\left(\theta, \theta^{(i)}\right)\end{aligned}</script><h3 id="6-5-直观解释"><a href="#6-5-直观解释" class="headerlink" title="6.5 直观解释"></a>6.5 直观解释</h3><ul><li>上方曲线为<script type="math/tex">L(\theta)</script>，下方曲线为<script type="math/tex">B(\theta, \theta^{(i)})</script>，两者在<script type="math/tex">\theta=\theta^{(i)}</script>处相等，此时执行M步：找到<script type="math/tex">\theta^{(i+1)}=\arg \max _{\theta} B\left(\theta, \theta^{(i)}\right)</script>。函数<script type="math/tex">B(\theta, \theta^{(i)})</script>的增加同时也造成了<script type="math/tex">L(\theta)</script>的增加。得到<script type="math/tex">\theta^{(i+1)}</script>后再执行E步：在<script type="math/tex">\theta = \theta^{(i+1)}</script>点重新计算Q函数，然后进行下一次迭代</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221021194004500.png" alt="image-20221021194004500"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SVM总结</title>
    <link href="/2022/04/06/SVM/"/>
    <url>/2022/04/06/SVM/</url>
    
    <content type="html"><![CDATA[<ul><li>SVM和决策树一样，同样是一种判别式模型， 都是基于条件概率分布进行建模，要在样本空间中找到一个划分超平面，将不同类别的样本分开，如下图：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220923114248027.png" alt="image-20220923114248027" style="zoom:67%;" /></p><p>存在多个超平面可将训练样本分开，但是我们是希望找到对于分类结果<strong>最鲁棒的超平面</strong>，也就是图中加粗的那条线，这个超平面对训练样本局部扰动的“容忍性”最好</p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><ul><li>在样本空间中，一个超平面可以通过以下线性方程来描述：</li></ul><script type="math/tex; mode=display">\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b=0</script><p>其中<script type="math/tex">w = (w_1, ..., w_d)</script>为法向量，确定超平面的方向，b为位移项，确定超平面与原点之间的距离。</p><ul><li>那么样本空间中任意点<script type="math/tex">x</script>到超平面<script type="math/tex">(w, b)</script>的距离为：</li></ul><script type="math/tex; mode=display">r=\frac{\left|\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b\right|}{\|\boldsymbol{w}\|}</script><ul><li>若超平面<script type="math/tex">(w, b)</script>能将样本正确分类，则对于任意<script type="math/tex">(x_i, y_i) \in D</script>，若<script type="math/tex">y = +1</script>则<script type="math/tex">w^Tx_i + b > 0</script>，若<script type="math/tex">y = -1</script>，则<script type="math/tex">w^Tx_i + b < 0</script>，那么令：</li></ul><script type="math/tex; mode=display">\left\{\begin{array}{ll}\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b \geqslant+1, & y_{i}=+1 \\\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b \leqslant-1, & y_{i}=-1\end{array}\right.</script><p>另上式等号成立的样本点成为<strong>支持向量</strong>，两个异类支持向量到超平面的距离之和为：</p><script type="math/tex; mode=display">\gamma = \frac{2}{||w||}</script><p>称之为<strong>间隔</strong>，如下图：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220923120639393.png" alt="image-20220923120639393" style="zoom:75%;" /></p><blockquote><p>可以发现在上式中，<script type="math/tex">w^Tx_i + b</script>是采用了大于或小于<script type="math/tex">\pm 1</script>而不是0或其他数字进行划分。<strong>首先不能使用0，因为若为0，则支持向量会恰好落在划分超平面上。而使用<script type="math/tex">\pm1</script>只是因为方便计算（若为其他非0数是一样的效果，因为$w$和$b$可以进行放缩）</strong></p></blockquote><ul><li>欲找到一个具有<strong>最大间隔</strong>的划分超平面，也就是找到能满足约束的参数$w$和$b$，使得$\gamma$最大，即：</li></ul><script type="math/tex; mode=display">\begin{aligned}\max _{\boldsymbol{w}, b} & \frac{2}{\|\boldsymbol{w}\|} \\\text { s.t. } & y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right) \geqslant 1, \quad i=1,2, \ldots, m .\end{aligned}</script><ul><li>因为最大化<script type="math/tex">||w||^{-1}</script>等价于最小化<script type="math/tex">||w||^2</script>，所以我们一般写为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\min _{\boldsymbol{w}, b} & \frac{1}{2}\|\boldsymbol{w}\|^{2} \\\text { s.t. } & y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right) \geqslant 1, \quad i=1,2, \ldots, m .\end{aligned}</script><p>这就是SVM的基本型</p><h1 id="2-对偶问题"><a href="#2-对偶问题" class="headerlink" title="2 对偶问题"></a>2 对偶问题</h1><h3 id="2-1-KKT条件"><a href="#2-1-KKT条件" class="headerlink" title="2.1 KKT条件"></a>2.1 KKT条件</h3><ul><li>考虑一个有m个等式约束和n个不等式约束的优化问题：</li></ul><script type="math/tex; mode=display">\begin{array}{ll}\min _{\boldsymbol{x}} & f(\boldsymbol{x}) \\\text { s.t. } & h_{i}(\boldsymbol{x})=0 \quad(i=1, \ldots, m) \\& g_{j}(\boldsymbol{x}) \leqslant 0 \quad(j=1, \ldots, n)\end{array}</script><ul><li>引入拉格朗日乘子<script type="math/tex">\pmb{\lambda} = (\lambda_1, ..., \lambda_m)</script>和<script type="math/tex">\pmb{\mu} = (\mu_1, ..., \mu_n)</script>，则相应的拉格朗日函数为：</li></ul><script type="math/tex; mode=display">L(\boldsymbol{x}, \boldsymbol{\lambda}, \boldsymbol{\mu})=f(\boldsymbol{x})+\sum_{i=1}^{m} \lambda_{i} h_{i}(\boldsymbol{x})+\sum_{j=1}^{n} \mu_{j} g_{j}(\boldsymbol{x})</script><p>则由不等式约束引入的KKT条件（j = 1, .., n）为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}g_{j}(\boldsymbol{x}) \leqslant 0 \\\mu_{j} \geqslant 0 \\\mu_{j} g_{j}(\boldsymbol{x})=0\end{array}\right.</script><h3 id="2-2-原问题转化到对偶问题"><a href="#2-2-原问题转化到对偶问题" class="headerlink" title="2.2 原问题转化到对偶问题"></a>2.2 原问题转化到对偶问题</h3><ul><li><p>SVM没有使用原问题而使用对偶问题是因为：<strong>对偶函数更易于求解，原问题约束太多太麻烦，并且对偶函数是一个光滑的凸函数，可以找到全局最优解，</strong>具体解释可看<a href="https://www.zhihu.com/question/36694952">例子</a></p></li><li><p>先写出上述问题的拉格朗日函数，即<strong>原问题</strong>：</p></li></ul><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{n} \alpha_{i}\left(y_{i}\left(w^{T} x_{i}+b\right)-1\right)</script><p>其中的<script type="math/tex">\alpha_i</script>为拉格朗日乘子</p><ul><li>易知：<strong>当有一个约束函数不满足时，L的最大值为<script type="math/tex">\infty</script>（只需令其对应的<script type="math/tex">\alpha_i</script>为<script type="math/tex">\infty</script>即可）；当所有约束条件都满足时，L的最大值为<script type="math/tex">\frac{1}{2}||w||^2</script>（只需令所有<script type="math/tex">\alpha_i</script>为0）</strong>。所有原问题等价于：</li></ul><script type="math/tex; mode=display">\min _{\boldsymbol{w}, b} \frac{1}{2}||w||^2 = \min _{w, b} \theta(w)=\min _{w, b} \max _{\alpha_{i} \geq 0} \mathcal{L}(w, b, \alpha)=p^{*}</script><ul><li>由于这个的求解问题不好做，<strong>因此一般我们将最小和最大的位置交换一下（需满足KKT条件）</strong>：</li></ul><script type="math/tex; mode=display">\max _{\alpha_{i} \geq 0} \min _{w, b} \mathcal{L}(w, b, \alpha)=d^{*}</script><ul><li>接下来就先对w，b求极小，再对<script type="math/tex">\alpha</script>求极大：</li></ul><blockquote><ol><li>首先求L对w和b的极小，分别求L关于w和b的偏导，可以得出：</li></ol><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial L}{\partial w}=0 \Rightarrow w=\sum_{i=1}^{n} \alpha_{i} y_{i} x_{i} \\\frac{\partial L}{\partial b}=0 \Rightarrow \sum_{i=1}^{n} \alpha_{i} y_{i}=0\end{array}</script><ol><li>将上述结果代入L：</li></ol><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}(w, b, \alpha) &=\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j}-\sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j}-b \sum_{i=1}^{n} \alpha_{i} y_{i}+\sum_{i=1}^{n} \alpha_{i} \\&=\sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j}\end{aligned}</script></blockquote><ul><li>这样就得到了原问题的<strong>对偶问题</strong>：</li></ul><script type="math/tex; mode=display">\begin{array}{ll}\max _{\alpha} & \sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j} \\\text { s.t. } & \alpha_{i} \geq 0, i=1, \ldots, n \\& \sum_{i=1}^{n} \alpha_{i} y_{i}=0\end{array}</script><p>然后再对<script type="math/tex">\alpha</script>求解<strong>（采用SMO算法）</strong>，即可得到模型：</p><script type="math/tex; mode=display">f(x) = w^Tx + b \\  = \sum_{i=1}^m{\alpha_iy_ix_i^Tx + b}</script><blockquote><p>由于满足KKT条件，所有对于任意样本<script type="math/tex">(x_i, y_i) \in D</script>，总有<script type="math/tex">\alpha_i=0</script>或<script type="math/tex">y_if(x_i) = 1</script>。若<script type="math/tex">\alpha_i=0</script>，则样本将不会出现在上述的模型式子中，就不会对<script type="math/tex">f(x)</script>产生影响；若<script type="math/tex">\alpha_i > 0</script>，则对应样本为支持向量。所以：<strong>最终模型仅与支持向量有关，大部分训练样本都无需保留</strong></p></blockquote><h3 id="2-3-SMO算法"><a href="#2-3-SMO算法" class="headerlink" title="2.3 SMO算法"></a>2.3 SMO算法</h3><ul><li>在对偶问题中如果要对<script type="math/tex">\alpha</script>求解，这是一个二次规划问题，可使用通用的方法求解，<strong>但是该问题的规模正比于训练样本数，将会有很大的开销</strong>，所以提出了SMO（Sequential Minimal Optimization）等更高效的算法</li><li>SMO算法之所以高效，是因为其<strong>每次只更新两个参数，而固定其他参数</strong>，具体来说，考虑更新<script type="math/tex">\alpha_i</script>和<script type="math/tex">\alpha_j</script>，而固定其他参数，由于存在约束<script type="math/tex">\sum_{i=1}^m{\alpha_iy_i} = 0</script>，所以：</li></ul><script type="math/tex; mode=display">\alpha_iy_i + \alpha_jy_j = c, \alpha_i \geq 0,\alpha_j \geq 0  \\ c = -\sum_{k \neq i, j}\alpha_ky_k</script><p>c为一个已知的常数</p><ul><li><p>则可以通过上式，消去$\alpha_j$，从而得到一个关于$\alpha_i$的单变量二次规划问题，仅有的约束是$\alpha_i \geq 0$，这样即可高效地更新$\alpha_i$，然后通过约束再得到更新后的$\alpha_j$</p></li><li><p>重复上述过程，每次只更新两个变量，直到收敛。但是每次按一定的规则选择两个变量进行更新：</p></li></ul><blockquote><p>因为选择的$\alpha_i, \alpha_j$只要有一个不满足KKT条件（一开始是随机初始化的），目标函数就会在迭代后增大，并且直观上来看，KKT条件违背的程度越大，则更新后获得的收益就越大。所以<strong>SMO先选取先选取一个违背KKT条件程度最大的变量</strong>，第二个变量应该选择使目标函数增长最快的变量，但是找出这个变量过于复杂，所以采用一个启发式：<strong>使选取的两个变量所对应的样本之间的间隔最大</strong>。直观解释为：差别大的两个变量的更新能给目标函数带来更大的增益</p></blockquote><ul><li>除了$\alpha$变量的更新，还需要确定偏移项b。对于任意支持向量<script type="math/tex">(x_s, y_s)</script>，都有<script type="math/tex">y_sf(x_s) = 1</script>，即：</li></ul><script type="math/tex; mode=display">y_{s}\left(\sum_{i \in S} \alpha_{i} y_{i} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{s}+b\right)=1</script><p>其中S为所有支持向量的下标集。理论上，采用任意一个支持向量都可以得到b的值，但是SMO采用更鲁棒的做法：<strong>使用所有支持向量求解的平均值：</strong></p><script type="math/tex; mode=display">b=\frac{1}{|S|} \sum_{s \in S}\left(y_{s}-\sum_{i \in S} \alpha_{i} y_{i} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{s}\right)</script><h1 id="3-核函数"><a href="#3-核函数" class="headerlink" title="3 核函数"></a>3 核函数</h1><ul><li>前面的讨论中，我们是假设训练样本是线性可分的，即存在一个划分超平面能将训练样本正确分类。然而在现实任务中，原始样本空间也许并不存在一个能正确划分两类样本的超平面。对于这样的问题，<strong>可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间中线性可分</strong>，如下图：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220923160040076.png" alt="image-20220923160040076" style="zoom:80%;" /></p><ul><li>令<script type="math/tex">\phi(x)</script>表示将x映射后的特征向量，于是在特征空间中的超平面对应的模型为：</li></ul><script type="math/tex; mode=display">f(x) = w^T\phi(x) + b</script><ul><li>然后像之前一样进行对偶问题的最优化，但是其中有一个内积项<script type="math/tex">\phi(x_i)^T\phi(x_j)</script>，这是样本$x_i$核$x_j$映射到特征空间后的内积。由于特征空间维度可能很高，甚至可能是无穷维，直接计算此内积项通常比较困难，所以提出了<strong>核函数</strong>：</li></ul><script type="math/tex; mode=display">\mathcal{k}(x_i, x_j) = <\phi(x_i), \phi(x_j)> = \phi(x_i)^T\phi(x_j)</script><p><strong>即$x_i$和$x_j$在特征空间的内积可以通过核函数在原始样本空间中的结果得出</strong></p><ul><li><p>因此，在线性不可分问题中，核函数的选择成了支持向量机的最大变数，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，<strong>核函数需要满足以下这个必要条件</strong>：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/5bc730ccc468c.png" alt="26.png"></p><p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/5bc730ccc541a.png" alt="27.png"></p></li></ul><h1 id="4-软间隔"><a href="#4-软间隔" class="headerlink" title="4 软间隔"></a>4 软间隔</h1><ul><li>前面讨论的情况是假定样本在样本空间或特征空间线性可分。然而在限时任务中往往很难确定合适的核函数，退一步讲，即使找到了核函数，也无法确定这个线性可分的结果是否是由于过拟合造成的。例如数据中有噪声的情况，噪声数据（outlier）本就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，<strong>当加入这些outlier后导致划分超平面被挤歪了</strong>，如下图所示，对支持向量机的泛化性能造成很大的影响：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/5bc730ccce68e.png" alt="28.png" style="zoom:67%;" /></p><p>可以看到如果不要outlier，能分出一个间隔更大的划分超平面</p><ul><li>缓解这个问题的一个办法是允许SVM在一些样本上出错。前面所述的SVM要在所有样本上都划分正确，这成为<strong>硬间隔（hard margin）</strong>。而<strong>软间隔则是允许某些样本不满足约束 <script type="math/tex">y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right) \geqslant 1</script>，但是不满足该约束的样本要尽可能少</strong>，于是优化目标可以写为：</li></ul><script type="math/tex; mode=display">\min _{\boldsymbol{w}, b} \frac{1}{2}\|\boldsymbol{w}\|^{2}+C \sum_{i=1}^{m} \ell_{0 / 1}\left(y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right)-1\right)</script><p>其中C是一个常数，<script type="math/tex">\ell_{0/1}(z)</script>是0/1损失函数，即<script type="math/tex">z < 0</script>的时候取1，其他时候取0。<strong>当C为无穷大的时候，则迫使所有样本满足约束，退化为硬间隔。当C为有限值的时候，允许一些样本不满足约束</strong></p><ul><li>由于<script type="math/tex">\ell_{0/1}</script>非凸非连续，数学性质不太好，所以可以用以下三种替代损失函数：</li></ul><blockquote><ul><li>hinge损失：<script type="math/tex">\ell_{\text {hinge }}(z)=\max (0,1-z)</script></li><li>指数损失（exponential loss）：<script type="math/tex">\ell_{\exp }(z)=\exp (-z)</script></li><li>对率损失（logistic loss）：<script type="math/tex">\ell_{\log }(z)=\log (1+\exp (-z))</script></li></ul></blockquote><ul><li>常用hinge损失进行替代，然后将连加中的每一项换为松弛变量（slack variables）$\xi_{i} \ge 0$，则优化目标重写为：</li></ul><script type="math/tex; mode=display">\min _{\boldsymbol{w}, b, \xi_{i}} \frac{1}{2}\|\boldsymbol{w}\|^{2}+C \sum_{i=1}^{m} \xi_{i}</script><p>每个变量都对应一个松弛变量，代表<strong>样本不满足约束的程度</strong></p><ul><li>上述问题仍是一个二次规划问题，按照和前面一样的方法进行求解，先写出拉格朗日函数：</li></ul><script type="math/tex; mode=display">\begin{aligned}L(\boldsymbol{w}, b, \boldsymbol{\alpha}, \boldsymbol{\xi}, \boldsymbol{\mu})=& \frac{1}{2}\|\boldsymbol{w}\|^{2}+C \sum_{i=1}^{m} \xi_{i} \\&+\sum_{i=1}^{m} \alpha_{i}\left(1-\xi_{i}-y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right)\right)-\sum_{i=1}^{m} \mu_{i} \xi_{i}\end{aligned}</script><p>其中$\alpha_i \ge 0$、$\mu_i \ge 0$是拉格朗日乘子，据此求解即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KNN总结</title>
    <link href="/2022/03/25/KNN/"/>
    <url>/2022/03/25/KNN/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1 基本思想"></a>1 基本思想</h1><ul><li>KNN模型是一种非参、惰性的模型，即并不需要显式的训练过程，也不需要参数，可以基于训练集直接进行预测</li><li>给定训练集<script type="math/tex">D = \{(x_1, y_1), ... (x_N, y_N)\}</script>和要预测的输入<script type="math/tex">x</script>，在训练集中找到和<script type="math/tex">x</script>最近的k个样本，然后通过投票的方式来预测<script type="math/tex">x</script>的类别</li></ul><script type="math/tex; mode=display">y=\arg \max _{c_{j}} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right), \quad i=1,2, \cdots, N ; \quad j=1,2, \cdots, K</script><p>其中<script type="math/tex">N_k</script>为和<script type="math/tex">x</script>最近的k个样本</p><ul><li><p>样本之间的距离度量常用<strong>欧氏距离</strong>，但也可以为更一般的<script type="math/tex">L_p,\quad p=1,2,...,\infty</script></p></li><li><p>对于k值的选择具有很大的影响，在应用中，<strong>k值一般取一个比较小的值</strong>，通常用<strong>交叉验证法</strong>选取最优值</p></li></ul><h1 id="2-kd树"><a href="#2-kd树" class="headerlink" title="2 kd树"></a>2 kd树</h1><ul><li>如果要把输入和每个样本都比较，复杂度是和训练及大小成正比的，所以采用kd树来降低复杂度</li></ul><h3 id="2-1-kd树构造"><a href="#2-1-kd树构造" class="headerlink" title="2.1 kd树构造"></a>2.1 kd树构造</h3><ul><li>简单来说，就是<strong>每次选取特征空间的一个维度，然后基于这个维度进行划分（一般选择当前样本在这个维度上的中位数进行划分）</strong>，算法流程如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221103120149491.png" alt="image-20221103120149491" style="zoom: 50%;" /></p><ul><li>举个栗子，给定特征空间<script type="math/tex">T=\left\{(2,3)^{\mathrm{T}},(5,4)^{\mathrm{T}},(9,6)^{\mathrm{T}},(4,7)^{\mathrm{T}},(8,1)^{\mathrm{T}},(7,2)^{\mathrm{T}}\right\}</script>，则会产生以下的kd树和空间划分：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221103120509325.png" alt="image-20221103120509325" style="zoom:50%;" /></p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221103120523272.png" alt="image-20221103120523272" style="zoom:50%;" /></p><h3 id="2-2-kd树搜索"><a href="#2-2-kd树搜索" class="headerlink" title="2.2 kd树搜索"></a>2.2 kd树搜索</h3><ul><li><p>构造好kd树后，就需要对kd树的结点进行搜索得到最近的k个样本，这里只说明搜索最近的样本（k=1），其他情况可以类推</p></li><li><p>可以从上面的栗子中看到，<strong>每次划分会产生一个超矩阵空间，并且叶结点对应的超矩阵空间是最小的</strong></p></li><li><p>给定要预测的输入<script type="math/tex">x</script>，先根据kd树的划分依据，找到<script type="math/tex">x</script>对应的叶结点，然后将该叶节点对应的样本<script type="math/tex">x'</script>作为候选最近样本，那么<strong>更近的样本，一定处于以x为球心，distance(x, x’)为半径的超球面内部</strong>，那么我们依次对每个超矩阵空间进行判定，<strong>若超矩阵空间和超球面没有相交，那么最近邻样本一定不在该超矩阵空间中，则该空间中的所有样本就都不用判断了；反之若相交，则将该子树作为根节点，递归寻找</strong>，算法流程如下：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221103155306872.png" alt="image-20221103155306872" style="zoom:50%;" /></p><ul><li>使用kd树使平均时间复杂度从<script type="math/tex">O(N)</script>降为了<script type="math/tex">O(\log N)</script>，但是需要很大的存储空间</li></ul><h1 id="3-一些结论"><a href="#3-一些结论" class="headerlink" title="3 一些结论"></a>3 一些结论</h1><ol><li><strong>KNN对回归、分类都可以用，对数据没有假设，并且对异常点不敏感，但是样本不平衡的时候准确率较低，可以通过投票时引入权值来改善</strong></li><li><p><strong>KNN每次选取最大方差的维度作为划分维度(方差越大，表示此维度上数据越分散)，这样一次划分的两组样本差别越大，搜索的时候可能会减少递归次数</strong></p></li><li><p><strong>KNN要提取中位数，可以在算法最开始的时候，在每个维度进行一次排序并存储下来，而不需要每次选了维度再排序，提升性能</strong></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BERT总结</title>
    <link href="/2022/02/25/Bert%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/25/Bert%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li><p>BERT是一种通过<strong>在预训练时使用无监督</strong>方法能在<strong>每一层</strong>实现<strong>双向</strong>表征的语言模型，并且使用微调的方法，在<strong>具体的下游任务时不需要task-specific architecture</strong>，只需要添加一两层和少部分参数，十分易于迁移</p></li><li><p>BERT带来的主要提升是解决了双向性的问题。如OpenAI GPT使用的是left-to-right（LTR）Transformer结构，失去了双向性。又比如ELMo使用简单的将left-to-right（LTR）的LSTM和right-to-left（RTL）的LSTM在最后简单的连结来实现双向性，而BERT能在每一层都实现双向，并且相比于在最后简单的连结更具有直观性和可解释性。</p></li></ul><h1 id="1-BERT的结构"><a href="#1-BERT的结构" class="headerlink" title="1 BERT的结构"></a>1 BERT的结构</h1><h3 id="1-1-结构和规模"><a href="#1-1-结构和规模" class="headerlink" title="1.1 结构和规模"></a>1.1 结构和规模</h3><ul><li>BERT的结构十分简单，就是由<strong>多个Transformer的encoder组合而成</strong></li><li><p>我们将encoder的数量设为L，隐藏层的单元数设为H，自注意力头的个数设为A，则BERT可分为<script type="math/tex">BERT_{BASE}</script>（L=12，H=768，A=12，总参数量=110M  ）和<script type="math/tex">BERT_{LARGE}</script>（L=24，H=1024，A=16，总参数量=340M）两个版本</p></li><li><p><script type="math/tex">BERT_{LARGE}</script>在几乎所有的任务上都是优于<script type="math/tex">BERT_{BASE}</script>的，特别是特别小的数据集上</p></li></ul><h3 id="1-2-BERT的输入输出"><a href="#1-2-BERT的输入输出" class="headerlink" title="1.2 BERT的输入输出"></a>1.2 BERT的输入输出</h3><ul><li><p>BERT使用WordPiece embeddings  </p></li><li><p>BERT的<strong>输入可以是一个句子也可以是两个句子</strong>，每个输入的<strong>最开始都需要加一个[CLS] token</strong>，如果输入包含两个句子（sentence A and sentence B），则<strong>中间需要加入一个[SEP] token来做分隔</strong></p></li><li><strong>总的输入为</strong>：对应的token embedding+segment embedding+position embedding的总和：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701114959234.png" alt="image-20220701114959234"></p><p>其中segment embedding是用以区分sentence A和sentence B（<strong>第一个句子的segment embedding都是0，第二个的都是1</strong>），而position embedding和Transformer中的不一样，Transformer是采用三角函数，而<strong>BERT采用learned position embedding</strong></p><ul><li>输入输出的形式大致如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701115457939.png" alt="image-20220701115457939"></p><p><strong>其中C为[CLS]对应的最终的embedding，在分类任务时作为整个序列的总表征（但是C在微调之前是没有具体意义的向量，因为他是通过NSP预训练出来的）</strong>。<script type="math/tex">T_i</script>为第<script type="math/tex">i</script>个token所对应的embedding</p><h1 id="2-BERT的Pre-training"><a href="#2-BERT的Pre-training" class="headerlink" title="2 BERT的Pre-training"></a>2 BERT的Pre-training</h1><ul><li>BERT的Pre-training可分为MLM和NSP，分别对应token级的任务和sentence级的任务</li><li>Pre-training采用的是<strong>无监督的方法</strong></li><li>在Pre-training数据的选择上，使用document-level corpus要优于shuffled sentence-level corpus</li></ul><h3 id="2-1-Masked-Language-Model（MLM）"><a href="#2-1-Masked-Language-Model（MLM）" class="headerlink" title="2.1 Masked Language Model（MLM）"></a>2.1 Masked Language Model（MLM）</h3><h4 id="2-1-1-MLM的输入"><a href="#2-1-1-MLM的输入" class="headerlink" title="2.1.1 MLM的输入"></a>2.1.1 MLM的输入</h4><ul><li>每个输入的sequence会<strong>随机mask掉15%的token</strong>，并且在最后预测mask掉的地方是什么词（通过将该token最后对应的embedding送入softmax层并采用交叉熵损失，分类个数为整个词典的token数）</li><li><strong>其中mask的策略为</strong>，对于一个要mask的token：</li></ul><ol><li>80%的概率变为[MASK]</li><li>10%的概率变为随机词</li><li>10%的概率不变</li></ol><p>举个栗子：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701122513870.png" alt="image-20220701122513870" style="zoom:80%;" /></p><h4 id="2-2-采用此mask策略的原因"><a href="#2-2-采用此mask策略的原因" class="headerlink" title="2.2 采用此mask策略的原因"></a>2.2 采用此mask策略的原因</h4><ul><li>预训练时是有[MASK]的，但是微调时是没有的，那么<strong>微调时模型就只能根据其他token的信息和语序结构来预测当前词，而无法利用到这个词本身的信息</strong>（因为它们从未出现在训练过程中，等于模型从未接触到它们的信息，等于整个语义空间损失了部分信息），所以会<strong>产生预训练和微调的mismatch</strong></li><li>而保留下来的信息<strong>如果全部使用原始token，那么模型在预训练的时候可能会偷懒，直接照抄当前的token</strong>，所以需要随机换成其他词，会让模型不能去死记硬背当前的token，而去<strong>尽力学习单词周边的语义表达和远距离的信息依赖</strong>，尝试建模完整的语言信息</li><li>但是随机替换不能太多，要不然肯定会对模型产生误导，以下是经过多次实验的数据：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701123511287.png" alt="image-20220701123511287"></p><p>可以看到只使用随机替换，会对结果产生极大的影响</p><h4 id="2-3-MLM的问题"><a href="#2-3-MLM的问题" class="headerlink" title="2.3 MLM的问题"></a>2.3 MLM的问题</h4><ul><li>由于MLM每次只mask掉15%的词，所以只预测15%的词，所以需要更多的steps才能收敛，以下是MLM和LTR模型的对比：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701123837335.png" alt="image-20220701123837335"></p><p>可以看到MLM收敛速度更慢，需要更多的steps，但是所获得的改进远大于所增加的成本，所以问题不大</p><h3 id="2-2-Next-Sentence-Predictoin（NSP）"><a href="#2-2-Next-Sentence-Predictoin（NSP）" class="headerlink" title="2.2 Next Sentence Predictoin（NSP）"></a>2.2 Next Sentence Predictoin（NSP）</h3><ul><li>NSP的输入为两个句子，有50%的概率sentence B是sentence A的下一句，有50%的概率不是，举个栗子：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701124711635.png" alt="image-20220701124711635" style="zoom:90%;" /></p><ul><li>在最后使用C向量送入下一层，判断为IsNext or NotNext</li></ul><h3 id="2-3-Pre-training的细节"><a href="#2-3-Pre-training的细节" class="headerlink" title="2.3 Pre-training的细节"></a>2.3 Pre-training的细节</h3><ul><li><p><strong>优化：</strong></p><blockquote><ol><li>Adam（learning rate = <script type="math/tex">10^{-4}</script>，<script type="math/tex">\beta_1 = 0.9</script>， <script type="math/tex">\beta_2 = 0.999</script>）</li><li>learning rate在前10000个steps采用warmup，并且还应用了线性衰减</li><li>0.01的L2权重衰减和0.1的Dropout</li><li>batch size = 256 sequences / batch</li></ol></blockquote></li><li><p>激活函数采用gelu而非relu</p></li><li><p>损失为MLM的最大似然和NSP的最大似然的和</p></li><li><p>由于attention是随序列长度进行平方增长的，所以为了提高预训练速度，在实验时，<strong>先在90%的steps应用应用128的序列长，然后在剩下的10%的steps中改为512序列长度，来学习position embedding</strong></p></li></ul><h1 id="3-BERT的Fine-tuning"><a href="#3-BERT的Fine-tuning" class="headerlink" title="3 BERT的Fine-tuning"></a>3 BERT的Fine-tuning</h1><h3 id="3-1-Fine-tuning的一般做法"><a href="#3-1-Fine-tuning的一般做法" class="headerlink" title="3.1 Fine-tuning的一般做法"></a>3.1 Fine-tuning的一般做法</h3><ul><li>都是在最后加上一两层，来进行微调。对于Transformer Encoder的输出：</li></ul><ol><li>如果是token级的下游任务，如sequence tagging和question answering，是直接将对应的token输出的embedding送入下一层。</li><li>如果是sentence级的下游任务，如sentiment analysis，需要将[CLS]对应的输出，也就是C，送入下一层用以分类</li></ol><h3 id="3-2-Fine-tuning的细节"><a href="#3-2-Fine-tuning的细节" class="headerlink" title="3.2 Fine-tuning的细节"></a>3.2 Fine-tuning的细节</h3><ul><li>大多数超参数和pre-training时是一样的，除了batch size、learning rate和epochs</li><li>dropout的概率还是保持为0.1</li><li>在实验中发现，以下几个超参的选择，适用于大多数的任务：</li></ul><blockquote><p><strong>Batch size：16， 32</strong></p><p><strong>Learning rate (Adam)：<script type="math/tex">5 \times 10^{-5}, 3 \times 10^{-5}, 2 \times 10^{-5}</script>  </strong></p><p><strong>Number of epochs：2，3，4  </strong></p></blockquote><ul><li>并且还发现大数据集相比小数据集对于超参的选择是不那么敏感的</li></ul><h1 id="4-BERT实践"><a href="#4-BERT实践" class="headerlink" title="4 BERT实践"></a>4 BERT实践</h1><ul><li>下面介绍BERT在各种下游任务上的表现：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220701233158369.png" alt="image-20220701233158369" style="zoom:70%;" /></p><h3 id="4-1-GLUE"><a href="#4-1-GLUE" class="headerlink" title="4.1 GLUE"></a>4.1 GLUE</h3><ul><li>GLUE全称为The General Language Understanding Evaluation，包含了各种而样的自然语言理解任务</li><li>在BERT中我们只添加了一个多分类输出层，将[CLS]对用的输出C，送入该层，再使用softmax，计算损失</li><li><p>采用的超参：batch size = 32，epochs = 3，learning rate =  <script type="math/tex">5 \times 10^{-5}，4 \times 10^{-5}，3 \times 10^{-5}，2 \times 10^{-5}</script></p></li><li><p>在微调时，<strong><script type="math/tex">BERT_{LARGE}</script>在小数据集上的结果是不稳定的</strong>，所以采取了<strong>多次随机重启</strong>（不一样的数据重洗和分类层的参数初始化），并且选择了在验证集上结果最好的模型</p></li></ul><h3 id="4-2-SQuAD"><a href="#4-2-SQuAD" class="headerlink" title="4.2 SQuAD"></a>4.2 SQuAD</h3><ul><li>SQuAD全称The Stanford Question Answering Dataset，收录了100k的QA对，其中每个Query的Answer是在对应的Passage中的一段连续文本（answer span）</li></ul><h4 id="4-2-1-SQuAD-v1-1"><a href="#4-2-1-SQuAD-v1-1" class="headerlink" title="4.2.1 SQuAD v1.1"></a>4.2.1 SQuAD v1.1</h4><ul><li>首先设<script type="math/tex">S \in R^H</script>和<script type="math/tex">E \in R^H</script>分别为answer span中的第一个词和最后一个词的embedding</li><li>那么<script type="math/tex">word_i</script>作为第一个词的概率，可以使用点积+softmax的求得：（其中<script type="math/tex">T_i</script>是<script type="math/tex">word_i</script>对应的output）</li></ul><script type="math/tex; mode=display">P_{i}=\frac{e^{S \cdot T_{i}}}{\sum_{j} e^{S \cdot T_{j}}}</script><p>将<script type="math/tex">word_i</script>作为最后一个词的概率也是一样的算法，只是把S替换成E</p><ul><li><p>在训练时的损失为正确的开始和结束位置的最大似然</p></li><li><p>在预测时，每个候选位置，即将<script type="math/tex">word_i</script>到<script type="math/tex">word_j</script>作为answer的score为：</p></li></ul><script type="math/tex; mode=display">S \cdot T_i + E \cdot T_j \quad (j \geq i)</script><p>然后取最大score的侯选位置作为输出</p><ul><li><p>超参：batch size = 32，epochs = 3，learning rate = <script type="math/tex">5 \times 10^{-5}</script></p></li><li><p>在具体实验中，应用于SQuAD数据集上前，先在TriviaQA上微调，进行适当的数据增强</p></li></ul><h4 id="4-2-2-SQuAD-v2-0"><a href="#4-2-2-SQuAD-v2-0" class="headerlink" title="4.2.2 SQuAD v2.0"></a>4.2.2 SQuAD v2.0</h4><ul><li>SQuAD v2.0相对于SQuAD v1.1增加了一个No Answer的输出，因为一个问题的答案并不总是出现在passage中的，No Answer的的具体形式为start和end都是[CLS]的answer span，预测为No Answer的score为：</li></ul><script type="math/tex; mode=display">s_{null} = S \cdot C + E \cdot C</script><p>当满足下式时，则不预测为No Answer：</p><script type="math/tex; mode=display">\hat{s_{i, j}}>s_{\mathrm{null}}+\tau</script><p>其中<script type="math/tex">\hat{s_{i, j}}=\max _{j \geq i} S \cdot T_{i}+E \cdot T_{j}</script>，而<script type="math/tex">\tau</script>是通过实验所得，使在验证集上获得最大的F1</p><ul><li>在本次实验中并未使用TriviaQA data set</li><li>超参：batch size = 48，epochs = 2，learning rate = <script type="math/tex">5 \times 10^{-5}</script></li></ul><h3 id="4-3-SWAG"><a href="#4-3-SWAG" class="headerlink" title="4.3 SWAG"></a>4.3 SWAG</h3><ul><li>全称The Situations With Adversarial Generations，用于常识推断任务，具体任务是给定一个sentence，然后需要在4个选择中选出最合适的答案</li><li>任务可建模为：每次有4个输入序列，每个输出是给定的sentence+4个可能的选择之一，最后得到C向量，再加一层全连接层，用sotfmax计算概率</li><li>超参：batch size = 16，epochs = 3，learning rate = <script type="math/tex">2 \times 10^{-5}</script></li></ul><h1 id="5-BERT和其他模型的对比"><a href="#5-BERT和其他模型的对比" class="headerlink" title="5 BERT和其他模型的对比"></a>5 BERT和其他模型的对比</h1><ul><li>实验进行了ELMo，OpenAI GPT和BERT之间的对比</li><li>首先介绍大致做法和结构：</li></ul><blockquote><ol><li>BERT使用双向Transformer，OpenAI GPT使用LTR Transformer，而ELMo使用LTR和RTL的LSTM在最后的简单连结</li><li>BERT和OpenAI GPT使用fine-tuning approaches，而ELMo使用feature-based approach</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220702121317344.png" alt="image-20220702121317344" style="zoom:80%;" /></p></blockquote><ul><li>另外，ELMo使用在最后将LTR和TRL简单的连结，有以下缺点：</li></ul><blockquote><ol><li>两倍的工作量</li><li>对于有些任务是不直观的，如QA</li><li>BERT在每层都可以实现双向，而ELMo只会在最后连结</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer总结</title>
    <link href="/2022/01/25/Transformer%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/25/Transformer%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li>Transformer摒弃了传统的CNN/RNN模型，而是用纯注意力机制， <strong>相对于RNN，实现了并行化，并且消除了memory对于距离的依赖性（无法捕捉长距离依赖）。</strong></li></ul><h1 id="1-注意力机制"><a href="#1-注意力机制" class="headerlink" title="1 注意力机制"></a>1 注意力机制</h1><ul><li><strong>注意力机制中分别有key、query、value（一般key=value），通过key、query之间的相似度，计算得到每个value对应的权值，再对所有value加权求和，得到一整个序列的表征。其中对于自己本身的注意力机制称为self-attention（自注意力机制），即key=value=query</strong></li></ul><h3 id="1-1-Scaled-Dot-Product-Attention-点积"><a href="#1-1-Scaled-Dot-Product-Attention-点积" class="headerlink" title="1.1 Scaled Dot-Product Attention(点积)"></a>1.1 Scaled Dot-Product Attention(点积)</h3><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220512112222285.png" alt="image-20220512112222285" style="zoom: 37%;" /></p><ul><li>在计算时，我们是将query、key、value（分别为<script type="math/tex">d_k, d_k, d_v</script>维）打包成Q，K<script type="math/tex">\in R^{N \times d_k}</script>，V<script type="math/tex">\in R^{N \times d_v}</script>，具体做法是：</li></ul><blockquote><p>将送进来的输入input<script type="math/tex">\in R^{N \times d_{model} }</script>（其中<script type="math/tex">d_{model}</script>为embedding的维度，且q、k、v三者的input可能各自不同），input分别乘<script type="math/tex">W^Q、W^K \in R^{d_{model} \times d_k}</script>，<script type="math/tex">W^V \in R^{ {d_{model} \times d_v} }</script>即可得到Q、K、V</p></blockquote><ul><li>在计算权值时，将Q、K相乘，再除以<script type="math/tex">\sqrt{d_k}</script>，再softmax得到权值。<strong>除以<script type="math/tex">\sqrt{d_k}</script>的原因</strong>：</li></ul><blockquote><p><strong>维度过大会使Q、K相乘的结果过大，容易把softmax的区域推向梯度极小的区域。并且实验证明在<script type="math/tex">d_k</script>较小时，其实除不除效果差不多</strong></p></blockquote><ul><li>得到权重后再和V相乘，总过程为：</li></ul><script type="math/tex; mode=display">\operatorname{Attention}(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T} }{\sqrt{d_{k} }}\right) V</script><ul><li>还有一种较常用的注意力机制叫Additive attention， 是使用一个单隐藏层的全连接网络计算权重，两者效果差不多，<strong>但是dot-product会快得多</strong></li></ul><h3 id="1-2-Multi-Head-Attention-多头注意力机制"><a href="#1-2-Multi-Head-Attention-多头注意力机制" class="headerlink" title="1.2 Multi-Head Attention(多头注意力机制)"></a>1.2 Multi-Head Attention(多头注意力机制)</h3><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220512112235945.png" alt="image-20220512112235945" style="zoom:35%;" /></p><ul><li>多头注意力机制本质上就是<strong>做多次Scaled Dot-Product Attention</strong></li><li>具体做法是：</li></ul><blockquote><p><strong>重复做h次Scaled Dot-Product Attention（每次的W权重矩阵分别独立），将每次得到的结果<script type="math/tex">Z \in R^{N \times d_v}</script>在第二维连结，形状变为<script type="math/tex">R^{N \times hd_v}</script>，再乘一个<script type="math/tex">W^O \in R^{hd_v \times d_{model} }</script>，即可得到形状为<script type="math/tex">R^{N \times d_{model} }</script>的最终结果</strong></p></blockquote><ul><li>总过程为：</li></ul><script type="math/tex; mode=display">\begin{aligned}\operatorname{MultiHead}(Q, K, V) &=\operatorname{Concat}\left(\text { head }_{1}, \ldots, \text { head }_{\mathrm{h} }\right) W^{O} \\\text { where head } &=\operatorname{Attention}\left(Q W_{i}^{Q}, K W_{i}^{K}, V W_{i}^{V}\right)\end{aligned}</script><ul><li><p>在base模型中取的<script type="math/tex">h = 8</script>，且<script type="math/tex">d_k = d_v = d_{model}/h = 64</script></p></li><li><p><strong>多头注意力的好处：类似于CNN中的通道，能提取到不同子空间下的特征。多头注意力允许模型共同关注来自不同位置的不同表示子空间的信息。</strong>如果单纯使用单注意力头+平均化，会抑制这一点</p></li></ul><blockquote><p>Multi-head attention allows the model to jointly attend to information from different representation subspaces at different positions. With a single attention head, averaging inhibits this.  </p></blockquote><h3 id="1-3-自注意力机制的好处"><a href="#1-3-自注意力机制的好处" class="headerlink" title="1.3 自注意力机制的好处"></a>1.3 自注意力机制的好处</h3><ul><li><p>自注意力机制最大的好处肯定是实现了<strong>并行化，加快了训练速度</strong>。并且得到的结果相比于其他方法（如全局平均池化），<strong>更具有解释性</strong>，self-attention是可以退化成平均的，所以结果肯定好于平均。</p></li><li><p>论文从每层的总计算复杂度、可并行化的计算数量（用顺序操作的最小量来衡量）、长距离依赖的距离三个方面进行了对比：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220512114401561.png" alt="image-20220512114401561"></p><ul><li><strong>并且单个注意力头不仅清楚地学习执行不同的任务，而且许多似乎表现出与句子的句法和语义结构相关的行为</strong></li></ul><blockquote><p>Not only do individual attention heads clearly learn to perform different tasks, many appear to exhibit behavior related to the syntactic and semantic structure of the sentences  </p></blockquote><h1 id="2-模型结构"><a href="#2-模型结构" class="headerlink" title="2 模型结构"></a>2 模型结构</h1><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220512121448150.png" alt="image-20220512121448150" style="zoom:28%;" /></p><ul><li>图中多头注意力层的输入从左到右依次为V、K、Q</li></ul><h3 id="2-1-Encoder和Decoder"><a href="#2-1-Encoder和Decoder" class="headerlink" title="2.1 Encoder和Decoder"></a>2.1 Encoder和Decoder</h3><ul><li>Encoder由N=6个相同的块组成，每个块有两个子层，一个多头注意力层，一个全连接层，子层输入输出都是都是<script type="math/tex">R^{N \times d_{model} }</script>，其中N为时间步个数，也就是词数。<strong>并且在每个子层都有一个残差结构+LayerNorm</strong>，先残差后LayerNorm：</li></ul><script type="math/tex; mode=display">LayerNorm(x + Sublayer(x))</script><ul><li>Decoder同样是由N=6个相同的块组成，每个块有3个子层，有两个和Encoder中一模一样。增加了一个带Mask的多头注意力层。<strong>Decoder最开始的输入在训练时和预测时不一样</strong>，在<strong>训练时是把所有的翻译结果一次性输入</strong>，并行化提高速度。而<strong>预测时是类似于RNN一样的串行方式</strong>，第一次给Decoder输入句子的开始符号，然后得到第一个翻译结果，再将第一个翻译结果当作输入送入Decoder。总结来说就是：<strong>每次Decoder的输入为之前所有时间步的结果</strong>。而在训练时，是一次导入所有结果，所以需要<strong>Mask掉未来时间步的翻译结果</strong>。</li></ul><h3 id="2-2-多头注意力层"><a href="#2-2-多头注意力层" class="headerlink" title="2.2 多头注意力层"></a>2.2 多头注意力层</h3><ul><li><p>进行的操作其实就是上文提到的多头注意力机制：<strong>将输入分别乘一个矩阵W，转换成Q、K、V，再计算权重并加权平均，得到Z。将上述过程进行h次，每次使用的是相互独立的W，再将Z连结，再乘一个权重矩阵，得到最终结果。</strong></p></li><li><p>需要注意的是Decoder中的Masked Multi-Head Attention。我们在<strong>预测时，肯定是无法知道未来的信息的（也就是之后时间步的输出），但是在训练时我们是将翻译结果一次性使用一个矩阵导入的</strong>。所以为了保持一致性，我们需要在<strong>训练时屏蔽掉未来的信息，即当前时间步t的输出只取决于t-1及其之前的时间步。</strong></p></li><li>下方为一个Attention Map，每个单元代表该行对四个列对应的权值。如第一行代表”I”分别对”I”、”have”、”a”、”dream”的权值。</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/64.jpg" alt="64" style="zoom:50%;" /></p><p>显然在通过”I”预测”have”时，是不知道后面的”have”、”a”、”dream”的，所以需要通过Mask屏蔽掉未来的信息，其他时间步的时候类似：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/56.jpg" alt="56" style="zoom:50%;" /></p><p>上图就是经过Mask后的Attention Map，将每个时间步未来的信息进行了屏蔽，具体的做法是：<strong>在计算V的权重时，softmax之前将对应的值设为<script type="math/tex">-\infty</script></strong></p><h3 id="2-3-全连接层"><a href="#2-3-全连接层" class="headerlink" title="2.3 全连接层"></a>2.3 全连接层</h3><ul><li>每个全连接子层有两个层，进行的运算为：</li></ul><script type="math/tex; mode=display">\operatorname{FFN}(x)=\max \left(0, x W_{1}+b_{1}\right) W_{2}+b_{2}</script><p>第二层是没有激活函数的</p><ul><li>层的输入为<script type="math/tex">d_{model} = 512</script>，经过第一层变为<script type="math/tex">d_{ff} = 2048</script>，经过第二层又变为512维。</li></ul><h3 id="2-4-Layer-Normalization"><a href="#2-4-Layer-Normalization" class="headerlink" title="2.4 Layer Normalization"></a>2.4 Layer Normalization</h3><ul><li><p>BN是对一个batch-size样本内的每个特征做归一化，LN是对每个样本的每个时间步中所有特征做归一化</p></li><li><p><strong>使用LN，假设输入X，X.shape = (batch_size,time_step,embedding_dim) 那么mean.shape = std.shape = (batch_size,time_step,1)。即对embedding维做归一化，另外LN中同样是有放缩的参数的</strong></p></li><li><p>而使用BN，那么mean.shape = std.shape = (1,time_step,embedding_dim)，即对batch维做归一化</p></li><li><p><strong>选用LN而弃用BN的原因：</strong>BN需要较大的batch_size来保证对于期望、方差的统计的可靠性，对于CNN、Dense层来说则好统计。但是在天然变长的NLP任务中，如果选用BN需要<strong>对每个时间步的状态进行统计</strong>，这会导致在偏长的序列中，<strong>靠后的时间步的统计量不足</strong>。相比之下使用LN则不会有这种限制</p></li><li><p><strong>而对embedding层进行归一化也更具有解释性，因为embedding层的每个值都是直接相关的</strong></p></li></ul><h3 id="2-5-词嵌入"><a href="#2-5-词嵌入" class="headerlink" title="2.5 词嵌入"></a>2.5 词嵌入</h3><ul><li>Transformer中的embedding是训练出来的，所以总的结构类似于跳字模型或者连续词袋模型，具体可看<a href="https://zlkqz.top/2022/02/20/NLP%E5%9F%BA%E7%A1%80/#1-2-%E8%B7%B3%E5%AD%97%E6%A8%A1%E5%9E%8B%EF%BC%88skip-gram%EF%BC%89">跳字模型</a>中的具体实现，简单来说就是：一个单隐藏层的全连接网络，输入one-hot向量，乘一个V矩阵，得到隐藏层值，再乘一个U矩阵，得到输入层值，再softmax计算概率最后梯度下降。<strong>而Decoder的前后就是分别为乘V和乘U两个操作，分别称为embedding转换和pre-softmax linear transformation</strong></li><li>在一般的词嵌入模型当中，U、V矩阵一般是两个不同的矩阵，而Transformer中使用了<strong>Weight Tying</strong>，即U、V使用同一矩阵<strong>（注意只是共用权重矩阵，偏差还是相互独立的）</strong></li><li>one-hot向量和对U的操作是“指定抽取”，即取出某个单词的向量行；pre-softmax对V的操作是“逐个点积”，对隐层的输出，依次计算其和每个单词向量行的变换结果。虽然具体的操作不同，<strong>但在本质上，U和V都是对任一的单词进行向量化表示，然后按词表序stack起来。因此，两个权重矩阵在语义上是相通的</strong>。</li><li>也是由于上面两种操作方式的不同，且V的更新在靠近输出层，所以<strong>U在反向传播中不如V训练得充分</strong>，将两者绑定在一起缓和了这一问题，可以训练得到质量更高的新矩阵。并且<strong>Weight Tying 可以显著减小模型的参数量</strong>。</li><li>在embdding层中，<strong>为了让embedding层的权重值不至于过小，乘以<script type="math/tex">\sqrt{d_{model} }</script>后与位置编码的值差不多，可以保护原有向量空间不被破坏</strong>。</li></ul><h3 id="2-6-Positional-Encode"><a href="#2-6-Positional-Encode" class="headerlink" title="2.6 Positional Encode"></a>2.6 Positional Encode</h3><ul><li>由于模型摒弃了RNN结构，所以<strong>无法获得序列的位置信息</strong>，而为了获得这种位置信息我们需要引入Positional Embedding来表示位置信息。</li><li>Positional Embedding的维度同样是<script type="math/tex">d_{model}</script>，并且在一开始的时候和Embedding进行相加，具体表示为：</li></ul><script type="math/tex; mode=display">\begin{aligned}P E_{(p o s, 2 i)} &=\sin \left(p o s / 10000^{2 i / d_{\text {model } }}\right) \\P E_{(p o s, 2 i+1)} &=\cos \left(p o s / 10000^{2 i / d_{\text {model } }}\right)\end{aligned}</script><p>其中pos代表第几个序列位置（最大值为规定的最长序列长度），i代表第几个维度（最大值为<script type="math/tex">d_{mdoel} / 2</script>）</p><ul><li>以上公式不仅能很好的表示单词的绝对位置，还能表示出相对位置：<strong>相隔 k 个词的两个位置 pos 和 pos+k 的位置编码是由 k 的位置编码定义的一个线性变换</strong>：</li></ul><script type="math/tex; mode=display">\begin{array}{c}P E(p o s+k, 2 i)=P E(p o s, 2 i) P E(k, 2 i+1)+P E(p o s, 2 i+1) P E(k, 2 i) \\P E(p o s+k, 2 i+1)=P E(p o s, 2 i+1) P E(k, 2 i+1)-P E(p o s, 2 i) P E(k, 2 i)\end{array}</script><ul><li>采用正弦方式和学习方式position embedding结果几乎一样。但采用正弦，因为<strong>能让模型推断出比训练期间遇到的序列长度更长的序列长度</strong></li></ul><h1 id="3-模型训练"><a href="#3-模型训练" class="headerlink" title="3 模型训练"></a>3 模型训练</h1><h3 id="3-1-Optimizer-amp-amp-learning-rate"><a href="#3-1-Optimizer-amp-amp-learning-rate" class="headerlink" title="3.1 Optimizer &amp;&amp; learning rate"></a>3.1 Optimizer &amp;&amp; learning rate</h3><ul><li><p>采用Adam优化器，参数都是模型参数：<script type="math/tex">\beta_1=0.9,\beta_2=0.98,\epsilon=10^{-9}</script></p></li><li><p>Transformer 的学习率更新公式叫作“<strong>noam</strong>”，它将 warmup 和 decay 两个部分组合在一起，总体趋势是<strong>先增加后减小</strong>，具体公式为：</p></li></ul><script type="math/tex; mode=display">\text { lrate }=d_{\text {model } }^{-0.5} \cdot \min \left(\text { step }_{-} \text {num }^{-0.5}, \text { step_ }_{-} \text {num } \cdot \text { warmup_steps }^{-1.5}\right)</script><ul><li>公式实际上是一个以warmup_steps为分界点的分段函数。该点之前是warmup部分，采用线性函数的形式，且warmup_steps越大，斜率越小。该点之后是decay部分，采用负幂的衰减形式，衰减速度先快后慢：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-7c98b2c7ca4467ab770da064bb2b58ba_720w.jpg" alt="v2-7c98b2c7ca4467ab770da064bb2b58ba_720w"  /></p><ul><li><strong>设置warmup的原因：</strong>在CV领域中常常这样做，在《Deep Residual Learning for Image Recognition》中，作者训练110层的超深网络是就用过类似策略：</li></ul><blockquote><p>In this case, we find that <strong>the initial learning rate of 0.1 is slightly too large to start converging</strong>. So we use 0.01 to warm up the training until the training error is below 80% (about 400 iterations), and then go back to 0.1 and continue training.</p></blockquote><p>对于 Transformer 这样的大型网络，<strong>在训练初始阶段，模型尚不稳定，较大的学习率会增加收敛难度</strong>。因此，使用较小的学习率进行 warmup，等 loss 下降到一定程度后，再恢复回常规学习率。</p><h3 id="3-2-Dropout"><a href="#3-2-Dropout" class="headerlink" title="3.2 Dropout"></a>3.2 Dropout</h3><ul><li>在每个子块中，输出结果加入到残差结构和layer normalization之前，进行Dropout</li><li>并且还在Encoder和Decoder最开始的两种embedding相加的时候，使用了Dropout</li><li>Dropout的概率均为0.1</li></ul><h3 id="3-3-Label-Smoothing"><a href="#3-3-Label-Smoothing" class="headerlink" title="3.3 Label Smoothing"></a>3.3 Label Smoothing</h3><ul><li>为了不要对正确类别”too confident”（防止过拟合），Transformer中还使用了Label Smoothing。这种方法<strong>会增大困惑度（perplexity），但是可以提高accuracy和BLEU</strong>。</li><li>假设目标类别为y，任意类别为k，ground-truth 分布为q(k)，模型预测分布为p(k)。 显然，当k=y时，q(k)=1。当k<script type="math/tex">\neq</script>y时，q(k)=0。<strong>LSR（Label Smoothing Regularization）为了让模型的输出不要过于贴合单点分布，选择在gound-truth中加入噪声</strong>。即削弱y的概率，并整体叠加一个独立于训练样例的均匀分布u(k)：</li></ul><script type="math/tex; mode=display">q^{\prime}(k)=(1-\epsilon) q(k)+\epsilon u(k)=(1-\epsilon) q(k)+\epsilon / K</script><p>其中K为softmax的类别数，拆开来看就是：</p><script type="math/tex; mode=display">\begin{array}{ll}q^{\prime}(k)=1-\epsilon+\epsilon / K, & k=y \\q^{\prime}(k)=\epsilon / K, & k \neq y\end{array}</script><p>所有类别的概率和仍然是归一的。说白了就是把最高点砍掉一点，多出来的概率平均分给所有人。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NLP基础</title>
    <link href="/2022/01/08/NLP%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/08/NLP%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-词嵌入（word-embedding）"><a href="#1-词嵌入（word-embedding）" class="headerlink" title="1 词嵌入（word embedding）"></a>1 词嵌入（word embedding）</h1><ul><li>词向量是⽤来表示词的向量，也可被认为是词的特征向量或表征。把词映射为实数域向量的技术也叫词嵌⼊（word embedding）</li></ul><h3 id="1-1-词嵌入相比于one-hot向量的优点"><a href="#1-1-词嵌入相比于one-hot向量的优点" class="headerlink" title="1.1 词嵌入相比于one-hot向量的优点"></a>1.1 词嵌入相比于one-hot向量的优点</h3><ul><li>虽然one-hot词向量构造起来很容易，但通常并不是⼀个好选择。⼀个主要的原因是，<strong>one-hot词 向量⽆法准确表达不同词之间的相似度</strong>，如我们常常使⽤的余弦相似度。对于向量<script type="math/tex">x, y \in R^d</script>，它 们的余弦相似度是它们之间夹⻆的余弦值：</li></ul><script type="math/tex; mode=display">\frac{\boldsymbol{x}^{\top} \boldsymbol{y}}{\|\boldsymbol{x}\|\|\boldsymbol{y}\|} \in[-1,1]</script><p>由于任何两个不同词的one-hot向量的余弦相似度都为0，多个不同词之间的相似度难以通过one-hot向量准确地体现出来。</p><p>word2vec⼯具的提出正是为了解决上⾯这个问题。它将每个词表示成⼀个定⻓的向量，并使得这些向量能较好地表达不同词之间的相似和类⽐关系。word2vec⼯具包含了两个模型，即<strong>跳字模型（skip-gram）</strong> 和<strong>连续词袋模型（continuous bag of words，CBOW）</strong></p><h3 id="1-2-跳字模型（skip-gram）"><a href="#1-2-跳字模型（skip-gram）" class="headerlink" title="1.2 跳字模型（skip-gram）"></a>1.2 跳字模型（skip-gram）</h3><ul><li>跳字模型假设基于某个词来生成它在⽂本序列周围的词</li><li>举个例子，假设⽂本序列是 “the” “man” “loves” “his” “son”。以“loves”作为中⼼词，设背景窗口大小为2。如下图所示，跳字模型所关⼼的是，给定中⼼词“loves”，生成与它距离不超过2个词的背景词 “the” “man” “his” “son”的条件概率，即：</li></ul><script type="math/tex; mode=display">P(the, man, his, son | loves)</script><p>假设给定中⼼词的情况下，背景词的生成是相互独⽴的，那么上式可以改写成：</p><script type="math/tex; mode=display">P(the| loves) \times P(man | loves) \times P(his | loves) \times P(son | loves)</script><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220125151903218.png" alt="image-20220125151903218" style="zoom: 80%;" /></p><ul><li>在跳字模型中，<strong>每个词被表示成两个<script type="math/tex">d</script>维向量</strong>，⽤来计算条件概率。假设这个词在词典中索引为<script type="math/tex">i</script>， 当它为中心词时向量表示为<script type="math/tex">v_i \in R^d</script>，而为背景词时向量表示为<script type="math/tex">u_i \in R^d</script>。设中⼼词<script type="math/tex">w_c</script>在词典中索引为<script type="math/tex">c</script>，背景词<script type="math/tex">w_o</script>在词典中索引为<script type="math/tex">o</script>，<strong>给定中⼼词<script type="math/tex">w_c</script>生成背景词<script type="math/tex">w_o</script>的条件概率可以通过对向量内积做softmax运算而得到：</strong></li></ul><script type="math/tex; mode=display">P\left(w_{o} \mid w_{c}\right)=\frac{\exp \left(\boldsymbol{u}_{o}^{\top} \boldsymbol{v}_{c}\right)}{\sum_{i \in \mathcal{V}} \exp \left(\boldsymbol{u}_{i}^{\top} \boldsymbol{v}_{c}\right)},</script><p>其中词典索引集<script type="math/tex">V = \{0, 1, . . . , |V|−1\}</script></p><ul><li>假设给定⼀个⻓度为T的⽂本序列，设时间步t的词为<script type="math/tex">w^{(t)}</script>。 假设给定中⼼词的情况下背景词的生成相互独⽴，当背景窗口大小为m时，跳字模型的<strong>似然函数</strong>即给定任⼀中⼼词生成所有背景词的概率：</li></ul><script type="math/tex; mode=display">\prod_{t=1}^{T} \prod_{-m \leq j \leq m, j \neq 0} P\left(w^{(t+j)} \mid w^{(t)}\right),</script><p>这⾥小于1或大于T的时间步可以被忽略</p><ul><li><strong>跳字模型的训练：</strong></li></ul><blockquote><ul><li><strong>跳字模型的参数是每个词所对应的中心词向量和背景词向量</strong></li><li>先把把最大似然函数取负对数：</li></ul><script type="math/tex; mode=display">-\sum_{t=1}^{T} \sum_{-m \leq j \leq m, j \neq 0} \log P\left(w^{(t+j)} \mid w^{(t)}\right)</script><p>如果使⽤随机梯度下降，那么在每⼀次迭代⾥我们随机采样⼀个较短的子序列来计算有关该子序列的损失，然后计算梯度来更新模型参数</p><ul><li>由Softmax的运算结果可以得到：</li></ul><script type="math/tex; mode=display">\log P\left(w_{o} \mid w_{c}\right)=\boldsymbol{u}_{o}^{\top} \boldsymbol{v}_{c}-\log \left(\sum_{i \in \mathcal{V}} \exp \left(\boldsymbol{u}_{i}^{\top} \boldsymbol{v}_{c}\right)\right)</script><p>那么我们可以求得上式关于各中心词向量和背景词向量的梯度，比如关于<script type="math/tex">v_c</script>的梯度：</p><script type="math/tex; mode=display">\frac{\partial \log P\left(w_{o} \mid w_{c}\right)}{\partial v_{c}}=\boldsymbol{u}_{o}-\sum_{j \in \mathcal{V}} P\left(w_{j} \mid w_{c}\right) \boldsymbol{u}_{j} .</script><p>训练结束后，对于词典中的任⼀索引为<script type="math/tex">i</script>的词，我们均得到该词作为中⼼词和背景词的两组词向量<script type="math/tex">v_i</script>和<script type="math/tex">u_i</script>。在⾃然语⾔处理应⽤中，<strong>⼀般使⽤跳字模型的中心词向量作为词的表征向量</strong></p></blockquote><ul><li><strong>跳字模型的具体实现：</strong></li></ul><blockquote><ul><li>可以用一个input-hidden-output的三层神经网络来建模上面的skip-model：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/20190526195633208.jpg" alt="在这里插入图片描述" style="zoom: 50%;" /></p><ul><li><p>输入的表示：输入层中每个词由独热编码方式表示，即所有词均表示成一个N维向量，其中N为词汇表中单词的总数。在向量中，每个词都将与之对应的维度置为1,其余维度的值均为0</p></li><li><p>网络中传播的前向过程：输出层向量的值可以通过<strong>隐含层向量（K维，即每一个词向量的维度）</strong>，以及连接隐藏层和输出层之间的<strong>KxN维权重矩阵</strong>计算得到。输出层也是一个N维向量，每维与词汇表中的一个单词相对应。最后对输出层向量应用Softmax激活函数，可以计算每一个单词的生成概率。</p></li><li><strong>input层和hidden层之间的N<script type="math/tex">\times</script>K权重矩阵即N个词的中心词向量，从input层到hidden层的运算即对中心词向量的提取，具体见下图。而hidden层和output层之间的K<script type="math/tex">\times</script>N权重矩阵即N个词的背景词向量，hidden层到output层的运算即实现<script type="math/tex">u^T_ov_c</script>，然后再在最后做一个softmax</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/20190526202027163.jpg" alt="在这里插入图片描述" style="zoom: 67%;" /></p><p>左边矩阵是input，右边矩阵是input到hidden的权重矩阵，即N个词的中心词向量，由于输入是ont-hot向量，所以运算结果其实就是对中心词向量的一个提取</p><ul><li>在代码实现中是直接使用一个<strong>嵌入层（Embedding层）</strong>，此层的权值形状为<strong>词典大小<script type="math/tex">\times</script>每个词的维度</strong>，可以直接将中心词和背景词对应的one-hot向量转化为词向量。以skip-gram举例，中心词的one-hot向量形状为(批量大小，1)，背景词为(批量大小，词典大小)，两者皆通过嵌入层转化成词向量后形状分别为(批量大小，1，每个词维度)、(批量大小，词典大小，每个词维度)。然后通过<strong>小批量乘法</strong>实现中心词向量和背景词向量的相乘<script type="math/tex">u^T_ov_c</script>，得到形状为(批量大小，词典大小)的结果，然后进行Softmax</li><li>上面的背景词one-hot向量第二维度不一定要为词典大小，如果我们采用<strong>负采样</strong>，则应该改为<strong>正负样本和的大小</strong>，具体可看下方负采样原理</li><li>现在我们来解释一下<strong>小批量乘法</strong>，假设第⼀个小批量包含n个形状为<script type="math/tex">a \times b</script>的矩阵<script type="math/tex">X_1, . . . , X_n</script>，第⼆个小批量包含n个形状为<script type="math/tex">b \times c</script>的矩阵<script type="math/tex">Y_1, . . . , Y_n</script>。 这两个小批量的矩阵乘法输出为n个形状为<script type="math/tex">a \times c</script>的矩阵<script type="math/tex">X_1Y_1, . . . , X_nY_n</script></li></ul></blockquote><h3 id="1-3-连续词袋模型（CBOW）"><a href="#1-3-连续词袋模型（CBOW）" class="headerlink" title="1.3 连续词袋模型（CBOW）"></a>1.3 连续词袋模型（CBOW）</h3><ul><li><p>连续词袋模型与跳字模型类似。与跳字模型最大的不同在于，<strong>连续词袋模型假设基于某中⼼词在 ⽂本序列前后的背景词来生成该中心词</strong></p></li><li><p>如下图，在同样的⽂本序列“the” “man” “loves” “his” “son” ⾥，以“loves”作为中⼼词，且背景窗口大小为2时，连续词袋模型关心的是，给定背景词 “the” “man” “his” “son”生成中心词“loves”的条件概率，也就是：</p></li></ul><script type="math/tex; mode=display">P(loves|the,man,his,son)</script><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220125172417014.png" alt="image-20220125172417014" style="zoom:80%;" /></p><ul><li><p>因为连续词袋模型的背景词有多个，我们<strong>将这些背景词向量取平均</strong>，然后使⽤和跳字模型⼀样的 ⽅法来计算条件概率</p><p>设<script type="math/tex">v_i \in R^d</script>和<script type="math/tex">u_i \in R^d</script>分别表示词典中索引为<script type="math/tex">i</script>的词作为背景词和中⼼词的向 量（<strong>注意符号的含义与跳字模型中的相反</strong>）。设中⼼词<script type="math/tex">w_c</script>在词典中索引为<script type="math/tex">c</script>，背景词<script type="math/tex">w_{o1} , . . . , w_{o2m}</script>在 词典中索引为<script type="math/tex">o_1, . . . , o_{2m}</script>，那么给定背景词生成中⼼词的条件概率：</p><script type="math/tex; mode=display">.P\left(w_{c} \mid w_{o_{1}}, \ldots, w_{o_{2 m}}\right)=\frac{\exp \left(\frac{1}{2 m} \boldsymbol{u}_{c}^{\top}\left(\boldsymbol{v}_{o_{1}}+\ldots+\boldsymbol{v}_{o_{2 m}}\right)\right)}{\sum_{i \in \mathcal{V}} \exp \left(\frac{1}{2 m} \boldsymbol{u}_{i}^{\top}\left(\boldsymbol{v}_{o_{1}}+\ldots+\boldsymbol{v}_{o_{2 m}}\right)\right)}</script><p>设<script type="math/tex">W_o = \{w_{o1} , . . . , w_{o2m}\}</script>，<script type="math/tex">\overline{\boldsymbol{v}}_{o}=\left(\boldsymbol{v}_{o_{1}}+\ldots+\boldsymbol{v}_{o_{2 m}}\right) /(2 m)</script>，可将上式简化为：</p><script type="math/tex; mode=display">P\left(w_{c} \mid \mathcal{W}_{o}\right)=\frac{\exp \left(\boldsymbol{u}_{c}^{\top} \overline{\boldsymbol{v}}_{o}\right)}{\sum_{i \in \mathcal{V}} \exp \left(\boldsymbol{u}_{i}^{\top} \overline{\boldsymbol{v}}_{o}\right)}</script></li><li><p>给定⼀个⻓度为T的⽂本序列，设时间步t的词为<script type="math/tex">w^{(t)}</script>，背景窗口大小为m。连续词袋模型的似然函数是由背景词生成任⼀中⼼词的概率：</p></li></ul><script type="math/tex; mode=display">\prod_{t=1}^{T} P\left(w^{(t)} \mid w^{(t-m)}, \ldots, w^{(t-1)}, w^{(t+1)}, \ldots, w^{(t+m)}\right)</script><ul><li>接着再像跳字模型一样求似然函数的负对数，然后再求关于背景向量和中心向量的梯度。<strong>同跳字模型不⼀样的⼀点在于，我们⼀般使⽤连续词袋模型的背景词向量作为词的表征向量</strong></li></ul><ul><li><strong>跳字模型更适合大型语料库，CBOW更适合小型的语料库</strong></li></ul><h3 id="1-4-近似训练"><a href="#1-4-近似训练" class="headerlink" title="1.4 近似训练"></a>1.4 近似训练</h3><ul><li>无论是跳字模型还是连续词袋模型，在求梯度的时候，由于条件概率使⽤了softmax运 算，每⼀步的梯度计算都包含词典大小数⽬的项的累加。对于含⼏⼗万或上百万词的较大词典， 每次的梯度计算开销可能过大。为了降低该计算复杂度，本节将介绍两种近似训练⽅法，即<strong>负采样（negative sampling）</strong>或<strong>层序softmax（hierarchical softmax）</strong></li></ul><h5 id="1-4-1-高频词抽样"><a href="#1-4-1-高频词抽样" class="headerlink" title="1.4.1 高频词抽样"></a>1.4.1 高频词抽样</h5><ul><li>首先介绍一下对高频词进行抽样（也称⼆次采样(subsampling)）。对于文本中的高频词，比如”the”，不进行抽样会带来两个问题：</li></ul><blockquote><ol><li>当我们得到成对的单词训练样本时，<strong>(“fox”, “the”) 这样的训练样本并不会给我们提供关于“fox”更多的语义信息</strong>，因为“the”在每个单词的上下文中几乎都会出现</li><li>由于在文本中“the”这样的常用词出现概率很大，因此我们将会有大量的（”the“，…）这样的训练样本，而这些样本数量远远超过了我们学习“the”这个词向量所需的训练样本数</li></ol></blockquote><ul><li>Word2Vec通过“抽样”模式来解决这种高频词问题。它的基本思想如下：<strong>对于我们在训练原始文本中遇到的每一个单词，它们都有一定概率被我们从文本中删掉，而这个被删除的概率与单词的频率有关，词频越高被删除的概率就越大</strong></li></ul><h5 id="1-4-2-负采样（negative-sampling）"><a href="#1-4-2-负采样（negative-sampling）" class="headerlink" title="1.4.2 负采样（negative sampling）"></a>1.4.2 负采样（negative sampling）</h5><ul><li><strong>负采样（negative sampling）</strong>解决了因为词典大小过大的计算开销问题。不同于原本每个训练样本更新所有的权重，<strong>负采样每次让一个训练样本仅仅更新一小部分的权重</strong>，这样就会降低梯度下降过程中的计算量。</li><li>当我们用训练样本 ( input word: “fox”，output word: “quick”) 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的vocabulary大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们<strong>期望输出为0的神经元结点</strong>所对应的单词我们称为<strong>“negative” word</strong>。</li><li><p>当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重。我们也会对我们的“positive” word进行权重更新（在我们上面的例子中，这个单词指的是”quick“）。<strong>（在论文中，作者指出指出对于小规模数据集，选择5-20个negative words会比较好，对于大规模数据集可以仅选择2-5个negative words。）</strong></p></li><li><p><strong>每个单词被选为“negative words”的概率计算公式与其出现的频次有关，词频越高，被选上的概率就越高</strong>，论文中给的公式是：</p></li></ul><script type="math/tex; mode=display">P\left(w_{i}\right)=\frac{f\left(w_{i}\right)^{3 / 4}}{\sum_{j=0}^{n}\left(f\left(w_{j}\right)^{3 / 4}\right)}</script><ul><li><strong>负采样概述：</strong></li></ul><blockquote><ul><li>负采样修改了原来的⽬标函数。给定中⼼词<script type="math/tex">w_c</script>的⼀个背景窗口，我们把背景词<script type="math/tex">w_o</script>出现在该背景窗口看作⼀个事件，并将该事件的概率计算为：</li></ul><script type="math/tex; mode=display">P\left(D=1 \mid w_{c}, w_{o}\right)=\sigma\left(\boldsymbol{u}_{o}^{\top} \boldsymbol{v}_{c}\right)</script><ul><li>我们先考虑最大化⽂本序列中所有该事件的联合概率来训练词向量。具体来说，给定⼀个⻓度为T的⽂本序列，设时间步t的词为<script type="math/tex">w^{(t)}</script>且背景窗口大小为m，考虑最大化联合概率：</li></ul><script type="math/tex; mode=display">\prod_{t=1}^{T} \prod_{-m \leq j \leq m, j \neq 0} P\left(D=1 \mid w^{(t)}, w^{(t+j)}\right)</script><p>然而，以上模型中包含的事件仅考虑了正类样本。这导致当所有词向量相等且值为⽆穷大时，以上的联合概率才被最大化为1。很明显，这样的词向量毫⽆意义。<strong>负采样通过采样并添加负类样本使⽬标函数更有意义。</strong></p><ul><li>在采集了K个负样本后，我们可以将所求概率近似为：</li></ul><script type="math/tex; mode=display">P\left(w^{(t+j)} \mid w^{(t)}\right)=P\left(D=1 \mid w^{(t)}, w^{(t+j)}\right) \prod_{k=1, w_{k} \sim P(w)}^{K} P\left(D=0 \mid w^{(t)}, w_{k}\right)</script><ul><li>取负对数后变成了：</li></ul><script type="math/tex; mode=display">-\log P\left(w^{(t+j)} \mid w^{(t)}\right)=-\log \sigma\left(\boldsymbol{u}_{i_{t+j}}^{\top} v_{i_{t}}\right)-\sum_{k=1, w_{k} \sim P(w)}^{K} \log \sigma\left(-\boldsymbol{u}_{h_{k}}^{\top} v_{i_{t}}\right)</script><p>现在，<strong>训练中每⼀步的梯度计算开销不再与词典大小相关，而与K线性相关</strong>。当K取较小的常数时，负采样在每⼀步的梯度计算开销较小。</p></blockquote><ul><li><strong>负采样的具体实现：</strong></li></ul><blockquote><ul><li><p>在实际应用中，我们并没有严格的将不在窗口中的词定义为负样本，而是根据词频直接随机取负样本，这样的实验结果是更优的。</p></li><li><p><strong>设词典大小为<script type="math/tex">\mathcal{V}</script>，将一根长为1的线段分为<script type="math/tex">\mathcal{V}</script>段，每段分别对应一个词，每个词对应的长度就是上面所写的每个词对应的频率<script type="math/tex">P(w_i)</script>，然后取一个M（M&gt;&gt;<script type="math/tex">\mathcal{V}</script>），论文中M取的是<script type="math/tex">10^8</script>，将长度为1的线段均分为M份（如下图），然后取K个负样本即在该线段上取K个点，取到的点在哪个词的对应线段就取哪个词</strong></p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220211153340493.png" alt="image-20220211153340493" style="zoom:67%;" /></p></blockquote><h5 id="1-4-3-层序Softmax（hierarchical-softmax）"><a href="#1-4-3-层序Softmax（hierarchical-softmax）" class="headerlink" title="1.4.3 层序Softmax（hierarchical softmax）"></a>1.4.3 层序Softmax（hierarchical softmax）</h5><ul><li>层序softmax是另⼀种近似训练法。它使⽤了⼆叉树这⼀数据结构，树的每个叶结点代表词典<script type="math/tex">\mathcal{V}</script>中的每个词。</li><li><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220210181128975.png" alt="image-20220210181128975" style="zoom: 80%;" /></li></ul><p>假设<script type="math/tex">L(w)</script>为从⼆叉树的根结点到词<script type="math/tex">w</script>的叶结点的路径（包括根结点和叶结点）上的结点数。 设<script type="math/tex">n(w, j)</script>为该路径上第<script type="math/tex">j</script>个结点，并设该结点的背景词向量为<script type="math/tex">u_{n(w,j)}</script>。以上图为例，<script type="math/tex">L(w_3) = 4</script> 层序softmax将跳字模型中的条件概率近似表示为：</p><script type="math/tex; mode=display">P\left(w_{o} \mid w_{c}\right)=\prod_{j=1}^{L\left(w_{o}\right)-1} \sigma\left([[ n\left(w_{o}, j+1\right)=\operatorname{leftChild}\left(n\left(w_{o}, j\right)\right) ]] \cdot \boldsymbol{u}_{n\left(w_{o}, j\right)}^{\top} \boldsymbol{v}_{c}\right),</script><p>其中如果判断x为真，[[x]] = 1；反之[[x]] = −1。</p><p>例如让我们计算上图中给定词<script type="math/tex">w_c</script>生成词<script type="math/tex">w_3</script>的条件概率：</p><script type="math/tex; mode=display">P\left(w_{3} \mid w_{c}\right)=\sigma\left(\boldsymbol{u}_{n\left(w_{3}, 1\right)}^{\top} \boldsymbol{v}_{c}\right) \cdot \sigma\left(-\boldsymbol{u}_{n\left(w_{3}, 2\right)}^{\top} \boldsymbol{v}_{c}\right) \cdot \sigma\left(\boldsymbol{u}_{n\left(w_{3}, 3\right)}^{\top} \boldsymbol{v}_{c}\right)</script><ul><li><strong>推导过程：</strong></li></ul><blockquote><p>设<script type="math/tex">d_{2}^{w}, d_{3}^{w}, \cdots, d_{l w}^{w} \in\{0,1\}</script>为词<script type="math/tex">w</script>的编码，<script type="math/tex">d_j^w</script>代表<script type="math/tex">w</script>路径上的第<script type="math/tex">j</script>个节点对应的编码（根节点无编码），则：</p><script type="math/tex; mode=display">P(w_0|w_c) = \prod_{j=2}^{L(w)} P\left(d_{j}^{w} \mid v_c, u_{n_(w, j)}\right)</script><p>其中的每一项都是一个Logistic回归：</p><script type="math/tex; mode=display">P\left(d_{j}^{w} \mid v_c, u_{n_(w, j)}\right) = \left\{\begin{array}{ll}\sigma\left(v_c^T u_{n_(w, j)}\right), & d_{j}^{w}=0 \\1-\sigma\left(v_c^T u_{n_(w, j)}\right), & d_{j}^{w}=1\end{array}\right.</script><p>可以将两式合并，并且由于<script type="math/tex">\sigma(x) + \sigma(-x) = 1</script>，可以将上式转化为：</p><script type="math/tex; mode=display">P\left(d_{j}^{w} \mid v_c, u_{n_(w, j)}\right)=\left[\sigma\left(v_c^T u_{n_(w, j)}\right)\right]^{1-d_{j}^{w}} \cdot\left[\sigma\left(-v_c^T u_{n_(w, j)}\right)\right]^{d^{w}}</script><p>我们取目标函数的对数：</p><script type="math/tex; mode=display">\mathcal{L} = \sum_{w \in \mathcal{V}}\log P(Context(w) | w) = \sum_{w \in \mathcal{V}} \sum_{j=2}^{L(w)}\left\{\left(1-d_{j}^{w}\right) \cdot \log \left[\sigma\left(v_c^T u_{n_(w, j)}\right)\right]+d_{j}^{w} \cdot \log \left[\sigma\left(-v_c^T u_{n_(w, j)}\right)\right]\right\}</script><p><strong>要最大化上述目标函数是比较困难的，但是我们可以最大化每一子项（即下式），达到局部最大化的效果</strong>：</p><script type="math/tex; mode=display">\mathcal{L}(w, j) = \left\{\left(1-d_{j}^{w}\right) \cdot \log \left[\sigma\left(v_c^T u_{n_(w, j)}\right)\right]+d_{j}^{w} \cdot \log \left[\sigma\left(-v_c^T u_{n_(w, j)}\right)\right]\right\}</script><p><strong>这样就可以将计算复杂度降为<script type="math/tex">O(log_2 |\mathcal{V}|)</script>，当词典<script type="math/tex">\mathcal{V}</script>很大时，层序softmax在训练中每⼀步的梯度计算开销相较未使用近似训练时大幅降低。</strong></p><p>显然，上式的<script type="math/tex">d_j^w</script>是用来<strong>判断下一个节点是否是本节点的左孩子的</strong>，其作用是为了满足给定任意中心词<script type="math/tex">w_c</script>，生成背景词的条件概率和为1：</p><script type="math/tex; mode=display">\sum_{w \in \mathcal{V}} P\left(w \mid w_{c}\right)=1</script><p>这样才能使似然函数不至于训练到无穷大（和负采样要添加负样本是一样的原因），并且符合概率和为1</p></blockquote><ul><li><strong>层序Softmax中的二叉树是使用的哈夫曼树，可以使搜索次数达到最小</strong></li></ul><h1 id="2-子词嵌入（fastText）"><a href="#2-子词嵌入（fastText）" class="headerlink" title="2 子词嵌入（fastText）"></a>2 子词嵌入（fastText）</h1><ul><li>英语单词通常有其内部结构和形成⽅式。例如，我们可以从“dog” “dogs”和“dogcatcher”的 字面上推测它们的关系。这些词都有同⼀个词根“dog”，但使⽤不同的后缀来改变词的含义。而 且，这个关联可以推⼴⾄其他词汇。例如，“dog”和“dogs”的关系如同“cat”和“cats”的关 系，“boy”和“boyfriend”的关系如同“girl”和“girlfriend”的关系。这方面的研究称为构词学</li><li><p>在word2vec中，我们并没有直接利⽤构词学中的信息。⽆论是在跳字模型还是连续词袋模型中， 我们都将形态不同的单词⽤不同的向量来表示。例如，“dog”和“dogs”分别⽤两个不同的向量表示，而模型中并未直接表达这两个向量之间的关系。鉴于此，fastText提出了子词嵌⼊（subword embedding）的⽅法，从而试图将构词信息引⼊word2vec中的跳字模型</p></li><li><p>在fastText中，每个中⼼词被表⽰成子词的集合。举个例子，例如单词”where”，⾸先，我们在单词的<strong>⾸尾分别添加特殊字符“&lt;” 和  “&gt;” 以区分作为前后缀的子词</strong>。然后，<strong>将单词当成⼀个由字符构成的序列来提取n元语法</strong>。例如，当n = 3时，我们得到所有⻓度为3的子词：”<wh"、"whe"、"her"、"ere"、"re>“以及特殊子词”where”。</p></li><li>在fastText中，对于⼀个词w，我们将它所有⻓度在3 ∼ 6的子词和特殊子词的并集记为<script type="math/tex">\mathcal{G}_{w}</script>。<strong>那么词典则是所有词的子词集合的并集</strong>。假设词典中子词<script type="math/tex">g</script>的向量为<script type="math/tex">z_g</script>，那么跳字模型中词w的作为中⼼词的向量<script type="math/tex">v_w</script>则表⽰成：</li></ul><script type="math/tex; mode=display">v_{w}=\sum_{g \in \mathcal{G}_{w}} z_{g}</script><ul><li>fastText的其余部分同跳字模型⼀致，不在此重复。可以看到，<strong>与跳字模型相⽐，fastText中词典 规模更大，造成模型参数更多</strong>，同时⼀个词的向量需要对所有子词向量求和，继而导致<strong>计算复杂度更高</strong>。但与此同时，<strong>较生僻的复杂单词，甚⾄是词典中没有的单词，可能会从同它结构类似的 其他词那⾥获取更好的词向量表示。</strong></li></ul><h1 id="3-全局向量的词嵌入（GloVe）"><a href="#3-全局向量的词嵌入（GloVe）" class="headerlink" title="3 全局向量的词嵌入（GloVe）"></a>3 全局向量的词嵌入（GloVe）</h1><ul><li>在词嵌入中，交叉熵损失函数有时并不是一个好的选择。一方面，正如上面所说，<strong>会带来整个词典大小的累加项，带来过大的计算开销</strong>。另一方面，<strong>词典中往往有大量生僻词，它们在数据集中出现的次数极少。而有关大量生僻词的条件概率分布在交叉熵损失函数中的最终预测往往并不准确。</strong></li><li>GloVe模型既使用了语料库的全局统计（overall statistics）特征，也使用了局部的上下文特征（即滑动窗口）。为了做到这一点GloVe模型引入了<strong>共现矩阵（Cooccurrence Probabilities Matrix）</strong></li></ul><h3 id="3-1-共现矩阵"><a href="#3-1-共现矩阵" class="headerlink" title="3.1 共现矩阵"></a>3.1 共现矩阵</h3><ul><li><p>假设：</p><blockquote><ol><li>共现矩阵为<script type="math/tex">X</script>，<script type="math/tex">X</script>中的元素<script type="math/tex">X_{ij}</script>为语料库中<script type="math/tex">word_i</script>上下文中出现<script type="math/tex">word_j</script>的次数</li><li><script type="math/tex">X_i = \sum_k X_{ik}</script>是出现在<script type="math/tex">word_i</script>上下文中所有词的总次数</li><li><script type="math/tex">P_{ij} = P(j|i) = \frac{X_{ij}}{X_i}</script>为<script type="math/tex">word_j</script>出现在<script type="math/tex">word_i</script>上下文的概率</li></ol></blockquote></li><li><p>下面我们来举个例子：</p></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220211235403111.png" alt="image-20220211235403111" style="zoom:80%;" /></p><p>设Ratio = <script type="math/tex">\frac{P_{ik}}{P_{jk}}</script>，，从上面的例子中我们可以总结出：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220211235553030.png" alt="image-20220211235553030"></p><p><strong>所以Ratio可以反应word之间的相关性，而GloVe就是利用了这个值</strong></p><p>假设<script type="math/tex">i, j, k</script>三者的词向量都已经得到<script type="math/tex">w_i, w_j, w_k</script>，那么我们现在就要找一个函数F，使得：</p><script type="math/tex; mode=display">F\left(w_{i}, w_{j}, w_{k}\right)=\frac{P_{i k}}{P_{j k}}</script><h3 id="3-2-损失函数推导"><a href="#3-2-损失函数推导" class="headerlink" title="3.2 损失函数推导"></a>3.2 损失函数推导</h3><ul><li><p><strong>上述等式的右边是通过统计得到的已知量，左侧的三个词向量<script type="math/tex">w_i, w_j, w_k</script>是模型要求的量，F是未知的，如果能够将F的形式确定下来， 那么我们就可以通过优化算法求解词向量了，下面是求解过程</strong></p></li><li><p><script type="math/tex">\frac{P_{i k}}{P_{j k}}</script>考察了<script type="math/tex">i,j,k</script>三个词的相关性，不妨先只考虑<script type="math/tex">i,j</script>两个词的词向量<script type="math/tex">w_i, w_j</script>的相关性，向量相关关系的度量可以用两个向量的差，所以上述等式可以先改为：</p></li></ul><script type="math/tex; mode=display">F\left((w_{i}-w_{j}), w_{k}\right)=\frac{P_{i k}}{P_{j k}}</script><ul><li>由于右边是标量，左边是向量，所以可以联想到使用向量的内积转化为标量：</li></ul><script type="math/tex; mode=display">F\left(\left(w_{i}-w_{j}\right)^{T} w_{k}\right)=F\left(w_{i}^{T} w_{k}-w_{j}^{T} w_{k}\right)=\frac{P_{i k}}{P_{j k}}</script><ul><li>因为左边是差，右边是商，所以将F设为exp运算，将差转化为商：</li></ul><script type="math/tex; mode=display">\exp \left(w_{i}^{T} w_{k}-w_{j}^{T} w_{k}\right)=\frac{\exp \left(w_{i}^{T} w_{k}\right)}{\exp \left(w_{j}^{T} w_{k}\right)}=\frac{P_{i k}}{P_{j k}}</script><ul><li>现在只需让分子分母分别相等就能成立：</li></ul><script type="math/tex; mode=display">\exp \left(w_{i}^{T} w_{k}\right)= \alpha P_{i k}, \exp \left(w_{j}^{T} w_{k}\right)= \alpha P_{j k}，\quad  \alpha为常数</script><ul><li>现在只需要在整个词料库中考察<script type="math/tex">\exp \left(w_{i}^{T} w_{k}\right)= \alpha P_{i k}= \alpha \frac{X_{i k}}{X_{i}}</script>，即：</li></ul><script type="math/tex; mode=display">w_{i}^{T} w_{k}=\log \left(\alpha \frac{X_{i k}}{X_{i}}\right)=\log X_{i k}-\log X_{i} + log\alpha</script><ul><li>所以我们需要设置一个偏差项<script type="math/tex">b_i</script>来拟合<script type="math/tex">log X_i - log \alpha</script>，由于如果上式<script type="math/tex">i,k</script>位置交换，左式的值不变，但是右式的值会变，所以我们还要设置一个偏差项<script type="math/tex">b_k</script>，即：</li></ul><script type="math/tex; mode=display">w_{i}^{T} w_{k}  + b_i + b_k=log X_{ik}</script><ul><li>上面公式只是理想状态下，实际中只能要求两者接近    从而就有了代价函数：</li></ul><script type="math/tex; mode=display">J=\sum_{i, k}\left(w_{i}^{T} w_{k}+b_{i}+b_{k}-\log X_{i k}\right)^{2}</script><ul><li>如果两个词共同出现的次数越多，那么其在代价函数中的影响就越大，所以要设计一个权重函数：</li></ul><script type="math/tex; mode=display">J=\sum_{i, k} f\left(X_{i k}\right)\left(w_{i}^{T} w_{k}+b_{i}+b_{k}-\log X_{i k}\right)^{2}</script><blockquote><p>对于函数f要满足一下条件：</p><ol><li>如果两个词没有共同出现过，那么权重就是0，即f(0) = 0</li><li>两个词共同出现次数越多，那么权重就越大，所以f是一个递增函数</li><li>由一些于高频词（<script type="math/tex">X_{ij}较大</script>，如”the”）的权重很大，但是实际上作用并不是很大，所以f(x)对于较大的x不能取太大的值</li></ol><p>综合上方条件，论文提出了一下函数：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{array}{r}\left(\frac{x}{x_{\max }}\right)^{\alpha}, \text { if } x<x_{\max } \\1, \text { otherwise }\end{array}\right.</script><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220212005820238.png" alt="image-20220212005820238" style="zoom:67%;" /></p><p>作者认为<script type="math/tex">x_{max} = 100, \alpha = \frac{3}{4}</script>比较合适</p></blockquote><ul><li>值得强调的是，如果词<script type="math/tex">w_i</script>出现在词<script type="math/tex">w_j</script>的背景窗口里，那么词<script type="math/tex">w_j</script>也会出现在词<script type="math/tex">w_i</script>的背景窗口⾥。也就是说，<script type="math/tex">x_{ij} = x_{ji}</script>。不同于<strong>word2vec中拟合的是非对称的条件概率<script type="math/tex">p_{ij}</script>，GloVe模型拟合的是对称的<script type="math/tex">\log X _{ij}</script></strong>。因此，<strong>任意词的中心词向量和背景词向量在GloVe模型中是等价的。但由于初始化值的不同，同⼀个词最终学习到的两组词向量可能不同</strong>。当学习得到所有词向量以后，GloVe模型使⽤<strong>中心词向量与背景词向量之和作为该词的最终词向量，这样做是为了提高鲁棒性（两者的初始化不同相当于加了不同的随机噪声，所以能提高鲁棒性）</strong></li></ul><h1 id="4-词嵌入应用"><a href="#4-词嵌入应用" class="headerlink" title="4 词嵌入应用"></a>4 词嵌入应用</h1><ul><li>下列应用均为在训练好的预训练模型上进行训练的</li></ul><h3 id="4-1-求近义词和类比词"><a href="#4-1-求近义词和类比词" class="headerlink" title="4.1 求近义词和类比词"></a>4.1 求近义词和类比词</h3><ul><li>求近义词可以运用词向量之间的余弦相似度</li><li>求类比词，例如，“man”（男人）: “woman”（女人）:: “son”（儿子）: “daughter”（女儿）是⼀个类⽐例子。<strong>对于类比关系中的4个词 a : b :: c : d，给定前3个词a、b和c，求d。设词w的词向量为vec(w)。求类比词的思路是vec(a) - vec(b) = vec(c) - vec(d)，来求出vec(d)的近似值，然后寻找和其最相似的几个词向量</strong></li></ul><h3 id="4-2-使用循环神经网络进行文本情感分类"><a href="#4-2-使用循环神经网络进行文本情感分类" class="headerlink" title="4.2 使用循环神经网络进行文本情感分类"></a>4.2 使用循环神经网络进行文本情感分类</h3><ul><li>⽂本分类是⾃然语⾔处理的⼀个常⻅任务，它把⼀段不定⻓的⽂本序列变换为⽂本的类别。本节关 注它的⼀个子问题：使⽤⽂本情感分类来分析⽂本作者的情绪。这个问题也叫<strong>情感分析（sentiment analysis）</strong></li><li>本节我们使用电影评论的情感分析（二分类，positive和negtive的情感），在数据处理的时候，一条评论为一个样本，我们要先对评论进行分词（一般都是<strong>基于空格分词</strong>），并且由于每条评论的长度不一样，无法组成小批量，所以我们需要通过<strong>截断或者补充来使长度定长</strong></li><li>对于模型的设计，先需要一个<strong>嵌入层将文本转化为词向量</strong>，再通过<strong>双向循环网络对特征序列进⼀步编码得到序列信息</strong>，然后将<strong>最初时间步和最终时间步的隐藏状态连结</strong>，再传入全连接层输出</li><li>注意由于是预训练的模型，所以<strong>嵌入层的模型参数是不需要更新的</strong>，直接由训练好的模型参数导入即可。但是<strong>导入的模型的词向量维度要和预先设置的嵌入层词向量维度一致</strong></li></ul><h3 id="4-3-使用卷积神经网络（textCNN）进行文本情感分类："><a href="#4-3-使用卷积神经网络（textCNN）进行文本情感分类：" class="headerlink" title="4.3 使用卷积神经网络（textCNN）进行文本情感分类："></a>4.3 使用卷积神经网络（textCNN）进行文本情感分类：</h3><ul><li><p>我们可以将⽂本数据看作只有⼀个维度的时间序列，并很⾃然地使⽤循环神经⽹络来表征这样的数据。其实，我们也可以将⽂本当作⼀维图像，从而可以⽤⼀维卷积神经⽹络来捕捉临近词之间的关联</p></li><li><p><strong>textCNN基于的假设是：一个词和其相邻的词（即卷积核中的词）是相关的</strong></p></li></ul><h5 id="4-3-1-一维卷积层"><a href="#4-3-1-一维卷积层" class="headerlink" title="4.3.1 一维卷积层"></a>4.3.1 一维卷积层</h5><ul><li>和二维卷积层一样，一维卷积层卷积窗口从输⼊数组的最左⽅开始，按从左往右的顺序，依次在输⼊数组上滑动，举个例子：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220212155418239.png" alt="image-20220212155418239" style="zoom:67%;" /></p><p>输出中的2是由输入的前两个和核逐个相乘得到的：0x1+1x2=2，然后窗口往后滑动一格，以此类推</p><p>对于多通道操作也是和二维卷积层一样的：<br><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220212155747478.png" alt="image-20220212155747478"></p><p>每个通道分别操作，然后各通道结果相加。如果想要输出多通道，则核还要增加一个维度</p><h5 id="4-3-2-时序最大池化层"><a href="#4-3-2-时序最大池化层" class="headerlink" title="4.3.2 时序最大池化层"></a>4.3.2 时序最大池化层</h5><ul><li>假设输⼊包含多个通道，各通道由不同时间步上的数值组成，<strong>各通道的输出即该通道所有时间步中最⼤的数值</strong>。因此，<strong>时序最⼤池化层的输⼊在各个通道上的时间步数可以不同</strong></li><li>为提升计算性能，我们常常将不同⻓度的时序样本组成⼀个小批量，<strong>并通过在较短序列后附加特殊字符（如0）令批量中各时序样本⻓度相同</strong>。这些⼈为添加的特殊字符当然是⽆意义的。由于时序最⼤池化的主要⽬的是抓取时序中最重要的特征，它通常能<strong>使模型不受⼈为添加字符的影响</strong></li></ul><h5 id="4-3-3-textCNN模型"><a href="#4-3-3-textCNN模型" class="headerlink" title="4.3.3 textCNN模型"></a>4.3.3 textCNN模型</h5><ul><li>textCNN模型主要使⽤了⼀维卷积层和时序最⼤池化层。假设输⼊的⽂本序列由n个词组成，每 个词⽤d维的词向量表⽰。那么输⼊样本的宽为n，⾼为1，输⼊通道数为d。textCNN的计算主要分为以下⼏步：</li></ul><blockquote><ol><li>定义多个⼀维卷积核，并使⽤这些卷积核对输⼊分别做卷积计算。宽度不同的卷积核可能 会捕捉到不同个数的相邻词的相关性</li><li>对输出的所有通道分别做时序最⼤池化，再将这些通道的池化输出值连结为向量。</li><li>通过全连接层将连结后的向量变换为有关各类别的输出。这⼀步可以使⽤丢弃层应对过拟合。</li></ol></blockquote><ul><li>举个例子，这⾥的输⼊是⼀个有11个词的句子，每个词⽤6维词向量表⽰。因此输⼊序列的宽为11，输⼊通道数为6。给定2个⼀维卷积核，核宽分别为2和4，输出 通道数分别设为4和5</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220212161751535.png" alt="image-20220212161751535" style="zoom: 67%;" /></p><p><strong>尽管每个通道的宽不同，我们依然可以对各个通道做时序最⼤池化， 并将9个通道的池化输出连结成⼀个9维向量</strong>。最终，使⽤全连接将9维向量变换为2维输出，即正⾯情感和负⾯情感的预测</p><h1 id="5-机器翻译"><a href="#5-机器翻译" class="headerlink" title="5 机器翻译"></a>5 机器翻译</h1><ul><li><p>我们使用seq2seq模型进行机器翻译，原理具体可看<a href="https://zlkqz.top/2021/12/10/RNN/#7-Seq2Seq%E6%A8%A1%E5%9E%8B">seq2seq</a></p></li><li><p>这里我们只介绍一下如何评价翻译结果。评价机器翻译结果通常使⽤<strong>BLEU（Bilingual Evaluation Understudy）</strong>。对于模型预测序列中任意的子序列，BLEU考察这个子序列是否出现在标签序列中。</p></li><li>具体来说，设词数为n的⼦序列的精度为<script type="math/tex">p_n</script>。它是<strong>预测序列与标签序列匹配词数为n的⼦序列的数量与预测序列中词数为n的⼦序列的数量之⽐</strong>。举个例子，假设标签序列为A、B、C、D、E、F， 预测序列为A、B、B、C、D，那么<script type="math/tex">p_1 = 4/5, p_2 = 3/4, p_3 = 1/3, p_4 = 0</script>。设<script type="math/tex">len_{label}</script>和<script type="math/tex">len_{pred}</script>分 别为标签序列和预测序列的词数，那么，BLEU的定义为：</li></ul><script type="math/tex; mode=display">\exp \left(\min \left(0,1-\frac{\text { len }_{\text {label }}}{\text { len }_{\text {pred }}}\right)\right) \prod_{n=1}^{k} p_{n}^{1 / 2^{n}}</script><p>其中k是我们希望匹配的⼦序列的最⼤词数。可以看到当预测序列和标签序列完全⼀致时， BLEU为1。</p><ul><li>设计思想：</li></ul><blockquote><p>因为匹配较⻓⼦序列⽐匹配较短⼦序列更难，BLEU对匹配较⻓⼦序列的精度赋予了更⼤权重，具体是在上式的<script type="math/tex">p_n^{1/2^n}</script>中，当序列较长，即n较大时，由于<script type="math/tex">p_n \in [0, 1]</script>，所以<script type="math/tex">1/2^n</script>后会变大，并且n越大越接近1，即给较长序列更大的权重</p><p>并且由于较短序列一般会有比较大的<script type="math/tex">p_n</script>，所以连乘项前面的系数是为了惩罚较短的输出而设置的。举个例子，当<script type="math/tex">len_{pred}</script>较小时，连乘项前面的系数就会小于1，以此来减少较短序列的权重。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CV基础</title>
    <link href="/2021/12/16/CV%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/16/CV%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-图像增广"><a href="#1-图像增广" class="headerlink" title="1 图像增广"></a>1 图像增广</h1><ul><li>图像增⼴（image augmentation）技术通过对训练图像做⼀系列随机改变，来产⽣相似但⼜不同的训练样本，从而<strong>扩大训练数据集的规模</strong></li><li><p>随机改变训练样本可以<strong>降低模型对某些属性的依赖，从而提高模型的泛化能力</strong>。例如，我们可以对图像进⾏不同 方式的裁剪，使感兴趣的物体出现在不同位置，从而减轻模型对物体出现位置的依赖性</p></li><li><p>常用的方法有：<strong>翻转</strong>、<strong>裁剪</strong>、<strong>变换颜色</strong>。对于翻转，大部分情况左右翻转比上下翻转更通用一些。对于颜色，我们可以从亮度、对比度、饱和度和⾊调四方面进行改变</p></li><li>实际应⽤中我们会将多个图像增⼴方法叠加使⽤</li></ul><h1 id="2-微调"><a href="#2-微调" class="headerlink" title="2 微调"></a>2 微调</h1><ul><li><strong>迁移学习（transfer learning）</strong>：<strong>将从源数据集学到的知识迁移到目标数据集上</strong>。例如，虽然ImageNet数据集的图像大多跟椅⼦⽆关，但在该数据集上训练的模型可以抽 取较通⽤的图像特征，从而能够帮助识别边缘、纹理、形状和物体组成等。这些类似的特征对于 识别椅⼦也可能同样有效。</li><li>迁移学习中的一种常用技术“微调（<strong>fine tuning）</strong>”，由一下四步构成：</li></ul><blockquote><ol><li>在源数据集（如ImageNet数据集）上预训练⼀个神经⽹络模型，即源模型</li><li>创建⼀个新的神经⽹络模型，即目标模型。它复制了源模型上除了输出层外的所有模型设 计及其参数。我们假设这些模型参数包含了源数据集上学习到的知识，且这些知识同样适⽤于目标数据集。我们还假设源模型的输出层与源数据集的标签紧密相关，因此在目标模 型中不予采⽤。</li><li>为目标模型添加⼀个输出大小为目标数据集类别个数的输出层，并随机初始化该层的模型参数。</li><li>在目标数据集（如椅⼦数据集）上训练目标模型。我们将从头训练输出层，而其余层的参数都是基于源模型的参数微调得到的。</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123170934001.png" alt="image-20220123170934001" style="zoom: 67%;" /></p><ul><li>可以选择保留除输出层以外的所有层，也可以保留除临近输出层的几层以外的所有层</li><li>由于预训练模型是比较接近正确结果的，而新添加的层是随机初始化。<strong>所以两者的学习率是不同的，预训练的学习率更小</strong></li></ul></blockquote><h1 id="3-目标检测和边界框"><a href="#3-目标检测和边界框" class="headerlink" title="3 目标检测和边界框"></a>3 目标检测和边界框</h1><ul><li>很多时候图像⾥有多个我们感兴趣的目标，我们 不仅想知道它们的类别，还想得到它们在图像中的具体位置。在计算机视觉⾥，我们将这类任务 称为目标检测（object detection）或物体检测</li><li>在目标检测⾥，我们通常使⽤<strong>边界框（bounding box）</strong>来描述目标位置。边界框是⼀个矩形框， 可以由矩形左上⻆的x和y轴坐标与右下⻆的x和y轴坐标确定</li><li>它以每个像素为中⼼⽣ 成多个大小和宽高比（aspect ratio）不同的边界框。这些边界框被称为<strong>锚框（anchor box）</strong></li></ul><h3 id="3-1-锚框的生成"><a href="#3-1-锚框的生成" class="headerlink" title="3.1 锚框的生成"></a>3.1 锚框的生成</h3><ul><li>假设输⼊图像高为h，宽为w。我们分别以图像的每个像素为中⼼⽣成不同形状的锚框。设大小为s <script type="math/tex">\in</script> (0, 1]且宽高比为r &gt; 0，那么锚框的宽和高将分别为<script type="math/tex">ws\sqrt{r}</script>和<script type="math/tex">hs/\sqrt{r}</script>。当中⼼位置给定时，已 知宽和高的锚框是确定的。⾯我们分别设定好⼀组大小<script type="math/tex">s_1, . . . , s_n</script>和⼀组宽高比<script type="math/tex">r_1, . . . , r_m</script>，s和r两两配对能覆盖所有的真实边界框，但是计算复杂度容易更高，所以我们通常只对包含<script type="math/tex">s_1</script>或<script type="math/tex">r_1</script>的大小与宽高比的组合感兴趣，即：</li></ul><script type="math/tex; mode=display">\left(s_{1}, r_{1}\right),\left(s_{1}, r_{2}\right), \ldots,\left(s_{1}, r_{m}\right),\left(s_{2}, r_{1}\right),\left(s_{3}, r_{1}\right), \ldots,\left(s_{n}, r_{1}\right)</script><h3 id="3-2-交并比"><a href="#3-2-交并比" class="headerlink" title="3.2 交并比"></a>3.2 交并比</h3><ul><li>Jaccard系数 （Jaccard index）可以衡量两个集合的相似度。给定集合A和B，它们的Jaccard系数即⼆者交集大小除以⼆者并集大小：</li></ul><script type="math/tex; mode=display">J(\mathcal{A}, \mathcal{B})=\frac{|\mathcal{A} \cap \mathcal{B}|}{|\mathcal{A} \cup \mathcal{B}|}</script><ul><li>我们通 常将Jaccard系数称为交并比（intersection over union，IoU），即两个边界框相交⾯积与相并⾯积之比</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123173756721.png" alt="image-20220123173756721" style="zoom: 80%;" /></p><h3 id="3-3-标注训练集的锚框"><a href="#3-3-标注训练集的锚框" class="headerlink" title="3.3 标注训练集的锚框"></a>3.3 标注训练集的锚框</h3><ul><li>在训练集中，我们<strong>将每个锚框视为⼀个训练样本</strong>。为了训练目标检测模型，我们需要为每个锚框标注两类标签：<strong>⼀是锚框所含目标的类别，简称类别；⼆是真实边界框相对锚框的偏移量，简称偏移量（offset)</strong></li><li>在目标检测时，我们⾸先⽣成多个锚框，然后为每个锚框预测类别以及偏移量， 接着根据预测的偏移量调整锚框位置从而得到预测边界框，最后筛选需要输出的预测边界框</li></ul><ul><li><p>假设图像中锚框分别为<script type="math/tex">A_1, A_2, . . . , A_{n_a}</script>，真实边界框分别为<script type="math/tex">B_1, B_2, . . . , B_{n_b}</script>，且<script type="math/tex">n_a</script> ≥ <script type="math/tex">n_b</script>。定义矩 阵<script type="math/tex">X \in R^{n_a\times n_b}</script>，其中第i⾏第j列的元素<script type="math/tex">x_{ij}</script>为锚框<script type="math/tex">A_i</script>与真实边界框<script type="math/tex">B_j</script>的交并比</p><blockquote><ol><li>找到矩阵中最大元素，并将该值对应的真实边界框赋值给锚框，然后从矩阵中去除该行和该列所有元素。然后继续找最大元素，重复上述操作，直到所有真实边界框都被分配完</li><li>这个时候，我们已为<script type="math/tex">n_b</script>个锚框各分配了⼀个真实边界框。接下来，我们 只遍历剩余的<script type="math/tex">n_a − n_b</script>个锚框：给定其中的锚框<script type="math/tex">A_i</script>，根据矩阵<script type="math/tex">X</script>的第i⾏找到与<script type="math/tex">A_i</script>交并比最大的真实边界框<script type="math/tex">B_j</script>，<strong>且只有当该交并比大于预先设定的阈值时，才为锚框<script type="math/tex">A_i</script>分配真实边界框<script type="math/tex">B_j</script></strong></li></ol></blockquote></li><li><p><strong>如果⼀个锚框A被分配了真实边界框B，将锚框A的类别设为B的类别，并根据B和A的中心坐标的相对位置以及两个框的相对大小为锚框A标注偏 移量。</strong></p></li><li><strong>由于数据集中各个框的位置和大小各异，因此这些相对位置和相对大小通常需要⼀些特殊变换，才能使偏移量的分布更均匀从而更容易拟合</strong>。设锚框A及其被分配的真实边界框B的中 ⼼坐标分别为<script type="math/tex">(x_a, y_a)</script>和<script type="math/tex">(x_b, y_b)</script>，A和B的宽分别为<script type="math/tex">w_a</script>和<script type="math/tex">w_b</script>，高分别为<script type="math/tex">h_a</script>和<script type="math/tex">h_b</script>，⼀个常⽤的技巧是将A的偏移量标注为：</li></ul><script type="math/tex; mode=display">\left(\frac{\frac{x_{b}-x_{a}}{w_{a}}-\mu_{x}}{\sigma_{x}}, \frac{\frac{y_{b}-y_{a}}{h_{a}}-\mu_{y}}{\sigma_{y}}, \frac{\log \frac{w_{b}}{w_{a}}-\mu_{w}}{\sigma_{w}}, \frac{\log \frac{h_{b}}{h_{a}}-\mu_{h}}{\sigma_{h}}\right)</script><p>其中常数的默认值为<script type="math/tex">µ_x = µ_y = µ_w = µ_h = 0, σ_x = σ_y = 0.1, σ_w = σ_h = 0.2</script></p><ul><li><p>如果一个锚框没有被分配真实边界框，我们只需将该锚框的类别设为<strong>背景</strong>。类别为背景的锚框通常被称为<strong>负类锚框</strong>，其余则被称为<strong>正类锚框</strong></p></li><li><p><strong>掩码（mask）：</strong> <strong>形状为(批量大小, 锚框个数的四倍)</strong>。掩码变量中的元素 与每个锚框的4个偏移量⼀⼀对应。由于我们不关⼼对背景的检测，有关负类的偏移量不应影响 目标函数。<strong>通过按元素乘法，掩码变量中的0可以在计算目标函数之前过滤掉负类的偏移量</strong></p></li></ul><h3 id="3-4-非极大值抑制"><a href="#3-4-非极大值抑制" class="headerlink" title="3.4 非极大值抑制"></a>3.4 非极大值抑制</h3><ul><li>为了使结果更加简洁，我们可以移除相似的预测边界框。常⽤的方法叫作非极大值抑制（non-maximum suppression，NMS)：</li></ul><blockquote><ol><li>在同⼀图像上，我们将预测类别非背景的预测边界框按置信度从高到低排序， 得到列表L</li><li>从L中选取置信度最高的预测边界框<script type="math/tex">B_1</script>作为基准，将所有与<script type="math/tex">B_1</script>的交并比大于某阈值 的非基准预测边界框从L中移除。这⾥的阈值是预先设定的超参数</li><li>继续重复上述操作，直到L中所有的预测边界框都曾作为基准</li></ol></blockquote><ul><li>实践中，我们可以在执⾏非极大值抑制前将置信度较低的预测边界框移除，从而减小非极大值抑制的计算量。我们还可以筛选非极大值抑制的输出，例如，只保留其中置信度较高的结果作为最终输出。</li></ul><h3 id="3-5-多尺度目标检测"><a href="#3-5-多尺度目标检测" class="headerlink" title="3.5 多尺度目标检测"></a>3.5 多尺度目标检测</h3><ul><li>在不同尺度下，我们可以⽣成不同数量和不同大小的锚框。值得注意的是，较小目标比较大目标在图像上出现位置的可能性更多</li><li>因此，当使⽤较小 锚框来检测较小目标时，我们可以采样较多的区域；而当使⽤较大锚框来检测较大目标时，我们可以采样较少的区域。</li><li>我们可以通过<strong>控制特征图的大小来控制尺度（特征图每个单元在输入图像上对应的感受野可大可小）</strong>。本质上，我们⽤输⼊图像在某个感 受野区域内的信息来预测输⼊图像上与该区域位置相近的锚框的类别和偏移量</li></ul><h3 id="3-6-单发多框检测（SSD）"><a href="#3-6-单发多框检测（SSD）" class="headerlink" title="3.6 单发多框检测（SSD）"></a>3.6 单发多框检测（SSD）</h3><ul><li>它主要由<strong>⼀个基础⽹络块和若干个多尺度特征块串联而成</strong>。其中<strong>基础⽹络块⽤来从原始图像中抽取特征</strong>，因此⼀般会选择常⽤的深度卷积神经⽹络。单 发多框检测论⽂中选⽤了在分类层之前截断的VGG，现在也常⽤ResNet替代</li><li>我们可以设计 基础⽹络，使它输出的高和宽较大。这样⼀来，基于该特征图⽣成的锚框数量较多，可以⽤来检 测尺⼨较小的目标</li><li>接下来的每个多尺度特征块将上⼀层提供的特征图的<strong>高和宽缩小（如减半）</strong>， 并使<strong>特征图中每个单元在输⼊图像上的感受野变得更⼴阔</strong>。如此⼀来，下图中<strong>越靠近顶部的多 尺度特征块输出的特征图越小，故而基于特征图⽣成的锚框也越少，加之特征图中每个单元感受 野越大，因此更适合检测尺⼨较大的目标</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123182624112.png" alt="image-20220123182624112" style="zoom:80%;" /></p><h5 id="3-6-1-类别预测层"><a href="#3-6-1-类别预测层" class="headerlink" title="3.6.1 类别预测层"></a>3.6.1 类别预测层</h5><ul><li>设目标的类别个数为q。每个锚框的类别个数将是q + 1，其中类别0表⽰锚框只包含背景</li><li>设特征图的高和宽分别为h和w，如果以其中每个单元为中⼼⽣成a个锚框，那么我们需 要对hwa个锚框进⾏分类。如果使⽤全连接层作为输出，<strong>很容易导致模型参数过多。所以我们可以通过通道输出类别</strong></li><li>类别预测层使⽤⼀个<strong>保持输⼊高和宽的卷积层</strong>。这样⼀来，输出和输⼊在特征图宽和高上的空间坐标⼀⼀对应。考虑输出和输⼊同⼀空间坐标(x, y)：<strong>输出特征图上(x, y)坐标的通道里包含了以输⼊特征图(x, y)坐标为中心生成的所有锚框的类别预测</strong>。因此<strong>输出通道数为a(q + 1)， 其中索引为i(q + 1) + j（0 ≤ j ≤ q）的通道代表了索引为i的锚框有关类别索引为j的预测</strong></li></ul><h5 id="3-6-2-边界框预测层"><a href="#3-6-2-边界框预测层" class="headerlink" title="3.6.2 边界框预测层"></a>3.6.2 边界框预测层</h5><ul><li>边界框预测层的设计与类别预测层的设计类似。唯⼀不同的是，这⾥需要为每个锚框预测4个偏移量，而不是q + 1个类别</li></ul><h5 id="3-6-3-连结多尺度的预测"><a href="#3-6-3-连结多尺度的预测" class="headerlink" title="3.6.3 连结多尺度的预测"></a>3.6.3 连结多尺度的预测</h5><ul><li>每个尺度的输出，除了批量大小一样，其他维度的大小均不一样。我们需要将它们变形成统⼀的格式并将多尺度的预测连结，从而让后续计算更简单</li><li>所以我们需要将为(批量大小, 通道数, 高, 宽)格式转换成⼆维的(批量大小, 高×宽×通道数)的格式，以方便之后在维度1上的连结。</li></ul><h5 id="3-6-4-损失函数和评价函数"><a href="#3-6-4-损失函数和评价函数" class="headerlink" title="3.6.4 损失函数和评价函数"></a>3.6.4 损失函数和评价函数</h5><ul><li>目标检测有两个损失：<strong>⼀是有关锚框类别的损失</strong>，我们可以重⽤之前图像分类问题⾥⼀直使⽤ 的交叉熵损失函数；<strong>⼆是有关正类锚框偏移量的损失</strong></li><li>。预测偏移量是⼀个回归问题，但这⾥不 使⽤前⾯介绍过的平方损失，而使⽤L1范数损失，即预测值与真实值之间差的绝对值（其中 使用掩码变量令负类锚框和填充锚框不参与损失的计算）</li><li>最后，我们将有关锚框类别和偏移量的损失相加得到模型的最终损失函数。</li><li>可以将<script type="math/tex">L_1</script>损失换成<strong>平滑的<script type="math/tex">L_1</script>范数损失</strong>，它在零点附近使⽤平方函数从而更加平滑，这是通过⼀个超参数<script type="math/tex">\sigma</script>来控制平滑区域的：</li></ul><script type="math/tex; mode=display">f(x)=\left\{\begin{array}{ll}(\sigma x)^{2} / 2, & \text { if }|x|<1 / \sigma^{2} \\|x|-0.5 / \sigma^{2}, & \text { otherwise }\end{array}\right.</script><p>当<script type="math/tex">\sigma</script>很⼤时该损失类似于<script type="math/tex">L_1</script>范数损失。当它较小时，损失函数较平滑。</p><ul><li>还可以将交叉熵损失换成<strong>焦点损失（focal loss）</strong>：</li></ul><script type="math/tex; mode=display">-\alpha\left(1-p_{j}\right)^{\gamma} \log p_{j}</script><p>焦点损失适用于比较密集的目标检测，即要判定的类别比较多的情况。我们将一个锚框标签的类别作为正类，其余都作为负类（包括背景），那么这就转换成了一个二分类问题，回顾二分类的交叉熵损失函数：</p><script type="math/tex; mode=display">\mathrm{L}=-\mathrm{ylog} y^{\prime}-(1-y) \log \left(1-y^{\prime}\right)=\left\{\begin{array}{ll}-\log y^{\prime} & , \quad y=1 \\-\log \left(1-y^{\prime}\right), & y=0\end{array}\right.</script><p>可以看到当标签为负类（y=0），且正类预测概率<script type="math/tex">y'</script>较大时，会产生较大的损失。而由于正负样本的极其不均衡（比如有1000个类别，正类只有1种，负类则有999种），所以负样本会主导梯度的更新方向，使得整体学习方向跑偏</p><p>上述的负类因为正负样本的不均衡，所以负类是是易分类的样本（<script type="math/tex">p_j > 0.5</script>），而焦点损失中的<script type="math/tex">(1-p_j)^{\gamma}</script>就是为了减轻易分类样本的权重，让对象检测器更关注难分类的样本（即正样本）</p><h1 id="4-区域卷积神经网络（R-CNN）"><a href="#4-区域卷积神经网络（R-CNN）" class="headerlink" title="4 区域卷积神经网络（R-CNN）"></a>4 区域卷积神经网络（R-CNN）</h1><h3 id="4-1-R-CNN"><a href="#4-1-R-CNN" class="headerlink" title="4.1 R-CNN"></a>4.1 R-CNN</h3><ul><li>R-CNN⾸先对图像<strong>选取若干提议区域</strong>（如锚框也是⼀种选取方法）并标注它们的类别和边界框 （如偏移量）。然后，<strong>⽤卷积神经⽹络对每个提议区域做前向计算抽取特征。之后，我们⽤每个提议区域的特征预测类别和边界框</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123184832784.png" alt="image-20220123184832784" style="zoom:80%;" /></p><ul><li><p>具体来说，R-CNN主要由以下4步构成：</p><blockquote><ol><li>对输⼊图像使⽤选择性搜索（selective search）来<strong>选取多个高质量的提议区域</strong>。这些提议区域通常是在<strong>多个尺度下</strong>选取的，并具有不同的形状和大小。<strong>每个提议区域将被标注类 别和真实边界框。</strong></li><li>选取⼀个预训练的卷积神经⽹络，并将其在输出层之前截断</li><li>将每个提议区域的特征连同其标注的类别作为⼀个样本，训练多个⽀持向量机对目标分类。 其中每个⽀持向量机⽤来判断样本是否属于某⼀个类别</li><li>将每个提议区域的特征连同其标注的边界框作为⼀个样本，训练线性回归模型来预测真实边界框</li></ol></blockquote></li><li><p>一张图片中可能会有很多个提议区域，每个区域都要进行卷积运算。这个<strong>巨大的计算量令R-CNN难以在实际应⽤中被⼴泛采⽤</strong></p></li></ul><h3 id="4-2-Fast-R-CNN"><a href="#4-2-Fast-R-CNN" class="headerlink" title="4.2 Fast R-CNN"></a>4.2 Fast R-CNN</h3><ul><li>R-CNN提议区域通常<strong>有大量重叠， 独⽴的特征抽取会导致大量的重复计算</strong>。Fast R-CNN对R-CNN的⼀个主要改进在于<strong>只对整个图像 做卷积神经⽹络的前向计算。</strong></li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123185433036.png" alt="image-20220123185433036" style="zoom:80%;" /></p><ul><li>主要步骤：</li></ul><blockquote><ol><li>与R-CNN相比，Fast R-CNN⽤来提取特征的卷积神经⽹络的输⼊是整个图像，而不是各个提议区域。而且，<strong>这个⽹络通常会参与训练</strong>，即更新模型参数。设输⼊为⼀张图像，将卷积神经⽹络的输出的形状记为<script type="math/tex">1 × c × h_1 × w_1</script></li><li>假设选择性搜索⽣成n个提议区域。<strong>这些形状各异的提议区域在卷积神经网络的输出上分别标出形状各异的兴趣区域</strong>。这些兴趣区域需要抽取出<strong>形状相同</strong>的特征（假设高和宽均分别指定为<script type="math/tex">h_2</script>和<script type="math/tex">w_2</script>）以便于连结后输出（使用<strong>兴趣区域池化（region of interest pooling，RoI池化）层，将卷积神经⽹络的输出和提议区域作为输⼊，输出连结后的各个提议区域抽取的特征</strong>）</li><li>通过全连接层将输出形状变换为n × d，其中超参数d取决于模型设计</li><li>预测类别时，将全连接层的输出的形状再变换为n × q并使⽤softmax回归（q为类别个数）。 预测边界框时，将全连接层的输出的形状变换为n × 4。也就是说，我们为每个提议区域预 测类别和边界框。</li></ol></blockquote><ul><li>兴趣区域池化层：兴趣区域池化层对每个区域的输 出形状是可以直接指定的如下图：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123191333584.png" alt="image-20220123191333584"></p><p>第一张图的蓝色区域是一个提议区域，将其经过2x2兴趣区域池化层后，划分成了4个区域，分别含有元素0、1、4、5（5最 大），2、6（6最大），8、9（9最大），10。输出每个区域的最大元素</p><h3 id="4-3-Faster-R-CNN"><a href="#4-3-Faster-R-CNN" class="headerlink" title="4.3 Faster R-CNN"></a>4.3 Faster R-CNN</h3><ul><li>Fast R-CNN通常需要在选择性搜索中⽣成较多的提议区域，以获得较精确的目标检测结果。Faster R-CNN提出<strong>将选择性搜索替换成区域提议⽹络（region proposal network）</strong>，从而<strong>减少提议区域 的⽣成数量</strong>，并保证目标检测的精度</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123191545146.png" alt="image-20220123191545146" style="zoom:67%;" /></p><ul><li>与Fast R-CNN相比，只有⽣成提议区域的方法从选择性搜索变成了区域提议⽹络，而其他部分均保持不变。具体来说，区域提议⽹络的计算步骤如下：</li></ul><blockquote><ol><li>使⽤填充为1的3 × 3卷积层变换卷积神经⽹络的输出，并将输出通道数记为c</li><li>. 以特征图每个单元为中⼼，⽣成多个不同大小和宽高比的锚框并标注它们</li><li>. ⽤锚框中⼼单元⻓度为c的特征分别预测该锚框的<strong>二元类别（含目标还是背景，需要reshape）</strong>和边界框</li><li>使⽤非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测 边界框即兴趣区域池化层所需要的提议区域。</li></ol></blockquote><ul><li>区域提议⽹络作为Faster R-CNN的⼀部分，是和整个模型⼀起训练得到的。也就 是说，<strong>Faster R-CNN的目标函数既包括目标检测中的类别和边界框预测，⼜包括区域提议⽹络中 锚框的⼆元类别和边界框预测</strong></li></ul><h3 id="4-4-Mask-R-CNN"><a href="#4-4-Mask-R-CNN" class="headerlink" title="4.4 Mask R-CNN"></a>4.4 Mask R-CNN</h3><ul><li>如果训练数据还标注了每个目标在图像上的像素级位置，那么Mask R-CNN能有效利⽤这些详尽 的标注信息进⼀步提升目标检测的精度。</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123193610616.png" alt="image-20220123193610616" style="zoom: 80%;" /></p><ul><li>Mask R-CNN将兴趣区域池化层 替换成了兴趣区域对⻬层，即通过<strong>双线性插值（bilinear interpolation）（一种常用的上采样方法，目的是将下一层的特征图的单元于上一层特征图单元对齐）</strong>来保留特征图上的空间信息，从而更适于像素级预测</li></ul><h1 id="5-语义分割"><a href="#5-语义分割" class="headerlink" title="5 语义分割"></a>5 语义分割</h1><ul><li>语义分割（semantic segmentation）关注如何将图像分割成属于不同语义类别的区域。值得⼀提的是，这些语义区域的标注和预测都是像素级的</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220123194304346.png" alt="image-20220123194304346" style="zoom: 67%;" /></p><ul><li>计算机视觉领域还有2个与语义分割相似的重要问题，即<strong>图像分割（image segmentation）</strong>和<strong>实例分割（instance segmentation）</strong></li><li><strong>图像分割</strong>将图像分割成若干组成区域。<strong>这类问题的方法通常利⽤图像中像素之间的相关性</strong>。 它在训练时不需要有关图像像素的标签信息，在预测时也⽆法保证分割出的区域具有我们希望得到的语义。如上图图像分割可能将狗分割成两个区域：⼀个覆盖以⿊⾊为主的嘴巴和眼睛，而另⼀个覆盖以⻩⾊为主的其余部分⾝体</li><li><strong>实例分割</strong>研究如何 识别图像中各个目标实例的像素级区域。与语义分割有所不同，实例分割<strong>不仅需要区分语 义，还要区分不同的目标实例</strong>。如果图像中有两只狗，实例分割需要区分像素属于这两只 狗中的哪⼀只。</li></ul><ul><li>如果我们通过缩放图像使其符合模型的输⼊形状。然而在语义分割⾥，<strong>需要将预测的像素类别重新映射回原始尺⼨的输⼊图像</strong>。这样的映射难以做到精确，尤其在不同语义的分割区域。为了避免这个问题，<strong>我们将图像裁剪成固定尺⼨而不是缩放</strong>（对于实际尺寸小于规定尺寸的图像，需要移除）</li></ul><h1 id="6-全卷积网络（FCN）"><a href="#6-全卷积网络（FCN）" class="headerlink" title="6 全卷积网络（FCN）"></a>6 全卷积网络（FCN）</h1><ul><li>全卷积⽹络（fully convolutional network，FCN）采⽤卷积神经⽹络实现了从图像像素到像素类别的变换。</li><li>全卷积⽹络通过<strong>转置卷积（transposed convolution）层将中间层特征图的高和宽变换回输⼊图像的尺⼨</strong></li></ul><ul><li>因为卷积运算可以用矩阵乘法来实现，假设input进行卷积运算相当于input矩阵乘一个<script type="math/tex">W</script>矩阵得到特征图featrue。那么可以通过featrue乘一个<script type="math/tex">W^T</script>来变回input的形状。<strong>所以可以通过转置卷积层来交换卷积层输入和输出的形状</strong></li></ul><h3 id="6-1-模型构造"><a href="#6-1-模型构造" class="headerlink" title="6.1 模型构造"></a>6.1 模型构造</h3><ul><li>全卷积⽹络先使⽤卷积神经⽹络抽取图像特征，然后通过1 × 1卷积层将通道数变换为类别个数，最后通过转置卷积层将特征图的⾼和宽变换为输⼊图像的尺⼨</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220124154145643.png" alt="image-20220124154145643" style="zoom: 67%;" /></p><h3 id="6-2-初始化转置卷积层"><a href="#6-2-初始化转置卷积层" class="headerlink" title="6.2 初始化转置卷积层"></a>6.2 初始化转置卷积层</h3><ul><li><strong>双线性插值：</strong>首先介绍一下单线性插值（一维）：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/20190819135319360.jpg" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>我们知道<script type="math/tex">x_0,x_1,y_0,y_1,x</script>的值，要求<script type="math/tex">y</script>的值：</p><script type="math/tex; mode=display">y = y_0 + \frac{y_1 - y_0}{x_1 - x_0}(x - x_0)</script><p>而<strong>双线性插值其实就是在不同的维度上单线性插值两次</strong>，已知<script type="math/tex">Q_{11}(x_1,y_1),Q_{12}(x_1,y_2),Q_{21}(x_2,y_1),Q_{22}(x_2,y_2)</script>，求其中点P(x,y)的函数值：</p><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/v2-ad3d95548a97aa47ca85867cd0f2e161_720w.jpg" alt="img" style="zoom:67%;" /></p><p>首先在x方向单线性插值两次：</p><script type="math/tex; mode=display">\begin{array}{l}f\left(R_{1}\right)=\frac{x_{2}-x}{x_{2}-x_{1}} f\left(Q_{11}\right)+\frac{x-x_{1}}{x_{2}-x_{1}} f\left(Q_{21}\right) \\f\left(R_{2}\right)=\frac{x_{2}-x}{x_{2}-x_{1}} f\left(Q_{12}\right)+\frac{x-x_{1}}{x_{2}-x_{1}} f\left(Q_{22}\right)\end{array}</script><p>然后再在y方向单线性插值一次：</p><script type="math/tex; mode=display">f(P)=\frac{y_{2}-y}{y_{2}-y_{1}} f\left(R_{1}\right)+\frac{y-y_{1}}{y_{2}-y_{1}} f\left(R_{2}\right)</script><p>即可得到结果。</p><ul><li>在全卷积⽹络中，我们一般<strong>将转置卷积层初始化为双线性插值的上采样</strong>，具体方法是：</li></ul><blockquote><ol><li>为了得到输出图像在坐 标(x, y)上的像素，先将该坐标映射到输⼊图像的坐标(x ′ , y′ )，例如，根据输⼊与输出的尺⼨之⽐来映射。</li><li>映射后的x ′和y ′通常是实数。然后，在输⼊图像上找到与坐标(x ′ , y′ )最近的4像素。最后， 输出图像在坐标(x, y)上的像素依据输⼊图像上这4像素及其与(x ′ , y′ )的相对距离来计算（用双线性插值）</li></ol></blockquote><ul><li><p>如果步幅为s、填充为s/2（假设s/2为整数）、卷积核的⾼和宽为2s，转置卷积核将输⼊的⾼和宽分别放⼤s倍</p></li><li><p>转置卷积层的输出形状可能会不一样，这是因为当<strong>输入图像的高宽无法整除步幅时，输出的高宽会有所偏差</strong>。为了解决这个问题，我们可以在图像中<strong>截取多块⾼和宽为步幅的整数倍的矩形区域</strong>，并分别对这些区域中的像素做前向计算。<strong>这些区域的并集需要完整覆盖输⼊图像</strong>。当⼀个像素被多个区域所覆盖时，它在不同区域 前向计算中转置卷积层输出的<strong>平均值可以作为softmax运算的输⼊</strong>，从而预测类别</p></li></ul><h1 id="7-样式迁移"><a href="#7-样式迁移" class="headerlink" title="7 样式迁移"></a>7 样式迁移</h1><ul><li><p>使⽤卷积神经⽹络⾃动将某图像中的样式应⽤在另⼀图像之上，即样式迁移（style transfer）。需要两张输⼊图像，⼀张是<strong>内容图像</strong>，另⼀张是<strong>样式图像</strong>， 我们将使⽤神经⽹络<strong>修改内容图像使其在样式上接近样式图像</strong></p></li><li><p>主要步骤：</p></li></ul><blockquote><ol><li>⾸先，我们初始化合成图像，例如 将其<strong>初始化成内容图像</strong>。该合成图像是样式迁移过程中<strong>唯⼀需要更新的变量</strong>，</li><li>我们选择⼀个预训练的卷积神经⽹络来<strong>抽取图像的特征</strong>，其中的<strong>模型参数在训练中⽆须更新</strong>。深度卷积神经⽹络<strong>凭借多个层逐级抽取图像的特征。我们可以选择其中某些 层的输出作为内容特征或样式特征</strong>，例如下图，这⾥选取的预训练的神经⽹络含有3个卷积 层，其中第⼆层输出图像的内容特征，而第⼀层和第三层的输出被作为图像的样式特征</li><li>样式迁移常⽤的损失函数由3部分组成：<strong>内容损失（content loss）</strong>使合成图像与内容图像在内容特征上接近，<strong>样式损失（style loss）</strong>令合成图像与样式图像 在样式特征上接近，而<strong>总变差损失（total variation loss）</strong>则有助于减少合成图像中的噪点</li></ol><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20220124175546385.png" alt="image-20220124175546385" style="zoom:50%;" /></p></blockquote><h3 id="7-1-内容层和样式层的选择"><a href="#7-1-内容层和样式层的选择" class="headerlink" title="7.1 内容层和样式层的选择"></a>7.1 内容层和样式层的选择</h3><ul><li><strong>⼀般来说，越靠近输⼊层的输出越容易抽取图像的细节信息，反之则越容易抽取图像的全局信息。为了避免合成 图像过多保留内容图像的细节，我们选择较靠近输出的层来输出图像的内容特征</strong></li><li><strong>我们还可以选择不同层的输出来匹配局部和全局的样式，这些层也叫样式层</strong></li><li>例如VGG-19,使⽤了5个卷积块。我们可以选择第四卷积块的最后⼀个卷积层作为内容层，以及每个卷积块的第⼀个卷积层作为样式层</li></ul><h3 id="7-2-损失函数"><a href="#7-2-损失函数" class="headerlink" title="7.2 损失函数"></a>7.2 损失函数</h3><ul><li><p><strong>内容损失：</strong>与线性回归中的损失函数类似，内容损失通过平⽅误差函数衡量合成图像与内容图像在内容特征上的差异。平⽅误差函数的两个输⼊均为内容层的输出。</p></li><li><p><strong>样式损失：</strong>样式损失也⼀样通过平⽅误差函数衡量合成图像与样式图像在样式上的差异。我们将样式层的输出（长为h，宽为w，通道数为c），转化成c行hw列的矩阵X，矩阵X可以看作由c个长度为hw的向量<script type="math/tex">x_1, . . . , x_c</script>组成的。其中向量<script type="math/tex">x_i</script>代表了通道<script type="math/tex">i</script>上的样式特征。</p><p>这些向量的<strong>格拉姆矩阵 （Gram matrix）<script type="math/tex">XX^T\in R^{c\times c}</script>中<script type="math/tex">i</script>⾏<script type="math/tex">j</script>列的元素<script type="math/tex">x_{ij}</script>即向量<script type="math/tex">x_i</script>与<script type="math/tex">x_j</script>的内积</strong>，它表达了通道<script type="math/tex">i</script>和通道<script type="math/tex">j</script>上样式特征的相关性。我们⽤这样的格拉姆矩阵表达样式层输出的样式。</p><p>需要注意的是，当hw的值较⼤时，格拉姆矩阵中的元素容易出现较⼤的值。此外，格拉姆矩阵的⾼和宽皆为通道数c。为了让样式损失不受这些值的⼤小影响，<strong>需要除以矩阵中元素的个数，即chw</strong></p></li><li><p><strong>总变量损失：</strong>有时候，我们学到的合成图像⾥⾯有⼤量⾼频噪点，即有特别亮或者特别暗的颗粒像素。⼀种常⽤的降噪⽅法是总变差降噪（total variation denoising）。</p><p>假设<script type="math/tex">x_{i,j}</script>表⽰坐标为<script type="math/tex">(i, j)</script>的像素值，降低总变差损失：</p><script type="math/tex; mode=display">\sum_{i, j}\left|x_{i, j}-x_{i+1, j}\right|+\left|x_{i, j}-x_{i, j+1}\right|</script><p>能够尽可能使邻近的像素值相似。</p></li></ul><ul><li>样式迁移的损失函数即内容损失、样式损失和总变差损失的<strong>加权和</strong>。通过调节这些<strong>权值超参数</strong>， 我们可以权衡合成图像在保留内容、迁移样式以及降噪三⽅⾯的相对重要性。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>优化算法</title>
    <link href="/2021/12/07/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <url>/2021/12/07/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-沿梯度方向函数值一定下降"><a href="#1-沿梯度方向函数值一定下降" class="headerlink" title="1 沿梯度方向函数值一定下降"></a>1 沿梯度方向函数值一定下降</h1><ul><li>证明上述的这个结论（这里只证明了一维输入的时候），首先通过泰勒公式：</li></ul><script type="math/tex; mode=display">f(x)=\sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n !}(x-a)^{n}</script><ul><li>将上式的x和a替换为<script type="math/tex">x + \epsilon</script>和x，得到：</li></ul><script type="math/tex; mode=display">f(x+\epsilon) \approx f(x)+f^{\prime}(x) \epsilon+\mathcal{O}\left(\epsilon^{2}\right)</script><ul><li>当<script type="math/tex">\epsilon</script>足够小时，<script type="math/tex">\mathcal{O}(\epsilon^2)</script>可以忽略不计：</li></ul><script type="math/tex; mode=display">f(x+\epsilon) \approx f(x)+f^{\prime}(x) \epsilon</script><ul><li>如果存在<script type="math/tex">\eta > 0</script>，使得<script type="math/tex">|\eta f'(x)|</script>足够小，那么：</li></ul><script type="math/tex; mode=display">f\left(x-\eta f^{\prime}(x)\right) \approx f(x)-\eta f^{\prime}(x)^{2} \lesssim f(x)</script><ul><li>对于多维输入时的证明，可以看<a href="https://zlkqz.site/2022/10/27/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/#4-1-%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法的原理</a></li></ul><h1 id="2-梯度下降法"><a href="#2-梯度下降法" class="headerlink" title="2 梯度下降法"></a>2 梯度下降法</h1><ul><li>梯度下降法即使用所有样本或部分样本关于loss的梯度和，作为整体的梯度：</li></ul><script type="math/tex; mode=display">\begin{array}{c}f(\boldsymbol{x})=\frac{1}{n} \sum_{i=1}^{n} f_{i}(\boldsymbol{x}) . \\\nabla f(\boldsymbol{x})=\frac{1}{n} \sum_{i=1}^{n} \nabla f_{i}(\boldsymbol{x}) .\end{array}</script><ul><li>不同batch-size的梯度下降有一定的区别，具体可看<a href="https://zlkqz.site/2021/11/11/%E4%B8%89%E7%A7%8D%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%9A%84%E6%96%B9%E6%B3%95/">不同batch size梯度下降的影响</a></li></ul><h1 id="3-动量法（Momentum）"><a href="#3-动量法（Momentum）" class="headerlink" title="3 动量法（Momentum）"></a>3 动量法（Momentum）</h1><h3 id="3-1-梯度下降法的问题"><a href="#3-1-梯度下降法的问题" class="headerlink" title="3.1 梯度下降法的问题"></a>3.1 梯度下降法的问题</h3><ul><li>举个栗子，考虑函数<script type="math/tex">f(x) = 0.1x_1^2 + 2x_2^2</script>，<strong>输入中不同维度变量的梯度相差较大</strong>，假设使用较小的学习率，其迭代路线如下：</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20221104163804950.png" alt="image-20221104163804950" style="zoom:80%;" /></p><ul><li><strong>可以看到，由于使用了较小的学习率，所以梯度较小的维度收敛得很慢，但是学习率又不能的过大，因为有较大的梯度的维度会无法收敛，</strong></li></ul><h3 id="3-2-指数加权移动平均"><a href="#3-2-指数加权移动平均" class="headerlink" title="3.2 指数加权移动平均"></a>3.2 指数加权移动平均</h3><ul><li>定义如下：</li></ul><script type="math/tex; mode=display">y_{t}=\gamma y_{t-1}+(1-\gamma) x_{t} \\y_0 = 0</script><ul><li>是可以对<script type="math/tex">y_t</script>进行展开的：</li></ul><script type="math/tex; mode=display">\begin{aligned}y_{t} &=(1-\gamma) x_{t}+\gamma y_{t-1} \\&=(1-\gamma) x_{t}+(1-\gamma) \cdot \gamma x_{t-1}+\gamma^{2} y_{t-2} \\&=(1-\gamma) x_{t}+(1-\gamma) \cdot \gamma x_{t-1}+(1-\gamma) \cdot \gamma^{2} x_{t-2}+\gamma^{3} y_{t-3} \\&= \quad ......\end{aligned}</script><ul><li>从上面可以看出，<strong>可以将<script type="math/tex">y_t</script>当作前面时间步的<script type="math/tex">x_i</script>的加权平均</strong>。但是我们需要一些近似，由于越往前的<script type="math/tex">x_i</script>涉及到的连乘越多，越接近0，<strong>所以对于权值为<script type="math/tex">\mathcal{O}(\gamma^{1 / (1-\gamma)})</script>的项进行忽略，即把<script type="math/tex">y_t</script>看作是对最近<script type="math/tex">1/(1 − \gamma)</script>个时间步的<script type="math/tex">x_i</script>值的加权平均，且越接近当前时间步，权重越大</strong></li></ul><h3 id="3-3-算法流程"><a href="#3-3-算法流程" class="headerlink" title="3.3 算法流程"></a>3.3 算法流程</h3><ul><li>算法流程如下：</li></ul><script type="math/tex; mode=display">\begin{array}{l}\boldsymbol{v}_{t} \leftarrow \gamma \boldsymbol{v}_{t-1}+\eta \boldsymbol{g}_{t} \\\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\boldsymbol{v}_{t}\end{array}</script><p>其中<script type="math/tex">g_t</script>为现在step的小批量梯度，最开始<script type="math/tex">v_0 = 0</script>，动量超参数<script type="math/tex">\gamma</script>满⾜<script type="math/tex">0 \le \gamma < 1</script>。当<script type="math/tex">\gamma = 0</script>时，动量法等价于小批量随机梯度下降</p><h3 id="3-4-算法原理"><a href="#3-4-算法原理" class="headerlink" title="3.4 算法原理"></a>3.4 算法原理</h3><ul><li>动量法其实就是对指数加权移动平均中<script type="math/tex">x_t</script>做了一个变形：</li></ul><script type="math/tex; mode=display">\boldsymbol{v}_{t} \leftarrow \gamma \boldsymbol{v}_{t-1}+(1-\gamma)\left(\frac{\eta}{1-\gamma} g_{t}\right)</script><ul><li><p>由上式可知，动量法其实就是对最近<script type="math/tex">1/(1 − \gamma)</script>个时间步的梯度（只是梯度进行了一个放缩）进行加权平均</p></li><li><p><strong>所以，在动量法中，⾃变量在各个⽅向上的移动幅度不仅取决于当前梯度，还取决于过去的各个梯度在各个⽅向上是否⼀致</strong>。如果梯度不一致，则代表梯度过大，那么动量法就会在加权平均时减去相反的梯度，以达到减少梯度的目的</p></li></ul><h1 id="4-AdaGrad算法"><a href="#4-AdaGrad算法" class="headerlink" title="4 AdaGrad算法"></a>4 AdaGrad算法</h1><ul><li>在前面梯度下降的问题中，造成这种现象的原因是<strong>不同维度使用了相同的学习率</strong>。而AdaGrad则自变量在每个维度的梯度值的大小来<strong>调整各个维度上的学习率</strong>，从而避免统⼀的学习率难以适应所有维度的问题</li></ul><h3 id="4-1-算法流程"><a href="#4-1-算法流程" class="headerlink" title="4.1 算法流程"></a>4.1 算法流程</h3><ul><li>算法流程如下：</li></ul><script type="math/tex; mode=display">\boldsymbol{s}_{t} \leftarrow \boldsymbol{s}_{t-1}+g_{t} \odot g_{t} \\\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\frac{\eta}{\sqrt{\boldsymbol{s}_{t}+\epsilon}} \odot \boldsymbol{g}_{t},</script><p>其中<script type="math/tex">\epsilon</script>是为了防止除以0，一般为<script type="math/tex">10^{-6}</script>，<script type="math/tex">\odot</script>为按元素相乘，在最开始时<script type="math/tex">s_0 = 0</script></p><h3 id="4-2-算法原理"><a href="#4-2-算法原理" class="headerlink" title="4.2 算法原理"></a>4.2 算法原理</h3><ul><li><p>小批量随机梯度按元素平方的累加变量<script type="math/tex">s_t</script>出现在学习率的分母项中。<strong>因此，如果 目标函数有关目变量中某个元素的偏导数⼀直都较⼤，那么该元素的学习率将下降较快；反之， 如果目标函数有关目变量中某个元素的偏导数⼀直都较小，那么该元素的学习率将下降较慢</strong></p></li><li><p>但是AdaGrad算法也有缺点，由于<script type="math/tex">s_t</script>⼀直在累加按元素平⽅的梯度，⾃变量中每个元素的<strong>学习率在迭代过程中⼀直在降低</strong>。所以，<strong>当学习率在迭代早期降得较快且当前解依然不佳时，AdaGrad算法在迭代后期由于学习率过小，可能较难找到⼀个有用的解</strong></p></li></ul><h1 id="5-RMSProp算法"><a href="#5-RMSProp算法" class="headerlink" title="5 RMSProp算法"></a>5 RMSProp算法</h1><ul><li>针对上述AdaGrad的问题，学习率会一直下降，而RMSProp对AdaGrad做了一点微小的改动，<strong>使用了指数加权移动平均：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{c}\boldsymbol{s}_{t} \leftarrow \gamma \boldsymbol{s}_{t-1}+(1-\gamma) \boldsymbol{g}_{t} \odot \boldsymbol{g}_{t} . \\\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\frac{\eta}{\sqrt{s_{t}+\epsilon}} \odot \boldsymbol{g}_{t}\end{array}</script><ul><li>可以看到，<strong>AdaGrad中的<script type="math/tex">s_t</script>是所有steps中梯度的平方和，而RMSProp中的<script type="math/tex">s_t</script>是最近<script type="math/tex">1 / (1-\gamma)</script>个steps的加权平均</strong>，这样学习率就不会一直降低</li></ul><h1 id="6-AdaDelta算法"><a href="#6-AdaDelta算法" class="headerlink" title="6 AdaDelta算法"></a>6 AdaDelta算法</h1><ul><li>AdaDelta同样是针对AdaGrad的问题进行了改进，值得注意的是<strong>AdaDelta没有学习率这一超参</strong></li></ul><h3 id="6-1-算法流程"><a href="#6-1-算法流程" class="headerlink" title="6.1 算法流程"></a>6.1 算法流程</h3><ul><li>AdaDelta和RMSProp同样使用了指数加权移动平均，以减少梯度惩罚致使学习率过小的影响，给定超参数<script type="math/tex">\rho</script>（即前面中的<script type="math/tex">\gamma</script>），首先和RMSProp一样，计算：</li></ul><script type="math/tex; mode=display">\boldsymbol{s}_{t} \leftarrow \rho \boldsymbol{s}_{t-1}+(1-\rho) \boldsymbol{g}_{t} \odot \boldsymbol{g}_{t}</script><ul><li>另外，他还维护另一个变量<script type="math/tex">\Delta x_t</script>：</li></ul><script type="math/tex; mode=display">\boldsymbol{g}_{t}^{\prime} \leftarrow \sqrt{\frac{\Delta \boldsymbol{x}_{t-1}+\epsilon}{\boldsymbol{s}_{t}+\epsilon}} \odot \boldsymbol{g}_{t} \\\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\boldsymbol{g}_{t}^{\prime}</script><ul><li><script type="math/tex">\Delta x_t</script>同样是使用指数加权移动平均：</li></ul><script type="math/tex; mode=display">\Delta \boldsymbol{x}_{t} \leftarrow \rho \Delta \boldsymbol{x}_{t-1}+(1-\rho) \boldsymbol{g}_{t}^{\prime} \odot \boldsymbol{g}_{t}^{\prime}</script><h3 id="6-2-算法原理"><a href="#6-2-算法原理" class="headerlink" title="6.2 算法原理"></a>6.2 算法原理</h3><ul><li>首先是牛顿法中的更新公式：</li></ul><script type="math/tex; mode=display">x_t = x_{t-1} - H^{-1}g</script><p>其中<script type="math/tex">H^{-1}</script>为黑塞矩阵的逆</p><ul><li>以及梯度下降中的更新公式：</li></ul><script type="math/tex; mode=display">x_t = x_{t-1} - \eta g</script><p>其中<script type="math/tex">\eta</script>为学习率</p><ul><li><p>从上面的两个式子可以得出：<strong>我们并需要显式的设置学习率，而可以直接用<script type="math/tex">H^{-1}</script>来代替学习率</strong></p></li><li><p>而由于黑塞矩阵的计算复杂度过高，所以我们需要进行一些迭代逼近，由于：</p></li></ul><script type="math/tex; mode=display">x_t - x_{t-1} = \Delta x = -H^{-1}g</script><p>所以：</p><script type="math/tex; mode=display">H^{-1} = -\frac{\Delta x}{g}</script><p>我们就使用这个式子来进行迭代逼近，其中<script type="math/tex">\Delta x</script>和<script type="math/tex">g</script>使用前面时间步的指数加权平均来取近似</p><ul><li>所以就得到了：</li></ul><script type="math/tex; mode=display">\Delta x_{t}=-\frac{\operatorname{RMS}[\Delta x]_{t-1}}{\operatorname{RMS}[g]_{t}} g_{t}</script><p>其中<script type="math/tex">\operatorname{RMS}[g]_{t}=\sqrt{E\left[g^{2}\right]_{t}+\epsilon}</script>，<script type="math/tex">E[g^2]_t</script>为最近t个时间步的<script type="math/tex">g^2</script>的指数加权移动平均，<script type="math/tex">\operatorname{RMS}[\Delta x]_{t-1}</script>同理</p><h3 id="6-3-二阶导和一阶导"><a href="#6-3-二阶导和一阶导" class="headerlink" title="6.3 二阶导和一阶导"></a>6.3 二阶导和一阶导</h3><ul><li><p>AdaDelta中使用了黑塞矩阵，涉及到二阶导，<strong>而作者认为使用二阶导是优于一阶导的</strong></p></li><li><p>一阶导可以得到一组近似：（RMSProp举例）</p></li></ul><script type="math/tex; mode=display">\Delta x \propto g \propto \frac{\partial f}{\partial x} \propto \frac{1}{x}</script><ul><li>而二阶导又可以得到另一组近似：（牛顿法举例）</li></ul><script type="math/tex; mode=display">\Delta x \propto H^{-1}g \propto \frac{\frac{\partial f}{\partial x}}{\frac{\partial^2 f}{\partial x^2}} \propto x</script><ul><li>由上面两个式子可以得出：<strong>一阶方法最终正比于1/x，即与参数逆相关：参数逐渐变大的时候，更新值反而变小；而二阶方法最终正比于x，即与参数正相关：参数逐渐变大的时候，更新值也会变大。因此，作者称Hessian方法得到了Correct Units(正确的更新单元)。</strong></li></ul><h1 id="7-Adam算法"><a href="#7-Adam算法" class="headerlink" title="7 Adam算法"></a>7 Adam算法</h1><ul><li>Adam其实就是<strong>动量法和RMSProp算法的结合</strong></li><li>其实就是在RMSProp有惩罚项的基础上，对梯度也做了指数加权平均：</li></ul><script type="math/tex; mode=display">\boldsymbol{v}_{t} \leftarrow \beta_{1} \boldsymbol{v}_{t-1}+\left(1-\beta_{1}\right) \boldsymbol{g}_{t} \\\boldsymbol{s}_{t} \leftarrow \beta_{2} \boldsymbol{s}_{t-1}+\left(1-\beta_{2}\right) \boldsymbol{g}_{t} \odot \boldsymbol{g}_{t}</script><p>其中超参建议值：<script type="math/tex">\beta_1 = 0.9, \beta_2 = 0.999</script></p><ul><li>将<script type="math/tex">v_t</script>展开：</li></ul><script type="math/tex; mode=display">\boldsymbol{v}_{t}=\left(1-\beta_{1}\right) \sum_{i=1}^{t} \beta_{1}^{t-i} \boldsymbol{g}_{i \circ}</script><p>将所有权值相加得到和为<script type="math/tex">1 - \beta_1^t</script>，所以在t较小时，其权值和是不等于1的，所以进行了一个<strong>偏差修正</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}\hat{\boldsymbol{v}}_{t} \leftarrow \frac{\boldsymbol{v}_{t}}{1-\beta_{1}^{t}} \\\hat{\boldsymbol{s}}_{t} \leftarrow \frac{\boldsymbol{s}_{t}}{1-\beta_{2}^{t}}\end{array}</script><p>这样权重值相加就等于1了</p><ul><li>然后使用偏差修正后的变量进行更新：</li></ul><script type="math/tex; mode=display">\begin{array}{l}\boldsymbol{g}_{t}^{\prime} \leftarrow \frac{\eta \hat{\boldsymbol{v}}_{t}}{\sqrt{\hat{\boldsymbol{s}}_{t}}+\epsilon} \\\boldsymbol{x}_{t} \leftarrow \boldsymbol{x}_{t-1}-\boldsymbol{g}_{t}^{\prime}\end{array}</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RNN基本概念</title>
    <link href="/2021/12/06/RNN/"/>
    <url>/2021/12/06/RNN/</url>
    
    <content type="html"><![CDATA[<ul><li>与多层感知机和能有效<strong>处理空间信息</strong>的卷积神经网络不同，循环神经网络是为更好地<strong>处理时序信息</strong>而设计的。它<strong>引⼊状态变量来存储过去的信息</strong>，并⽤其<strong>与当前的输⼊共同决定当前的输出</strong></li></ul><h1 id="1-语言模型"><a href="#1-语言模型" class="headerlink" title="1 语言模型"></a>1 语言模型</h1><h3 id="1-1-语言模型的计算"><a href="#1-1-语言模型的计算" class="headerlink" title="1.1 语言模型的计算"></a>1.1 语言模型的计算</h3><ul><li>我们可以把⼀段⾃然语⾔⽂本看作⼀段离散的时间序列。假设⼀段⻓度为 $T$ 的⽂本中的词 依次为 $w_1, w_2, . . . , w_T$，那么在离散的时间序列中，$w_t（1 ≤ t ≤ T）$可看作在时间步（time step）$ t$ 的输出或标签。给定⼀个⻓度为 $T$ 的词的序列 $w_1, w_2, . . . , w_T$，语⾔模型将计算该序列的概率：</li></ul><script type="math/tex; mode=display">P(w_1, w_2, ...,w_T)</script><ul><li><strong>由于 $w_1, w_2, . . . , w_T$ 是依次生成的，所以有：</strong></li></ul><script type="math/tex; mode=display">P(w_1, w_2, ...,w_T) = \prod_{t=1}^T P(w_t | w_1, ..., w_{t-1})</script><ul><li>为了计算语⾔模型，我们需要计算词的概率，以及⼀个词在给定前⼏个词的情况下的条件概率，即<strong>语⾔模型参数</strong>。<strong>词的概率可以通过该词在训练数据集中的相对词频来计算</strong></li></ul><h3 id="1-2-n元语法"><a href="#1-2-n元语法" class="headerlink" title="1.2 n元语法"></a>1.2 n元语法</h3><ul><li><strong>当序列⻓度增加时，计算和存储多个词共同出现的概率的复杂度会呈指数级增加</strong></li><li>n元语法通过⻢尔可夫假设（<strong>虽然并不⼀定成立</strong>）简化了语⾔模型的计算。这⾥的<strong>⻢尔可夫假设是指⼀个词的出现只与前⾯n个词相关</strong>，即n阶⻢尔可夫链（Markov chain of order n）</li><li>如果基于$n-1$阶马尔科夫链，我们可以将语言模型改写为：</li></ul><script type="math/tex; mode=display">P(w_1, w_2, ...,w_T) \approx \prod_{t=1}^T P(w_t | w_{t - (n - 1)}, ..., w_{t-1})</script><ul><li><p>以上也叫<strong>n元语法</strong>（n-grams）。它是基于n−1阶⻢尔可夫链的概率语⾔模型</p></li><li><p>当n较小时，n元语法往往并不准确。当n较⼤时，n元语法需要计算并存储⼤量的词频和多词相邻频率。<strong>n权衡了计算复杂度和模型准确性</strong></p></li></ul><h1 id="2-循环神经网络（RNN）"><a href="#2-循环神经网络（RNN）" class="headerlink" title="2 循环神经网络（RNN）"></a>2 循环神经网络（RNN）</h1><ul><li>在n元语法中，时间步t的词 $w_t$ 基于前⾯所有词的条件概率只考虑了最近时间步的n − 1个词。如果要考虑⽐t − (n − 1)更早时间步的词对$w_t$的可能影响，我们需要增⼤n。但这样模型参数的数量将随之呈指数级增⻓</li><li>但是对于循环神经网络，它<strong>并⾮刚性地记忆所有固定⻓度的序列，而是通过隐藏状态来存储之前时间步的信息</strong></li></ul><h3 id="2-1-循环神经网络"><a href="#2-1-循环神经网络" class="headerlink" title="2.1 循环神经网络"></a>2.1 循环神经网络</h3><ul><li>假设<script type="math/tex">X_t \in \mathbb{R}^{n \times d}</script>是序列中时间步t的小批量输⼊， <script type="math/tex">H_t \in \mathbb{R}^{n \times h}</script>是该时间步的隐藏变量。与多层感知机不同的是，这⾥我们保存上⼀时间步的隐藏变量<script type="math/tex">H_{t−1}</script>，并引⼊⼀个新的权重参数<script type="math/tex">W_{hh} \in \mathbb{R}^{h×h}</script>，该参数⽤来描述在当前时间步如何使⽤上⼀时间步的隐藏变量。时间步t的隐藏变量的计算由当前时间步的输⼊和上⼀时间步的隐藏变量共同决定：</li></ul><script type="math/tex; mode=display">\boldsymbol{H}_{t}=\phi\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x h}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h h}+\boldsymbol{b}_{h}\right)</script><p>$\phi$是激活函数</p><ul><li><strong>这⾥的隐藏变量能够捕捉截⾄当前时间步的序列的历史信息</strong></li><li>每个时间步还有一个对应的输出：</li></ul><script type="math/tex; mode=display">\boldsymbol{O}_{t}=\boldsymbol{H}_{t} \boldsymbol{W}_{h q}+\boldsymbol{b}_{q}</script><p>在训练时，我们对每个时间步的输出层输出使⽤softmax运算，然后使⽤交叉熵损失函数来计算它与标签的误差</p><ul><li><strong>即便在不同时间步，循环神经网络也始终使⽤W， b这些模型参数。因此，循环神经网络模型参数的数量不随时间步的增加而增⻓</strong></li></ul><p><img src="https://s2.loli.net/2021/12/10/oAbwO43tDSTWpVg.png" alt="image-20211210101227481"></p><ul><li>隐藏状态中<script type="math/tex">X_{t}W_{x h}+H_{t-1} W_{h h}</script>的计算等价于<script type="math/tex">X_t</script>与<script type="math/tex">H_{t−1}</script>连结后的矩阵乘以<script type="math/tex">W_{xh}</script>与<script type="math/tex">W_{hh}</script>连结后的矩阵，实际上在代码实现中基本都是这么做的</li></ul><ul><li>举一个栗子：基于字符级循环神经网络的语⾔模型</li></ul><p><img src="https://s2.loli.net/2021/12/10/OYZwANsxl2oEQaI.png" alt="image-20211210101914126"></p><p><strong>标签序列依次为输入序列的下一个</strong>，并且在训练时，我们对每个时间步的输出层输出使⽤softmax运算，然后使⽤交叉熵损失函数来计算它与标签的误差</p><h3 id="2-2-时序数据的采样"><a href="#2-2-时序数据的采样" class="headerlink" title="2.2 时序数据的采样"></a>2.2 时序数据的采样</h3><ul><li>时序数据的⼀个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想” “要” “有” “直” “升”。<strong>该样本的标签序列为这些字符分别在训练集中的下⼀个字符</strong>，即 “要” “有” “直” “升” “机”。</li><li>我们有两种⽅式对时序数据进⾏采样，分别是随机采样和相邻采样</li></ul><h4 id="2-2-1-随机采样"><a href="#2-2-1-随机采样" class="headerlink" title="2.2.1 随机采样"></a>2.2.1 随机采样</h4><ul><li><p>在随机采样中，每个样本是原始序列上任意截取的⼀段序列。</p></li><li><p>相邻的两个随机小批量在原始序列上的位置不⼀定相毗邻。因此，我们⽆法⽤⼀个小批量最终时间步的隐藏状态来初始化下⼀个小批量的隐藏状态。<strong>在训练模型时，每次随机采样前都需要重新初始化隐藏状态</strong></p></li></ul><h4 id="2-2-2-相邻采样"><a href="#2-2-2-相邻采样" class="headerlink" title="2.2.2 相邻采样"></a>2.2.2 相邻采样</h4><ul><li>除对原始序列做随机采样之外，我们还可以令相邻的两个随机小批量在原始序列上的位置相毗邻。这时候，我们就<strong>可以⽤⼀个小批量最终时间步的隐藏状态来初始化下⼀个小批量的隐藏状态</strong>，从而使下⼀个小批量的输出也取决于当前小批量的输⼊</li></ul><ul><li><strong>两种采样方式的区别：</strong><ol><li>采用相邻采样，在训练模型时，我们只需在每⼀个迭代周期开始时初始化隐藏状态</li><li>当多个相邻小批量通过传递隐藏状态串联起来时，模型参数的梯度计算将依赖所有串联起来的小批量序列。同⼀迭代周期中，随着迭代次数的增加，梯度的<strong>计算开销会越来越⼤</strong>。为了使模型参数的梯度计算只依赖⼀次迭代读取的小批量序列，我们可以在每次读取小批量前将隐藏状态从计算图中分离出来</li><li><strong>相邻采样不能并行运算</strong>，因为必须等上一个小批量结束了，下一个小批量才能开始</li></ol></li></ul><h3 id="2-3-RNN的训练、预测"><a href="#2-3-RNN的训练、预测" class="headerlink" title="2.3 RNN的训练、预测"></a>2.3 RNN的训练、预测</h3><h4 id="2-3-1-输入输出"><a href="#2-3-1-输入输出" class="headerlink" title="2.3.1 输入输出"></a>2.3.1 输入输出</h4><ul><li>首先是RNN的输入输出，应该包含time_steps、batch_size、vocab_size（时间步、批量大小、词典大小）的维度，之所以有一个维度是词典大小，是因为我们会<strong>把输入输出用独热向量</strong>表示</li></ul><h4 id="2-3-2-预测"><a href="#2-3-2-预测" class="headerlink" title="2.3.2 预测"></a>2.3.2 预测</h4><ul><li><p><strong>在训练时，下一个时间步的输入可以：</strong></p><ol><li>上一个时间步的标签</li><li>上一个时间步的表征（也就是输出）</li></ol><p>采用第一种方法，<strong>更容易收敛，但是泛化能力更差</strong>，而第二种方法<strong>更不易收敛，但是泛化能力更强</strong></p></li><li><p><strong>但是在预测时</strong>，由于我们压根没有标签，所以只能用上述第二种方法。正是由于训练时和预测时干的事情都不一样，所以采用第一种方法泛化能力更差</p></li></ul><h4 id="2-3-3-困惑度"><a href="#2-3-3-困惑度" class="headerlink" title="2.3.3 困惑度"></a>2.3.3 困惑度</h4><ul><li>我们通常使⽤困惑度（perplexity）来评价语⾔模型的好坏</li><li>困惑度的基本思想是：<strong>给测试集的句子赋予较高概率值的语言模型较好，当语言模型训练完之后，测试集中的句子都是正常的句子，那么训练好的模型在测试集上的概率越高越好</strong></li><li>现在给定测试集上的一个句子序列<script type="math/tex">w_1, ..., w_t</script>，那么其困惑度为：</li></ul><script type="math/tex; mode=display">PP(w_1, ..., w_t) = P(w_1, ..., w_t)^{-\frac{1}{N}} = \sqrt[N]{\frac{1}{P\left(w_{1} w_{2} \ldots w_{N})\right.}}</script><p>可以看到，我们的<strong>目的是最大化获得测试集上的句子的概率</strong>，而最小化困惑度其实就是最大化这个概率，另外这里使用了一个几何平均，其目的是：</p><blockquote><ol><li>因为每个字符的概率必然小于1，所以越长的句子的概率在连乘的情况下必然越小，所以为了对长短句公平，需要平均一下</li><li>因为<strong>几何平均数</strong>的特点是，如果有其中的一个概率是很小的，那么最终的结果就不可能很大，从而要求好的句子的每个字符（即每个时间步的输出）都要有基本让人满意的概率</li></ol></blockquote><ul><li>采用unigram，假设每个时间步的预测是相互独立的：</li></ul><script type="math/tex; mode=display">PP(w_1, ..., w_t) = \sqrt[N]{\frac{1}{\prod_{i=1}^NP(w_i)}}</script><p>这是uni-gram（即当前词不取决于前面的词）的困惑度计算公式，针对不同近似的N元语法又不同的计算公式，比如bi-gram、tri-gram等。另外，里面的<script type="math/tex">P(w_i)</script>直接取输出层经过Softmax的概率值即可</p><ul><li>特别的：</li></ul><ol><li>最佳情况下，模型总是把标签类别的概率预测为1，此时困惑度为1</li><li>最坏情况下，模型总是把标签类别的概率预测为0，此时困惑度为正⽆穷</li><li>基线情况下，模型总是预测所有类别的概率都相同，此时困惑度为类别个数</li></ol><p><strong>显然，任何一个有效模型的困惑度必须小于类别个数（要不然模型的预测效果还不如随机点一个类别来的好）</strong></p><h4 id="2-3-4-通过时间反向传播"><a href="#2-3-4-通过时间反向传播" class="headerlink" title="2.3.4 通过时间反向传播"></a>2.3.4 通过时间反向传播</h4><ul><li>我们需要将循环神经网络按时间步展开，从而得到模型变量和参数之间的依赖关系，并依据链式法则应⽤反向传播计算并存储梯度</li><li>简单起⻅，我们考虑⼀个⽆偏差项的循环神经网络，且激活函数为恒等映射$（\phi(x) = x）$。设时间步t的输⼊为单样本$x_t \in R^d$，标签为$y_t$，那么隐藏状态$h_t \in R^h$的计算表达式为:</li></ul><script type="math/tex; mode=display">h_t = W_{hx}X_t + W_{hh}h_{t-1}</script><p>输出层变量$o_t \in \mathbb{R}^q$为：</p><script type="math/tex; mode=display">o_t = W_{qh}h_t</script><p>设时间步t的损失为$\ell(o_t, y_t)$。则总时间步数为T的损失函数L定义为：</p><script type="math/tex; mode=display">L = \frac{1}{T}\sum_{t = 1}^T \ell(o_t, y_t)</script><ul><li><p>我们假设一共有3个时间步数，那么可以做出计算图：<br><img src="https://s2.loli.net/2021/12/10/Feq2PM3nCslpGO7.png" alt="image-20211210132156070"></p></li><li><p>现在我们开始反向传播：</p></li></ul><p>易得：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol{o}_{t}}=\frac{\partial \ell\left(\boldsymbol{o}_{t}, y_{t}\right)}{T \cdot \partial \boldsymbol{o}_{t}}</script><p>然后可以得到：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol{W}_{q h}}=\sum_{t=1}^{T} \operatorname{prod}\left(\frac{\partial L}{\partial \boldsymbol{o}_{t}}, \frac{\partial \boldsymbol{o}_{t}}{\partial \boldsymbol{W}_{q h}}\right)=\sum_{t=1}^{T} \frac{\partial L}{\partial \boldsymbol{o}_{t}} \boldsymbol{h}_{t}^{\top} .</script><p>接下来就是计算关于<script type="math/tex">W_{hx}</script>和<script type="math/tex">W_{hh}</script>的梯度，那么必然要求关于各时间步隐藏状态的梯度，我们注意到隐藏状态之间也存在依赖关系，，L只通过<script type="math/tex">o_T</script>依赖最终时间步T的隐藏状态<script type="math/tex">h_T</script>。因此，我们先计算⽬标函数有关最终时间步隐藏状态的梯度：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol{h}_{T}}=\operatorname{prod}\left(\frac{\partial L}{\partial \boldsymbol{o}_{T}}, \frac{\partial \boldsymbol{o}_{T}}{\partial \boldsymbol{h}_{T}}\right)=\boldsymbol{W}_{q h}^{\top} \frac{\partial L}{\partial \boldsymbol{o}_{T}}</script><p>接下来对于时间步t &lt; T，在图6.3中，$L$通过$h_{t+1}$和$o_t$依赖$h_t$。依据链式法则，⽬标函数有关时间步t &lt; T的隐藏状态的梯度$\partial L / \partial h_t \in R^h$需要按照时间步从⼤到小依次计算:</p><script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol{h}_{t}}=\operatorname{prod}\left(\frac{\partial L}{\partial \boldsymbol{h}_{t+1}}, \frac{\partial \boldsymbol{h}_{t+1}}{\partial \boldsymbol{h}_{t}}\right)+\operatorname{prod}\left(\frac{\partial L}{\partial \boldsymbol{o}_{t}}, \frac{\partial \boldsymbol{o}_{t}}{\partial \boldsymbol{h}_{t}}\right)=\boldsymbol{W}_{h h}^{\top} \frac{\partial L}{\partial \boldsymbol{h}_{t+1}}+\boldsymbol{W}_{q h}^{\top} \frac{\partial L}{\partial \boldsymbol{o}_{t}} .</script><p>对次递归公式展开，我们可以得到对任意时间步1 ≤ t ≤ T，我们可以得到⽬标函数有关隐藏状态梯度的通项公式：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial \boldsymbol{h}_{t}}=\sum_{i=t}^{T}\left(\boldsymbol{W}_{h h}^{\top}\right)^{T-i} \boldsymbol{W}_{q h}^{\top} \frac{\partial L}{\partial \boldsymbol{o}_{T+t-i}}</script><p>通过关于每个时间步隐藏状态的梯度，易求得关于<script type="math/tex">W_{hx}</script>和<script type="math/tex">W_{hh}</script>的梯度。</p><ul><li><strong>由上式中的指数项可⻅，当时间步数T较⼤或者时间步t较小时，⽬标函数有关隐藏状态的梯度较容易出现衰减和爆炸</strong></li><li>RNN和一般的网络一样，我们在正向传播和反向传播的时候会进行一些数据的储存，避免重复计算</li></ul><h4 id="2-3-5-激活函数的选择"><a href="#2-3-5-激活函数的选择" class="headerlink" title="2.3.5 激活函数的选择"></a>2.3.5 激活函数的选择</h4><ul><li><p>对于下一个时间步隐藏状态的计算，激活函数一般选用Tanh或者ReLu。对输出的运算，一般做softmax运算。</p></li><li><p>但是很多时候还是选用Tanh而不是ReLu，这一点在Hinton的<a href="https://arxiv.org/abs/1504.00941">IRNN论文</a>里面是很明确的提到的：</p></li></ul><p><img src="https://pic2.zhimg.com/80/v2-2d19e8c9b39f40044853ea65f6edfb31_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>也就是说在RNN中直接把激活函数换成ReLu会导致非常大的输出值，因此它们可能更容易发生爆炸</strong></p><ul><li>下面具体来看一下：</li></ul><script type="math/tex; mode=display">\begin{array}{c}\text { net }_{t}=U x_{t}+W h_{t-1} \\h_{t}=f\left(\text { net }_{t}\right)\end{array}</script><p><strong>假设ReLu函数一直处于激活区域（即输入大于0）</strong>，则有<script type="math/tex">f(x) = x, net_t = Ux_t + W(Ux_{t-1} + Wh_{t-2})</script>，继续将其展开，最终会包含多个W的连乘，如果W不是单位矩阵， 那么最终的结果将会区域0或无穷。</p><p>但是在CNN中就不会发生这种问题，因为CNN中每一层的W是不同的，并且在初始化时它们是独立同分布的，因此可以相互抵消，在多层之后一般不会出现这种严重的数值问题</p><p>我们再来看看反向传播的时候：</p><script type="math/tex; mode=display">\frac{\partial h_t}{\partial h_{t-1}} = W</script><p>所以：</p><script type="math/tex; mode=display">\frac{\partial h_t}{\partial h_{1}} = W^n</script><p>可以看到只要W不是单位矩阵，梯度会出现消失或者爆炸的现象</p><p>而在使用tanh作为激活函数的时候：</p><script type="math/tex; mode=display">\frac{\partial h_{t}}{\partial h_{t-1}}=\left(1-h_{t}^{2}\right) W</script><p>可以证明，固定<script type="math/tex">h_{t-1}</script>时，<script type="math/tex">\left(1-h_{t}^{2}\right) W</script>是有界的（这个界可能不是1，但总归是有界的）</p><ul><li>综上所述：当采用ReLu作为激活函数时，只有W在单位矩阵附近时才能取得比较好的结果。<strong>而使用tanh函数，每个相邻时间步之间的梯度是有界的，减少了一些梯度爆炸的可能性（注意是梯度爆炸，而没有解决梯度消失）。</strong>但是ReLu也拥有自己的优点，那就是计算量更小，收敛更快，其实relu也可以配合梯度裁剪来使用，但是终归没有tanh好</li></ul><h3 id="2-4-梯度裁剪"><a href="#2-4-梯度裁剪" class="headerlink" title="2.4 梯度裁剪"></a>2.4 梯度裁剪</h3><ul><li>循环神经网络中较容易出现梯度衰减或梯度爆炸。<strong>为了应对梯度爆炸</strong>，我们可以裁剪梯度（clip gradient）。假设我们把所有模型参数梯度的元素拼接成⼀个向量 $g$，并设裁剪的阈值是$\theta$。裁剪后的梯度：</li></ul><script type="math/tex; mode=display">\min \left(\frac{\theta}{\|g\|}, 1\right) g</script><p>的$L_2$范数不超过$\theta$</p><ul><li><strong>但是梯度裁剪无法应对梯度衰减</strong></li></ul><h1 id="3-门控循环单元（GRU）"><a href="#3-门控循环单元（GRU）" class="headerlink" title="3 门控循环单元（GRU）"></a>3 门控循环单元（GRU）</h1><ul><li>我们发现，当时间步数较⼤或者时间步较小时，循环神经网络的梯度较容易出现衰减或爆炸。虽然裁剪梯度可以应对梯度爆炸，但⽆法解决梯度衰减的问题。通常由于这个原因，<strong>循环神经网络在实际中较难捕捉时间序列中时间步距离较大的依赖关系</strong></li><li>门控循环神经网络（gated recurrent neural network）的提出，正是为了更好地捕捉时间序列中时间步距离较⼤的依赖关系。它通过可以学习的⻔来控制信息的流动。其中，门控循环单元（gated recurrent unit，GRU）是⼀种常⽤的⻔控循环神经网</li></ul><h3 id="3-1-重置门和更新门"><a href="#3-1-重置门和更新门" class="headerlink" title="3.1 重置门和更新门"></a>3.1 重置门和更新门</h3><ul><li>⻔控循环单元中的重置⻔和更新⻔的输⼊均为当前时间步输⼊<script type="math/tex">X_t</script>与上⼀时间步隐藏状态<script type="math/tex">H_{t−1}</script>，输出由激活函数为sigmoid函数的全连接层计算得到。</li></ul><p><img src="https://zlkqzimg-1310374208.cos.ap-chengdu.myqcloud.com/image-20211210135706726.png" alt="image-20211210135706726"></p><p>具体来说，重置门$R_t \in \mathbb{R}^{n \times h}$和更新门$Z_t \in \mathbb{R}^{n \times h}$的计算如下：</p><script type="math/tex; mode=display">\begin{array}{l}\boldsymbol{R}_{t}=\sigma\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x r}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h r}+\boldsymbol{b}_{r}\right) \\\boldsymbol{Z}_{t}=\sigma\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x z}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h z}+\boldsymbol{b}_{z}\right)\end{array}</script><h3 id="3-2-候选隐藏状态"><a href="#3-2-候选隐藏状态" class="headerlink" title="3.2 候选隐藏状态"></a>3.2 候选隐藏状态</h3><ul><li><p>我们将当前时间步重置⻔的输出与上⼀时间步隐藏状态做按元素乘法（符号为$\odot$）。如果重置⻔中元素值接近0，那么意味着重置对应隐藏状态元素为0，即丢弃上⼀时间步的隐藏状态。如果元素值接近1，那么表⽰保留上⼀时间步的隐藏状态。然后，将按元素乘法的结果与当前时间步的输⼊连结，再通过含激活函数tanh的全连接层计算出候选隐藏状态</p></li><li><p>具体来说，时间步t的候选隐藏状态$\tilde{H}_t \in \mathbb{R}^{n \times h}$的计算为：</p></li></ul><script type="math/tex; mode=display">\tilde{\boldsymbol{H}}_{t}=\tanh \left(\boldsymbol{X}_{t} \boldsymbol{W}_{x h}+\left(\boldsymbol{R}_{t} \odot \boldsymbol{H}_{t-1}\right) \boldsymbol{W}_{h h}+\boldsymbol{b}_{h}\right),</script><ul><li><p><strong>重置门控制了上⼀时间步的隐藏状态如何流⼊当前时间步的候选隐藏状态。而上⼀时间步的隐藏状态可能包含了时间序列截⾄上⼀时间步的全部历史信息。因此，重置门可以⽤来丢弃与预测⽆关的历史信息</strong></p></li><li><p>最后，时间步t的隐藏状态<script type="math/tex">H_t \in \mathbb{R}^{n×h}</script>的计算使⽤当前时间步的更新门<script type="math/tex">Z_t</script>来对上⼀时间步的隐藏状态<script type="math/tex">H_{t−1}</script>和当前时间步的候选隐藏状态<script type="math/tex">\tilde{H}_t</script>做组合：</p></li></ul><script type="math/tex; mode=display">\boldsymbol{H}_{t}=\boldsymbol{Z}_{t} \odot \boldsymbol{H}_{t-1}+\left(1-\boldsymbol{Z}_{t}\right) \odot \tilde{\boldsymbol{H}}_{t}</script><p><img src="https://s2.loli.net/2021/12/10/L7O69pm3Yjzbno5.png" alt="image-20211210141824572"></p><ul><li><strong>更新门可以控制隐藏状态应该如何被包含当前时间步信息的候选隐藏状态所更新</strong>。假设更新⻔在时间步$t’$到$t（t’ &lt; t）$之间⼀直近似1。那么，<strong>在时间步$t’$到$t$之间的输⼊信息⼏乎没有流⼊时间步$t$的隐藏状态$H_t$</strong>。实际上，<strong>这可以看作是较早时刻的隐藏状态$H_{t’−1}$⼀直通过时间保存并传递⾄当前时间步$t$</strong>。这个设计可以应对循环神经网络中的梯度衰减问题，并更好地捕捉时间序列中时间步距离较⼤的依赖关系</li><li>我们稍作总结：</li></ul><ol><li>重置⻔有助于捕捉时间序列⾥短期的依赖关系</li><li>更新⻔有助于捕捉时间序列⾥⻓期的依赖关系</li><li>重置门和更新门为0、1的情况：</li></ol><div class="table-container"><table><thead><tr><th>对应情况</th><th>重置门</th><th>更新门</th></tr></thead><tbody><tr><td>退化为一般的RNN</td><td>1</td><td>0</td></tr><tr><td>丢弃当前时间步的全部信息，只保留历史信息</td><td>0或1</td><td>1</td></tr><tr><td>完全丢弃历史信息，只保留当前时间步的信息</td><td>0</td><td>0</td></tr></tbody></table></div><h1 id="4-长短期记忆（LSTM）"><a href="#4-长短期记忆（LSTM）" class="headerlink" title="4 长短期记忆（LSTM）"></a>4 长短期记忆（LSTM）</h1><ul><li>还有另外一种十分常用的门控循环神经网络：⻓短期记忆（long short-term memory，LSTM）</li><li><strong>LSTM之所以叫做长短期记忆，是因为里面的两个记忆变量：隐藏状态<script type="math/tex">H_t</script>负责短期记忆，记忆细胞<script type="math/tex">C_t</script>负责长期记忆（因为每个时间步中<script type="math/tex">H_t</script>相比于<script type="math/tex">C_t</script>更新的更多，所以负责短期）</strong></li></ul><h3 id="4-1-输⼊门、遗忘门、输出门和候选记忆细胞"><a href="#4-1-输⼊门、遗忘门、输出门和候选记忆细胞" class="headerlink" title="4.1 输⼊门、遗忘门、输出门和候选记忆细胞"></a>4.1 输⼊门、遗忘门、输出门和候选记忆细胞</h3><ul><li>与门控循环单元中的重置门和更新门⼀样，⻓短期记忆的门的输⼊均为当前时间步输⼊<script type="math/tex">X_t</script>与上⼀时间步隐藏状态<script type="math/tex">H_{t−1}</script>，输出由激活函数为sigmoid函数的全连接层计算得到</li><li>⻓短期记忆需要计算候选记忆细胞$\tilde{C}_t$。它的计算与上⾯介绍的3个⻔类似，但使⽤了值域在[−1, 1]的tanh函数作为激活函数:</li></ul><p><img src="https://s2.loli.net/2021/12/10/jzn954wmEqRfyIg.png" alt="image-20211210144009641"></p><ul><li>时间步t的输⼊⻔$I_t \in R^{n×h}$、遗忘⻔$F_t \in R^{n×h}$和输出⻔$O_t \in R^{n×h}$分别计算如下：</li></ul><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{I}_{t} &=\sigma\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x i}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h i}+\boldsymbol{b}_{i}\right), \\\boldsymbol{F}_{t} &=\sigma\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x f}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h f}+\boldsymbol{b}_{f}\right), \\\boldsymbol{O}_{t} &=\sigma\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x o}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h o}+\boldsymbol{b}_{o}\right), \\\tilde{\boldsymbol{C}}_{t}&=\tanh \left(\boldsymbol{X}_{t} \boldsymbol{W}_{x c}+\boldsymbol{H}_{t-1} \boldsymbol{W}_{h c}+\boldsymbol{b}_{c}\right),\end{aligned}</script><h3 id="4-2-记忆细胞"><a href="#4-2-记忆细胞" class="headerlink" title="4.2 记忆细胞"></a>4.2 记忆细胞</h3><ul><li>当前时间步记忆细胞$C_t \in R^{n\times h}$的计算组合了上⼀时间步记忆细胞和当前时间步候选记忆细胞的信息，并通过遗忘⻔和输⼊⻔来控制信息的流动：</li></ul><script type="math/tex; mode=display">\boldsymbol{C}_{t}=\boldsymbol{F}_{t} \odot \boldsymbol{C}_{t-1}+\boldsymbol{I}_{t} \odot \tilde{\boldsymbol{C}}_{t}</script><ul><li>遗忘门控制上⼀时间步的记忆细胞$C_{t−1}$中的信息是否传递到当前时间步，而输⼊门则控制当前时间步的输⼊$X_t$通过候选记忆细胞$\tilde{C}_t$如何流⼊当前时间步的记忆细胞。如果遗忘门⼀直近似1且输⼊门⼀直近似0，过去的记忆细胞将⼀直通过时间保存并传递⾄当前时间步</li></ul><h3 id="4-3-隐藏状态"><a href="#4-3-隐藏状态" class="headerlink" title="4.3 隐藏状态"></a>4.3 隐藏状态</h3><ul><li>有了记忆细胞以后，接下来我们还可以通过输出门来控制从记忆细胞到隐藏状态$H_t \in R^{n×h}$的信息的流动：</li></ul><script type="math/tex; mode=display">H_t = O_t \odot tanh(C_t)</script><ul><li>当输出门近似1时，记忆细胞信息将传递到隐藏状态供输出层使⽤；当输出门近似0时，记忆细胞信息只⾃⼰保留</li></ul><p><img src="https://s2.loli.net/2021/12/10/mlYhrVbA47MByvG.png" alt="image-20211210145754660"></p><h3 id="4-4-三种门的作用"><a href="#4-4-三种门的作用" class="headerlink" title="4.4 三种门的作用"></a>4.4 三种门的作用</h3><ul><li><strong>输入门控制当前计算的新状态以多大程度更新到记忆单元中</strong></li><li><strong>遗忘门控制前一步记忆单元中的信息有多大程度被遗忘掉</strong></li><li><strong>输出门控制当前的输出有多大程度取决于当前的记忆单元</strong></li><li>在一个训练好的网络中：</li></ul><ol><li>当输入的序列中没有重要信息时，LSTM的遗忘门接近于1，输入门接近于0，此时过去的记忆会被保存，从而实现了长期记忆功能</li><li>当输入的序列中出现了重要的信息时，LSTM应当把其存入记忆中，此时其输入门的值会接近1</li><li>当输入的序列中出现了重要的信息，且该信息意味着之前的记忆不再重要时，输入门的值接近1，而遗忘门的值接近于0，这样旧的记忆被遗忘，新的重要信息被记忆</li></ol><h3 id="4-5-LSTM各模块激活函数"><a href="#4-5-LSTM各模块激活函数" class="headerlink" title="4.5 LSTM各模块激活函数"></a>4.5 LSTM各模块激活函数</h3><ul><li>LSTM中，三种门都用的Sigmoid函数，生成候选记忆时，使用Tanh作为激活函数。值得注意的是，<strong>这两个激活函数都是饱和的</strong>，也就是说在输入达到一定值的情况下，输出就不发生明显变化了。如果使用的是非饱和的激活函数，例如ReLu，将难以实现门控的效果</li><li>Sigmoid的输出在0到1之间，符合门控的物理定义。且当输入较大或较小时，输出会非常接近1或0，从而保证门开或门关</li><li>在生成候选记忆时，使用Tanh函数，是因为其输出在-1到1之间，这与大多数场景下特征分布是zero-centered吻合</li><li>此为Tanh函数在输入为0附近相比于Sigmoid有更大的梯度，通常收敛更快</li></ul><h1 id="5-门控机制是如何解决RNN的问题的"><a href="#5-门控机制是如何解决RNN的问题的" class="headerlink" title="5 门控机制是如何解决RNN的问题的"></a>5 门控机制是如何解决RNN的问题的</h1><ul><li>上面我们说到，RNN最大的一个问题就是无法捕捉长距离依赖，而引入门控机制就是为了解决这个问题，这里我们以LSTM举例：</li></ul><script type="math/tex; mode=display">\begin{aligned}f_{t} &=\sigma\left(W_{f} x_{t}+U_{f} h_{t-1}+b_{f}\right) \\i_{t} &=\sigma\left(W_{i} x_{t}+U_{i} h_{t-1}+b_{i}\right) \\o_{t} &=\sigma\left(W_{o} x_{t}+U_{o} h_{t-1}+b_{o}\right) \\\hat{c}_{t} &=\tanh \left(W_{c} x_{t}+U_{c} h_{t-1}+b_{c}\right) \\c_{t} &=f_{t} \circ c_{t-1}+i_{t} \circ \hat{c}_{t} \\h_{t} &=o_{t} \circ \tanh \left(c_{t}\right)\end{aligned}</script><ul><li>我们可以像上面2.3.5激活函数的选择中一样，探讨<script type="math/tex">\frac{\partial h_t}{\partial h_{t-1}}</script>，但是因为<script type="math/tex">h_{t} =o_{t} \circ \tanh(c_t)</script>，所以同样可以分析<script type="math/tex">\frac{c_t}{c_{t-1}}</script>，而后者更简单些，所以分析后者：</li></ul><script type="math/tex; mode=display">\frac{\partial c_{t}}{\partial c_{t-1}}=f_{t}+c_{t-1} \frac{\partial f_{t}}{\partial c_{t-1}}+\hat{c} t \frac{\partial i_{t}}{\partial c_{t-1}}+i_{t} \frac{\partial \hat{c}_{t}}{\partial c_{t-1}}</script><ul><li><p>上式总共有4项，<strong>梯度主要取决于第一项<script type="math/tex">f_t</script></strong>，由于<script type="math/tex">f_t \in (0,1)</script>，所以梯度爆炸的风险减小，而是否会发生梯度小时，取决于每个时间步的<script type="math/tex">f_t</script>是否接近1，但是这里有个自洽的结论：<strong>如果我们的任务比较依赖于历史信息，那么<script type="math/tex">f_t</script>就会接近于1，这时候历史的梯度信息也正好不容易消失；如果<script type="math/tex">f_t</script>很接近于0，那么就说明我们的任务不依赖于历史信息，这时候就算梯度消失也无妨了。</strong></p></li><li><p>而后面3项都不是决定梯度的主要因素，挑<script type="math/tex">c_{t-1} \frac{\partial f_{t}}{\partial c_{t-1}}</script>来说明，带入<script type="math/tex">h_{t-1} =o_{t-1} \circ \tanh(c_{t-1})</script>，可以得到：</p></li></ul><script type="math/tex; mode=display">c_{t-1} \frac{\partial f_{t}}{\partial c_{t-1}} = c_{t-1} \frac{\partial f_{t}}{\partial h_{t-1}}  \frac{\partial h_{t-1}}{\partial c_{t-1}} = f_{t}\left(1-f_{t}\right) o_{t-1}\left(1-\tanh ^{2} c_{t-1}\right) c_{t-1} U_{f}</script><ul><li><p>由于<script type="math/tex">f_t,(1-f_t),o_{t-1} \in (0,1)</script>，并且可以证明<script type="math/tex">|\left(1-\tanh ^{2} c_{t-1}\right)c_{t-1}| <0.45</script>，所以结果相当于<script type="math/tex">U_f</script>乘上四个门，结果会非常的小，所以不起主导作用。其他两项是同样的方法</p></li><li><p><strong>注意：LSTM和GRU只是很大的缓解了梯度消失，但是如果时间步很长，成千上万步，仍然会发生梯度消失，毕竟记忆单元压根存不了那么多信息</strong></p></li><li><p>另外，一般LSTM要比GRU要好一些，但是到底好在哪里呢，在GRU中同样进行反向传播的分析：</p></li></ul><script type="math/tex; mode=display">\begin{aligned}\frac{\partial h_{t}}{\partial h_{t-1}}=& 1-z_{t}-z_{t}\left(1-z_{t}\right) h_{t-1} U_{z}+z_{t}\left(1-z_{t}\right) \hat{h}_{t} U_{z} \\&+\left(1-\hat{h}_{t}^{2}\right) r_{t}\left(1+\left(1-r_{t}\right) h_{t-1} U_{r}\right) z_{t} U_{h}\end{aligned}</script><ul><li>上式其主导作用的同样是<script type="math/tex">1-z_t</script>，但是后面的项相比于LSTM只有3个门的连乘（LSTM有4个），所以这些想对梯度的影响可能大一些，所以<strong>LSTM的梯度要比GRU稳定一些，所以GRU更依赖于初始化</strong></li></ul><h1 id="6-深度循环神经网络"><a href="#6-深度循环神经网络" class="headerlink" title="6 深度循环神经网络"></a>6 深度循环神经网络</h1><ul><li>到⽬前为⽌介绍的循环神经网络只有⼀个单向的隐藏层，在深度学习应⽤⾥，我们通常会⽤到含有多个隐藏层的循环神经网络，也称作深度循环神经网络</li><li>下图演⽰了⼀个有L个隐藏层的深度循环神经网络，<strong>每个隐藏状态不断传递⾄当前层的下⼀时间步和当前时间步的下⼀层</strong></li></ul><p><img src="https://s2.loli.net/2021/12/10/PUK7CRjyemEbzLM.png" alt="image-20211210150125737"></p><ul><li>第1隐藏层的隐藏状态和之前的计算⼀样：</li></ul><script type="math/tex; mode=display">\boldsymbol{H}_{t}^{(1)}=\phi\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x h}^{(1)}+\boldsymbol{H}_{t-1}^{(1)} \boldsymbol{W}_{h h}^{(1)}+\boldsymbol{b}_{h}^{(1)}\right)</script><ul><li>当1 &lt; l ≤ L时，第l隐藏层的隐藏状态的表达式为:</li></ul><script type="math/tex; mode=display">\boldsymbol{H}_{t}^{(l)}=\phi\left(\boldsymbol{H}_{t}^{(l-1)} \boldsymbol{W}_{x h}^{(l)}+\boldsymbol{H}_{t-1}^{(l)} \boldsymbol{W}_{h h}^{(l)}+\boldsymbol{b}_{h}^{(l)}\right)</script><ul><li>最终，输出层的输出只需基于第L隐藏层的隐藏状态：</li></ul><script type="math/tex; mode=display">\boldsymbol{O}_{t}=\boldsymbol{H}_{t}^{(L)} \boldsymbol{W}_{h q}+\boldsymbol{b}_{q}</script><ul><li><p>同多层感知机⼀样，隐藏层个数L是超参数</p></li><li><p><strong>RNN中选择深度网络的原因和一般前馈神经网络一样，都是为了能够用来表征更复杂的情况</strong></p></li></ul><h1 id="7-双向循环神经网络"><a href="#7-双向循环神经网络" class="headerlink" title="7 双向循环神经网络"></a>7 双向循环神经网络</h1><ul><li>之前介绍的循环神经网络模型都是假设当前时间步是由前⾯的较早时间步的序列决定的，因此它们都将信息通过隐藏状态从前往后传递。有时候，当前时间步也可能由后⾯时间步决定。例如，当我们写下⼀个句⼦时，可能会根据句⼦后⾯的词来修改句⼦前⾯的⽤词</li><li><strong>双向循环神经网络通过增加从后往前传递信息的隐藏层来更灵活地处理这类信息</strong>，下图演⽰了⼀个含单隐藏层的双向循环神经网络的架构</li></ul><p><img src="https://s2.loli.net/2021/12/10/VtFmigZ58qw2aeb.png" alt="image-20211210151934211"></p><ul><li>具体来看，设时间步t正向隐藏状态为$\overrightarrow{H}_t \in R^{n×h}$（正向隐藏单元个数为h），反向隐藏状态为$\overleftarrow{H}_t \in R^{n×h}$（反向隐藏单元个数为h）。我们可以分别计算正向隐藏状态和反向隐藏状态：</li></ul><script type="math/tex; mode=display">\begin{array}{l}\overrightarrow{\boldsymbol{H}}_{t}=\phi\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x h}^{(f)}+\overrightarrow{\boldsymbol{H}}_{t-1} \boldsymbol{W}_{h h}^{(f)}+\boldsymbol{b}_{h}^{(f)}\right) \\\overleftarrow{\boldsymbol{H}}_{t}=\phi\left(\boldsymbol{X}_{t} \boldsymbol{W}_{x h}^{(b)}+\overleftarrow{\boldsymbol{H}}_{t+1} \boldsymbol{W}_{h h}^{(b)}+\boldsymbol{b}_{h}^{(b)}\right)\end{array}</script><p><strong>然后我们连结两个⽅向的隐藏状态$\overrightarrow{H}_t$和 $\overleftarrow{H}_t$来得到隐藏状态$H_t \in R^{n×2h}$</strong>，并将其输⼊到输出层。 输出层计算输出$O_t \in R^{n×q}$（输出个数为q）：</p><script type="math/tex; mode=display">O_t = H_tW_{hq} + b_q</script><ul><li><strong>不同方向的隐藏状态的隐藏单元个数也可以不同</strong></li><li>双向循环神经网络在每个时间步的隐藏状态同时取决于该时间步之前和之后的⼦序列（包括当前时间步的输⼊）</li></ul><h1 id="8-Seq2Seq模型"><a href="#8-Seq2Seq模型" class="headerlink" title="8 Seq2Seq模型"></a>8 Seq2Seq模型</h1><ul><li>在许多时候，输入和输出都是不定长序列，这采用一般的RNN肯定是行不通的。以机器翻译为例，输⼊可以是⼀段不定⻓的英语⽂本序列，输出可以是⼀段不定⻓的法语⽂本序列，例如：英语输⼊：“They”、“are”、“watching”、“.” ； 法语输出：“Ils”、“regardent”、“.”</li><li>当输⼊和输出都是不定⻓序列时，我们可以使⽤seq2seq模型，本质上都⽤到了两个循环神经网络，分别叫做编码器和解码器。<strong>编码器用来分析输⼊序列，解码器⽤来生成输出序列</strong></li></ul><p><img src="https://s2.loli.net/2021/12/10/FQfVxdq2wuC7aSs.png" alt="image-20211210170200879"></p><ul><li>&lt; bos &gt;（beginning of sequence）和 &lt; eos &gt;（end of sequence）分别表示序列的开始和结束</li><li>编码器每个时间步的输⼊依次为英语句⼦中的单词、标点和特殊符号。上图中使⽤了编码器在最终时间步的隐藏状态作为输⼊句⼦的表征或编码信息。解码器在各个时间步中使⽤输⼊句⼦的编码信息和上个时间步的输出以及隐藏状态作为输⼊</li></ul><h3 id="8-1-编码器"><a href="#8-1-编码器" class="headerlink" title="8.1 编码器"></a>8.1 编码器</h3><ul><li><strong>编码器的作⽤是把⼀个不定⻓的输⼊序列变换成⼀个定⻓的背景变量$c$，并在该背景变量中编码输⼊序列信息</strong>。编码器可以使⽤循环神经网络</li><li>编码器通过⾃定义函数q将各个时间步的隐藏状态变换为背景变量</li></ul><script type="math/tex; mode=display">c = q(h_1, ...,h_T)</script><ul><li><strong>也可以使⽤双向循环神经网络构造编码器</strong>，在这种情况下，编码器每个时间步的隐藏状态同时取决于该时间步之前和之后的⼦序列（包括当前时间步的输⼊），并编码了整个序列的信息。</li></ul><h3 id="8-2-解码器"><a href="#8-2-解码器" class="headerlink" title="8.2 解码器"></a>8.2 解码器</h3><ul><li>解码器就是通过编码器输出的背景向量$c$，和每一个时间步的输入，输出所需要的结果</li><li><strong>解码器在预测和训练时是不一样的</strong>，我们先介绍<strong>预测</strong>时的解码器：</li></ul><p>编码器输出的背景变量$c$编码了整个输⼊序列<script type="math/tex">x_1, . . . , x_T</script>的信息。给定训练样本中的输出序列<script type="math/tex">y_1, y_2, . . . , y_{T'}</script>，对每个时间步<script type="math/tex">t'</script>（符号与输⼊序列或编码器的时间步<script type="math/tex">t</script>有区别），解码器输出<script type="math/tex">y_{t'}</script>的条件概率将基于之前的输出序列<script type="math/tex">y_1, . . . , y_{t'−1}</script>和背景变量<script type="math/tex">c</script>，即<script type="math/tex">P(y_{t'} | y_1, . . . , y_{t'−1}, c)</script></p><p>为此，我们可以使⽤另⼀个循环神经网络作为解码器。在输出序列的时间步<script type="math/tex">t'</script>，解码器将上⼀时间步的输出<script type="math/tex">y_{t'−1}</script>以及背景变量<script type="math/tex">c</script>作为输⼊，并将它们与上⼀时间步的隐藏状态<script type="math/tex">s_{t'−1}</script>变换为当前时间步的隐藏状态<script type="math/tex">s_{t'}</script>：</p><script type="math/tex; mode=display">s_{t'} = g(y_{t' -1}, c, s_{t' - 1})</script><p>有了解码器的隐藏状态后，我们可以使⽤⾃定义的输出层和softmax运算来计算<script type="math/tex">P(y_{t'} | y_1, . . . , y_{t'−1}, c)</script></p><ul><li><strong>训练</strong>时的解码器，每一时间步的输入序列可以是上一时间步的输出，也可以是上一时间步的真实标签序列。后者叫做<strong>强制教学</strong></li></ul><p>根据最大似然估计，我们可以最大化输出序列基于输入序列的条件概率：</p><script type="math/tex; mode=display">\begin{aligned}P\left(y_{1}, \ldots, y_{T^{\prime}} \mid x_{1}, \ldots, x_{T}\right) &=\prod_{t^{\prime}=1}^{T^{\prime}} P\left(y_{t^{\prime}} \mid y_{1}, \ldots, y_{t^{\prime}-1}, x_{1}, \ldots, x_{T}\right) \\&=\prod_{t^{\prime}=1}^{T^{\prime}} P\left(y_{t^{\prime}} \mid y_{1}, \ldots, y_{t^{\prime}-1}, c\right)\end{aligned}</script><p>并得到该输出序列的损失：</p><script type="math/tex; mode=display">-\log P\left(y_{1}, \ldots, y_{T^{\prime}} \mid x_{1}, \ldots, x_{T}\right)=-\sum_{t^{\prime}=1}^{T^{\prime}} \log P\left(y_{t^{\prime}} \mid y_{1}, \ldots, y_{t^{\prime}-1}, c\right)</script><p>在模型训练中，所有输出序列损失的均值通常作为需要最小化的损失函数</p><h3 id="8-3-预测时的搜索方式"><a href="#8-3-预测时的搜索方式" class="headerlink" title="8.3 预测时的搜索方式"></a>8.3 预测时的搜索方式</h3><h4 id="8-3-1-贪婪搜索"><a href="#8-3-1-贪婪搜索" class="headerlink" title="8.3.1 贪婪搜索"></a>8.3.1 贪婪搜索</h4><ul><li>贪婪搜索（greedy search）。对于输出序列任⼀时间步$t’$，我 们从$|Y|$（Y为词典）个词中搜索出条件概率最⼤的词：</li></ul><script type="math/tex; mode=display">y_{t'} = argmax_{y \in Y}P(y|y_1, ..., y_{t' - 1}, c)</script><p>作为输出。⼀旦搜索出“&lt; eos &gt;”符号，或者输出序列⻓度已经达到了最⼤⻓度$T’$，便完成输出。</p><ul><li>我们将该条件概率最⼤的输出序列称为<strong>最优输出序列</strong>，<strong>而贪婪搜索无法保证得到最优输出序列</strong>，下面举个栗子：</li></ul><blockquote><p>假设输出词典⾥⾯有“A” “B” “C” 和“&lt; eos &gt;”这4个词。下图中每个时间步下的4个数字分别代表了该时间步⽣成“A” “B” “C” 和“&lt; eos &gt;”这4个词的条件概率。在每个 间步，贪婪搜索选取条件概率最⼤的词。因此，将⽣成输出序列“A” “B” “C” “&lt; eos &gt;”。 该输出序列的条件概率是0.5 × 0.4 × 0.4 × 0.6 = 0.048</p></blockquote><p><img src="https://s2.loli.net/2021/12/10/JUgILXFCjWviaQw.png" alt="image-20211210180148791"></p><blockquote><p>但是现在我们考虑下面一种情况，在时间步2中选取了条件概率第⼆⼤的词“C”，<strong>由于之后时间步的概率值是基于前面的时间步的，所以时间步2结果选取的改变，会导致后续的概率发生改变</strong>，如下图，所以我们现在的输出序列“A” “C” “B” “&lt; eos &gt;”的条件概率是0.5 × 0.3 × 0.6 × 0.6 = 0.054，大于贪婪搜索的概率，所以贪婪搜索得到的不是最优的</p></blockquote><p><img src="https://s2.loli.net/2021/12/10/zSKDLamFWqseyuN.png" alt="image-20211210180404095"></p><h4 id="8-3-2-穷举搜索"><a href="#8-3-2-穷举搜索" class="headerlink" title="8.3.2 穷举搜索"></a>8.3.2 穷举搜索</h4><ul><li>我们可以考虑穷举搜索（exhaustive search）：穷举所有可能的输出序列，输出条件概率最⼤的序列</li><li><strong>虽然穷举搜索可以得到最优输出序列，但它的计算开销$O(|Y|^{T’})$很容易过⼤</strong>，而贪婪搜索的开销为$O(|Y|T’)$，明显小于穷举搜索</li></ul><h4 id="8-3-3-束搜索"><a href="#8-3-3-束搜索" class="headerlink" title="8.3.3 束搜索"></a>8.3.3 束搜索</h4><ul><li><p>束搜索（beam search）是对贪婪搜索的⼀个改进算法。它有⼀个<strong>束宽</strong>（beam size）超参数。我们将它设为k。在时间步1时，选取当前时间步条件概率最⼤的k个词，分别组成k个候选输出序列的⾸词。在之后的每个时间步，基于上个时间步的k个候选输出序列，从k$ |Y|$个可能的输出序列中选取条件概率最⼤的k个，作为该时间步的候选输出序列。最终，<strong>我们从各个时间步的候选输出序列中筛选出包含特殊符号“&lt; eos &gt;”的序列，并将它们中所有特殊符号“&lt; eos &gt;”后⾯的⼦序列舍弃</strong>，得到最终候选输出序列的集合</p></li><li><p>下面举个栗子：</p></li></ul><p><img src="https://s2.loli.net/2021/12/10/QEBb3gUVxmuDS7O.png" alt="image-20211210182131362"></p><p>第一个时间步找出概率最大的”A”和”C”，然后再根据”A”和”C”，在时间步2中寻找概率最大的2个，分别为”AB”和”CE”，再根据这两个，在时间步3，输出”ABD”和”CED”，最后减去&lt; eos &gt;符号以后的内容，得出输出序列</p><ul><li>在最终候选输出序列的集合中，我们取以下分数最⾼的序列作为输出序列：</li></ul><script type="math/tex; mode=display">\frac{1}{L^{\alpha}} \log P\left(y_{1}, \ldots, y_{L}\right)=\frac{1}{L^{\alpha}} \sum_{t^{\prime}=1}^{L} \log P\left(y_{t^{\prime}} \mid y_{1}, \ldots, y_{t^{\prime}-1}, c\right)</script><p>其中$L$为最终候选序列⻓度，$\alpha$⼀般可选为0.75。分⺟上的$L^{\alpha}$是为了惩罚较⻓序列在以上分数中较多的对数相加项</p><ul><li>束搜索的计算开销为$O(k|Y|T’)$，介于贪婪搜索和穷举搜索之间</li><li><strong>束搜索通过灵活的束宽来权衡计算开销和搜索质量</strong></li></ul><h3 id="8-4-注意力机制"><a href="#8-4-注意力机制" class="headerlink" title="8.4 注意力机制"></a>8.4 注意力机制</h3><h4 id="8-4-1-seq2seq中的注意力机制"><a href="#8-4-1-seq2seq中的注意力机制" class="headerlink" title="8.4.1 seq2seq中的注意力机制"></a>8.4.1 seq2seq中的注意力机制</h4><ul><li><strong>解码器在⽣成输出序列中的每⼀个词时可能只需利⽤输⼊序列某⼀部分的信息， 而不需要由整个输入序列生成的背景向量</strong>，例如，在输出序列的时间步1，解码器可以主要依赖“They” “are” 的信息来⽣成“Ils”，在时间步2则主要使⽤来⾃“watching”的编码信息⽣成“regardent”，而不需要”They are watching”整个句子</li><li><p>若没引入注意力机制，在实际使用中，那么会发现随着输入序列的增长，模型的性能发生了显著下降。<strong>这是因为编码时输入序列的全部信息压缩到了一个向量中，随着序列的增长，越前面的词丢失越严重</strong>。<strong>同时，seq2seq模型的输出序列中，常常会损失部分输入序列的信息，这是因为在解码时，当前词对应的源语言词的上下文信息和位置信息在编解码过程中丢失了</strong></p></li><li><p>注意⼒机制通过对编码器所有时间步的隐藏状态做<strong>加权平均</strong>来得到背景变量。解码器在每⼀时间步调整这些权重，即注意力权重，从而能够在不同时间步分别关注输入序列中的不同部分并编码进相应时间步的背景变量</p></li></ul><p><img src="https://s2.loli.net/2021/12/10/5kGV8uqeaYn3wlF.png" alt="image-20211210184622950"></p><p>⾸先，函数a根据解码器在时间步1的隐藏状态和编码器在各个时间步的隐藏状态计算softmax运算的输⼊。softmax运算输出概率分布并对编码器各个时间步的隐藏状态做加权平均，从而得到背景变量</p><ul><li>具体来说，令编码器在时间步t的隐藏状态为$h_t$，且总时间步数为T。那么解码器在时间步$t’$（$t’$代表的是解码器的时间步数）的背景变量为所有编码器隐藏状态的加权平均：</li></ul><script type="math/tex; mode=display">\boldsymbol{c}_{t^{\prime}}=\sum_{t=1}^{T} \alpha_{t^{\prime} t} \boldsymbol{h}_{t}</script><p>其中给定$t’$时，权重$\alpha_{t’t}$在$t = 1, . . . , T$的值是⼀个概率分布。为了得到概率分布，我们可以使⽤softmax运算:</p><script type="math/tex; mode=display">\alpha_{t^{\prime} t}=\frac{\exp \left(e_{t^{\prime} t}\right)}{\sum_{k=1}^{T} \exp \left(e_{t^{\prime} k}\right)}, \quad t=1, \ldots, T</script><p>由于<script type="math/tex">e_{t't}</script>同时取决于解码器的时间步<script type="math/tex">t'</script>和编码器的时间步t，我们不妨以解码器在时间步<script type="math/tex">t'− 1</script>的隐藏状态<script type="math/tex">s_{t'−1}</script>与编码器在时间步t的隐藏状态<script type="math/tex">h_t</script>为输⼊，并通过函数a计算<script type="math/tex">e_{t't}</script>：</p><script type="math/tex; mode=display">e_{t't} = a(s_{t'-1}, h_t)</script><p>其中a是一个自定义函数，有多种选择。如果两个输⼊向量⻓度相同，⼀个简单的选择是计算它们的内积$a(s,h) = s^⊤h$</p><ul><li>我们对注意力机制可以有一个直观的理解：<strong>在生成一个输出词时，会考虑每一个输入词和当前输出词的对应关系，对齐越好的词，会有越大的权重</strong></li><li>还可以结合双向RNN和注意力机制，每个隐状态包含了$\overleftarrow{h_t}$和$\overrightarrow{h_t}$</li></ul><h4 id="8-4-2-矢量化计算"><a href="#8-4-2-矢量化计算" class="headerlink" title="8.4.2 矢量化计算"></a>8.4.2 矢量化计算</h4><ul><li><p>我们还可以对注意⼒机制采⽤更⾼效的⽮量化计算。⼴义上，注意⼒机制的输⼊包括<strong>查询项</strong>以及<strong>⼀⼀对应的键项和值项</strong>，其中值项是需要加权平均的⼀组项。在加权平均中，<strong>值项的权重来⾃查询项以及与该值项对应的键项的计算</strong></p></li><li><p>在上面的例⼦中，查询项为解码器的隐藏状态，键项和值项均为编码器的隐藏状态。假设编码器和解码器的隐藏单元个数均为h，且函数<script type="math/tex">a(s, h) = s^ ⊤h</script>。若我们希望根据解码器单个隐藏状态<script type="math/tex">s_{t'−1} \in \mathbb{R}^h</script>和编码器所有隐藏状态<script type="math/tex">h_t \in \mathbb{R}^h , t = 1, . . . , T</script>来计算背景向量<script type="math/tex">c_{t'} \in \mathbb{R}^h</script>。我们可以将查询项矩阵<script type="math/tex">Q \in R^{1\times h}</script>设为<script type="math/tex">s^⊤_{t'−1}</script>，并令键项矩阵<script type="math/tex">K \in \mathbb{R}^{T\times h}</script>和值项矩阵<script type="math/tex">V \in \mathbb{R}^{T\times h}</script>相同且第t⾏均为<script type="math/tex">h^⊤_t</script> 。此时，我们只需要通过⽮量化计算：</p></li></ul><script type="math/tex; mode=display">softmax(QK^T)V</script><p>即可算出转置后的背景向量<script type="math/tex">c^⊤_{t'}</script>。当查询项矩阵Q的⾏数为n时，上式将得到n行的输出矩阵。输出矩阵与查询项矩阵在相同行上⼀⼀对应。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CNN基本概念</title>
    <link href="/2021/11/26/CNN/"/>
    <url>/2021/11/26/CNN/</url>
    
    <content type="html"><![CDATA[<h1 id="1-卷积层"><a href="#1-卷积层" class="headerlink" title="1 卷积层"></a>1 卷积层</h1><h3 id="1-1-互相关运算"><a href="#1-1-互相关运算" class="headerlink" title="1.1 互相关运算"></a>1.1 互相关运算</h3><ul><li><strong>在⼆维卷积层中，⼀个⼆维输⼊数组和⼀个⼆维核（kernel）数组通过互相 关运算输出⼀个⼆维数组</strong>，如下图：</li></ul><p><img src="https://i.loli.net/2021/11/24/8amf1EYbuU7JPKd.png" alt="image-20211124131936578"></p><p>卷积窗口从输⼊数组的最左上⽅开始，按从左往右、从上往下的顺序，依 次在输⼊数组上滑动。当卷积窗口滑动到某⼀位置时，窗口中的输⼊⼦数组与核数组按元素相乘 并求和，得到输出数组中相应位置的元素</p><ul><li><strong>⼆维卷积层将输⼊和卷积核做互相关运算，并加上⼀个标量偏差来得到输出</strong></li><li><strong>使用互相关运算做边缘检测：</strong></li></ul><p>比如我们把kernel设为[1, -1]，要识别的图像为单通道，只有黑白：<img src="https://i.loli.net/2021/11/24/Uro3neFEKigbCd2.png" alt="image-20211124132335469"></p><p>则进行互相关运算之后可以变为：<img src="https://i.loli.net/2021/11/24/kuH17Ef3p8Rbjdi.png" alt="image-20211124132405678"></p><p>由此我们可以看出边缘是在第2和第6列</p><ul><li><strong>卷积运算：</strong>其实就是把核数组左右翻转并 上下翻转，再与输⼊数组做互相关运算。但因为我们的参数都是学习出来的，而不是一开始设定好的，<strong>所以卷积层⽆论使⽤互相关运算或卷积运算都不影响模型预测时的输出</strong>，而我们一般使用的也是互相关运算</li></ul><h3 id="1-2-特征图和感受野"><a href="#1-2-特征图和感受野" class="headerlink" title="1.2 特征图和感受野"></a>1.2 特征图和感受野</h3><ul><li><strong>⼆维卷积层输出的⼆维数组可以看作输⼊在空间维度（宽和⾼）上某⼀级的表征，也叫特征图（feature map）</strong></li><li><strong>影响元素x的前向计算的所有可能输⼊区域叫做x的感受野（receptive field）</strong>，用上图距离，阴影中19的感受野就是输入的四个阴影，如果输入的元素又是另一个卷积运算的输出，则我们还可以将19的感受野扩大</li><li>可⻅，我们可以通过更深的卷积神经⽹络使特征 图中单个元素的感受野变得更加⼴阔，从而捕捉输⼊上更⼤尺⼨的特征</li></ul><h3 id="1-3-填充和步幅"><a href="#1-3-填充和步幅" class="headerlink" title="1.3 填充和步幅"></a>1.3 填充和步幅</h3><ul><li><strong>填充（padding）是指在输⼊⾼和宽的两侧填充元素（通常是0元素）</strong>，如下图就是对3$\times$3数组进行填充，填充为1：</li></ul><p><img src="https://i.loli.net/2021/11/24/YE4p8vg31IaWbuK.png" alt="image-20211124133849360"></p><ul><li><p><strong>我们将每次滑动的⾏数和列数称为步幅（stride）</strong></p></li><li><p><strong>一般来说输出的高宽为：</strong></p><script type="math/tex; mode=display">[(n_h - k_h + p_h + s_h) / s_h] \times [(n_w - k_w + p_w + s_w) / s_w]</script><p>其中：$n为输入，k为核，p为填充，s为步幅$</p></li><li><p>步幅为1时，很多情况下，我们会设置$p_h = k_h−1$和$p_w = k_w −1$来使输⼊和输出具有相同的⾼和宽</p></li></ul><h3 id="1-4-多输入通道和多输出通道"><a href="#1-4-多输入通道和多输出通道" class="headerlink" title="1.4 多输入通道和多输出通道"></a>1.4 多输入通道和多输出通道</h3><ul><li>当输入通道 $c_i &gt; 1$ 时，我们为每个输入通道都分配一个核数组，则得到一个形状为$c_i \times k_h \times k_w$的卷积核，最后再将每个通道上的卷积结果相加，就得到输出，如下图：</li></ul><p><img src="https://i.loli.net/2021/11/24/iNGt96JXUlSAEKZ.png" alt="image-20211124140843742"></p><ul><li>可是按上面的方法，无论输入通道是多少，输出通道总为1，我们设输入、输出通道分别为$c_i, c_o$，如果我们想要多通道的输出，则可以给每个输出通道都创建一个形状为$c_i \times k_h \times k_w$的核，则可以得到形状为$c_o \times c_i \times k_h \times k_w$的卷积核</li></ul><h3 id="1-5-1-times-1卷积层"><a href="#1-5-1-times-1卷积层" class="headerlink" title="1.5 1$\times$1卷积层"></a>1.5 1$\times$1卷积层</h3><ul><li>卷积窗口形状为1 × 1的多通道卷积层。我们通常称之为1 × 1卷 积层，并将其中的卷积运算称为1 × 1卷积</li><li>因为使⽤了最小窗口，1 × 1卷积失去了卷积层可以 识别⾼和宽维度上相邻元素构成的模式的功能。<strong>实际上，1 × 1卷积的主要计算发⽣在通道维上， 1 × 1卷积层通常⽤来调整⽹络层之间的通道数，并控制模型复杂度</strong></li><li><strong>假设我们将通道维当作特征维，将⾼和宽维度上的元素当成数据样本，那 么1 × 1卷积层的作⽤与全连接层等价</strong></li></ul><h3 id="1-6-卷积层相对于全连接层的优点"><a href="#1-6-卷积层相对于全连接层的优点" class="headerlink" title="1.6 卷积层相对于全连接层的优点"></a>1.6 卷积层相对于全连接层的优点</h3><ul><li><strong>卷积层使图像的像素在⾼和宽两个⽅向上的相关性均可能被有效识别</strong>，用全连接层举例，全连接层就相当于一个很大的卷积核，但是过大的卷积核带来的问题是我们可能无法提取到有效特征，并且像素在高宽方向上的相关性可能提取不到，如果选择合适的卷积核大小才更可能提取到</li><li>卷积层通过滑动窗口将同⼀卷积核与不同位置的输⼊重复计算，同一输入通道使用同一卷积核，<strong>实现参数共享</strong>，从而<strong>避免参数过多</strong>。同时参数共享也具有物理意义，他使卷积层<strong>具有平移等特性</strong>，比如图像中有一只猫，那么无论他在图像的任何位置，我们都能提取到他的主要特征，将他识别为猫</li><li>对于全连接层，<strong>任意一对输入和输出之间都会产生交互</strong>，形成稠密的连接结构</li></ul><p><img src="https://i.loli.net/2021/11/25/BuGFLnhli2NJPCv.png" alt="image-20211125234024022"></p><p>而在卷积神经网络中，卷积核尺度远小于输入的维度，<strong>这样每个输出神经元仅与前一层部分神经元产生交互</strong></p><p><img src="https://i.loli.net/2021/11/26/HBjoOyvEcqxSna6.png" alt="image-20211125234143051"></p><p>我们将这种特性称为<strong>稀疏交互</strong>，这样我们可以将<strong>优化过程的时间复杂度减少好几个数量级，并且缓解过拟合</strong></p><p>稀疏交互的物理意义是<strong>许多现实中的数据都具有局部的特征结构，我们可以先学习局部的特征，然后再将局部的特征组合起来形成更复杂和抽象的特征</strong></p><h1 id="2-池化层"><a href="#2-池化层" class="headerlink" title="2 池化层"></a>2 池化层</h1><ul><li><strong>池化层的提出是为了缓解卷积层对位置的过度敏感性</strong>。不同于卷积层⾥计算输⼊和核的互相关性，池化层直接计算池化窗口内元素的最⼤值或者平均值。该运算也分别叫做<strong>最⼤池化</strong>或<strong>平均池化</strong></li><li><strong>池化层没有参数</strong></li><li>Pooling 层说到底还是一个特征选择，信息过滤的过程。也就是说我们损失了一部分信息，这是一个和计算性能的一个妥协，随着运算速度的不断提高，这个妥协会越来越小，下面介绍几种常用的池化层</li></ul><h3 id="2-1-平均池化层（mean-pooling）"><a href="#2-1-平均池化层（mean-pooling）" class="headerlink" title="2.1 平均池化层（mean-pooling）"></a>2.1 平均池化层（mean-pooling）</h3><ul><li>即对邻域内特征点只求平均</li><li>优缺点：<strong>抑制邻域大小受限造成的估计值方差增大</strong>，能很好的保留背景，但容易使得图片变模糊</li></ul><h3 id="2-2-最大池化层（max-pooling）"><a href="#2-2-最大池化层（max-pooling）" class="headerlink" title="2.2 最大池化层（max-pooling）"></a>2.2 最大池化层（max-pooling）</h3><ul><li>即对邻域内特征点取最大</li><li>优缺点：<strong>抑制积层参数误差造成估计均值的偏移</strong>，能很好的保留纹理特征，一般现在都用max-pooling而很少用mean-pooling</li></ul><h3 id="2-3-全局平均池化（global-average-pooling）"><a href="#2-3-全局平均池化（global-average-pooling）" class="headerlink" title="2.3 全局平均池化（global average pooling）"></a>2.3 全局平均池化（global average pooling）</h3><ul><li>对每个通道中所有元素求平均并直接⽤于分类</li><li>优点：大幅度减少网络参数，理所当然的减少了过拟合现象</li></ul><h3 id="2-4-池化层的作用"><a href="#2-4-池化层的作用" class="headerlink" title="2.4 池化层的作用"></a>2.4 池化层的作用</h3><ol><li><strong>对特征进行压缩，保留主要特征的同时减少参数和计算量，减少模型复杂度，防止过拟合。</strong>用池化层做互相关运算，本身就能减少特征的个数。并且对于全局平均优化，如果我们要进行图像分类，我们需要使用参数很多的全连接层，最后再导入Softmax，而如果我们使用全局平均优化，则可以规避全连接庞大的参数量，减少过拟合</li><li><strong>实现不变性</strong>，包括平移不变性、旋转不变性和尺度不变性。</li></ol><h3 id="2-5-池化层的多通道"><a href="#2-5-池化层的多通道" class="headerlink" title="2.5 池化层的多通道"></a>2.5 池化层的多通道</h3><ul><li>和卷积层有区别， 在处理多通道输⼊数据时，<strong>池化层对每个输⼊通道分别池化，而不是像卷积层那样将各通道的输 ⼊按通道相加。这意味着池化层的输出通道数与输⼊通道数相等</strong></li></ul><h1 id="3-LeNet"><a href="#3-LeNet" class="headerlink" title="3 LeNet"></a>3 LeNet</h1><ul><li>分为卷积层块和全连接层块两个部分</li></ul><h3 id="3-1-卷积层块"><a href="#3-1-卷积层块" class="headerlink" title="3.1 卷积层块"></a>3.1 卷积层块</h3><ul><li>卷积层块⾥的基本单位是卷积层后接最⼤池化层，卷积层⽤来识别图像⾥的空间模式，如线条和 物体局部，之后的最⼤池化层则⽤来降低卷积层对位置的敏感性</li><li>在卷积层块中，每个卷积层都使⽤5 × 5的窗口，并在输出上使⽤sigmoid激活函数。第⼀个卷积层输出通道数为6，第⼆个卷积层输出通道数则增加到16。这是因为第⼆个卷积层⽐第⼀个卷积层的输⼊的⾼和宽要小，所以增加输出通道使两个卷积层的参数尺⼨类似</li><li>卷积层块的两个最⼤池化层的窗口形状均为2 × 2，且步幅为2</li></ul><h3 id="3-2-全连接层块"><a href="#3-2-全连接层块" class="headerlink" title="3.2 全连接层块"></a>3.2 全连接层块</h3><ul><li>当卷积层块的输出传⼊全连接层块时，全连接 层块会将小批量中每个样本变平（flatten）。也就是说，全连接层的输⼊形状将变成⼆维，其中第⼀维是小批量中的样本，第⼆维是每个样本变平后的向量表⽰，且向量⻓度为通道、⾼和宽的乘积</li><li>全连接层块含3个全连接层。它们的输出个数分别是120、84和10，其中10为输出的类别个数</li></ul><p><img src="https://i.loli.net/2021/11/28/NH5zDmge7RiwaGA.png" alt="20150903212346407"></p><h1 id="4-AlexNet（相对于LeNet较深）"><a href="#4-AlexNet（相对于LeNet较深）" class="headerlink" title="4 AlexNet（相对于LeNet较深）"></a>4 AlexNet（相对于LeNet较深）</h1><ul><li>相对于较小的LeNet，AlexNet包含8层变换，其中有5层卷积和2层全连接隐藏层，以及1个全连接输出层</li><li>AlexNet第⼀层中的卷积窗口形状是11 × 11，步幅为4。因为ImageNet中绝⼤多数图像的⾼和宽均 ⽐MNIST图像的⾼和宽⼤10倍以上，ImageNet图像的物体占⽤更多的像素，所以需要更⼤的卷积窗口来捕获物体。第⼆层中的卷积窗口形状减小到5 × 5，之后全采⽤3 × 3</li><li>第⼀、第⼆和第五个卷积层之后都使⽤了窗口形状为3 × 3、步幅为2的最⼤池化层</li><li>AlexNet使⽤的卷积通道数也⼤于LeNet中的卷积通道数数⼗倍，5层的输出通道数分别为96，256，384，384，256</li><li>紧接着最后⼀个卷积层的是两个输出个数为4096的全连接层</li><li>AlexNet将sigmoid激活函数改成了更加简单的ReLU激活函数</li><li>AlexNet使用了Dropout和图像增广</li><li>AlexNet相比于LeNet有更小的学习率</li><li><strong>AlexNet的一个很大的意义就是在图像识别上AI超越人工，并且首次使用了GPU加速</strong></li></ul><p><img src="https://pic2.zhimg.com/v2-3f5a7ab9bcb15004d5a08fdf71e6a775_b.jpg" alt="v2-3f5a7ab9bcb15004d5a08fdf71e6a775_b"></p><h1 id="5-VGG（使用重复元素）"><a href="#5-VGG（使用重复元素）" class="headerlink" title="5 VGG（使用重复元素）"></a>5 VGG（使用重复元素）</h1><h3 id="5-1-VGG块"><a href="#5-1-VGG块" class="headerlink" title="5.1 VGG块"></a>5.1 VGG块</h3><ul><li>连续使⽤<strong>数个相同的填充为1、窗口形状为3 × 3的卷积层后接上⼀个步幅为2、窗口形状为2 × 2的最⼤池化层</strong>。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。可以指定卷积层的数量num_convs和输出通道数num_channels</li></ul><h3 id="5-2-VGG网络"><a href="#5-2-VGG网络" class="headerlink" title="5.2 VGG网络"></a>5.2 VGG网络</h3><ul><li>我们构造⼀个VGG⽹络。它有5个卷积块，前2块使⽤单卷积层，而后3块使⽤双卷积层。第⼀块的输出通道是64，之后每次对输出通道数翻倍，直到变为512。因为这个⽹络使⽤了8个卷积层和3个全连接层，所以经常被称为VGG-11</li><li>之后的3个全连接层神经元个数分别为：4096，4096，10（最后一层为类别个数）</li><li>使用VGG后，每次输⼊的⾼和宽将减半，直到最终⾼和宽变成7后传⼊全连接层。与此同时，输出通道数每次翻倍，直到变成512。VGG这种⾼和宽减半以及通道翻倍的设计使多数卷积层都有相同的模型参数尺⼨和计算复杂度</li></ul><ul><li><strong>VGG的一个很大的意义就是VGG用数个小卷积核代替大卷积核，使参数量减少</strong></li></ul><p><img src="https://i.loli.net/2021/11/28/tTvmMekgd81PJX6.png" alt="20180205192403250"></p><h1 id="6-NiN（网络中的网络）"><a href="#6-NiN（网络中的网络）" class="headerlink" title="6 NiN（网络中的网络）"></a>6 NiN（网络中的网络）</h1><ul><li>的LeNet、AlexNet和VGG在设计上的共同之处是：先以由卷积层构成的模块充分抽取空间特征，再以由全连接层构成的模块来输出分类结果。其中，AlexNet和VGG对LeNet的改进主要在于如何对这两个模块加宽（增加通道数）和加深</li><li>但是NiN有所不同，由于1$\times$1卷积层可以替代全连接层，所以NiN中就进行了替换：</li><li><strong>NiN之所以被称为网络中的网络是因为：NiN串联多个由卷积层和“准全连接层”（1X1的网络）的小网络来构成一个深层网络</strong></li></ul><p><img src="https://i.loli.net/2021/11/25/NjfabGRcVe8ysZk.png" alt="image-20211125152432130"></p><h3 id="6-1-NiN块"><a href="#6-1-NiN块" class="headerlink" title="6.1 NiN块"></a>6.1 NiN块</h3><ul><li>NiN块是NiN中的基础块。它由⼀个卷积层加两个充当全连接层的1 × 1卷积层串联而成。其中<strong>第⼀个卷积层的超参数可以⾃⾏设置，而第⼆和第三个卷积层的超参数⼀般是固定的</strong></li><li>三个卷积层的通道数是相同的</li></ul><h3 id="6-2-NiN模型"><a href="#6-2-NiN模型" class="headerlink" title="6.2 NiN模型"></a>6.2 NiN模型</h3><ul><li>NiN使⽤卷积窗口形状分别为11 × 11、5 × 5和3 × 3的卷积层，相应的输出通道数也与AlexNet中的⼀致。每个NiN块后接⼀ 个步幅为2、窗口形状为3 × 3的最⼤池化层</li><li>除使⽤NiN块以外，NiN还有⼀个设计与AlexNet显著不同：NiN去掉了AlexNet最后的3个全连接层，取而代之地，NiN使⽤了输出通道数等于标签类别数的NiN块，然后使⽤<strong>全局平均池化层</strong>对每个通道中所有元素求平均并直接⽤于分类。<strong>这个设计的好处是可以显著减小模型参数尺⼨，从而缓解过拟合，然而，该设计有时会造成获得有效模型的训练时间的增加</strong></li><li>NiN的学习率一般比AlexNet和VGG大</li></ul><p><img src="https://i.loli.net/2021/11/28/2eiOxQsw4XoBFN9.png" alt="image-20211128200750143"></p><h1 id="7-GoogLeNet（含并行连接的网络）"><a href="#7-GoogLeNet（含并行连接的网络）" class="headerlink" title="7 GoogLeNet（含并行连接的网络）"></a>7 GoogLeNet（含并行连接的网络）</h1><h3 id="7-1-Inception块"><a href="#7-1-Inception块" class="headerlink" title="7.1 Inception块"></a>7.1 Inception块</h3><p><img src="https://i.loli.net/2021/11/25/Q4sfSlhjntDaXFM.png" alt="image-20211125155525157"></p><ul><li><p>Inception块⾥有4条并⾏的线路。前3条线路使⽤窗口⼤小分别是1 × 1、3 × 3和5 × 5的卷积层来<strong>抽取不同空间尺⼨下的信息</strong></p></li><li><p>其中中间2个线路会对输⼊先做1 × 1卷积来减少输⼊通道数，<strong>以降低模型复杂度</strong>。第四条线路则使⽤3 × 3最⼤池化层，后接1 × 1卷积层来改变通道数</p></li><li><p>4条线路都使⽤了合适的填充来使<strong>输⼊与输出的⾼和宽⼀致</strong>。最后我们将每条线路的输出<strong>在通道维上连结</strong>，并输⼊接下来的层中去</p></li></ul><h3 id="7-2-GoogLeNet模型"><a href="#7-2-GoogLeNet模型" class="headerlink" title="7.2 GoogLeNet模型"></a>7.2 GoogLeNet模型</h3><ul><li>在主体卷积部分中使⽤5个模块（block），<strong>每个模块之间使⽤步幅为2的3× 3最⼤池化层来减小输出⾼宽</strong></li><li>第⼀模块使⽤⼀个64通道的7 × 7卷积层，步幅为2</li></ul><ul><li>第⼆模块使⽤2个卷积层：⾸先是64通道的1 × 1卷积层，然后是将通道增⼤3倍（变为192）的3 × 3卷积层</li></ul><ul><li><p>第三模块串联2个完整的Inception块。第⼀个Inception块的输出通道数为64+128+32+32 = 256（4个加数对应4条线路的通道数），其中第⼆、第三条线路由于有两个卷积层，所以两条线路的第一个<script type="math/tex">1 \times 1</script>卷积层先将输出通道减少为96和16，再接上第⼆层卷积层。</p><p>第⼆个Inception块 输出通道数增⾄128 + 192 + 96 + 64 = 480。其中第⼆、第三条线路<script type="math/tex">1 \times 1</script>卷积层的输出通道分别为128和32</p></li></ul><ul><li><p>第四模块更加复杂。它串联了5个Inception块，其输出通道数分别是192 + (96,208) + (16,48) + 64 = 512、 160+(112,224)+(24,64)+64 = 512、128+(128,256)+(24,64)+64 = 512、112+(144,288)+(32,64)+64 = 528和 256+(160,320)+(32,128)+128 = 832</p><p>其中括号里的第一个数字为二三条通道的第一个卷积核输出通道数</p></li></ul><ul><li>第五模块有输出通道数为256 + (160,320) + (32,128) + 128 = 832和384 + (192,384) + (48,128) + 128 = 1024的两个Inception块，<strong>然后再接上一个全局平均池化层</strong></li></ul><ul><li><strong>五个模块相连之后最后再接上一个全连接层，神经元个数为类别个数</strong></li></ul><p><img src="https://i.loli.net/2021/11/28/rdpGSFRzuKZeTs2.jpg" alt="142051802f8de8513fe61601277f03c8"></p><h1 id="8-批量归一化"><a href="#8-批量归一化" class="headerlink" title="8 批量归一化"></a>8 批量归一化</h1><ul><li>我们一般在前向传播开始之前会对数据进行归一化，<strong>使不同特征之间具有可比性，并且更快收敛</strong></li><li>通常来说，数据标准化预处理对于浅层模型就⾜够有效了，<strong>但对深层神经网络来说，即使输⼊数据已做标准化，训练中模型参数的更新依然很容易造成靠近输出层输出的剧烈变化。</strong>这种计算数值的不稳定性通常令我们难以训练出有效的深度模型</li><li>而批量归一化则是对每一层的输出都做一次归一化，<strong>使均值永远为0，方差永远为1</strong></li></ul><h3 id="8-1-批量归一化层"><a href="#8-1-批量归一化层" class="headerlink" title="8.1 批量归一化层"></a>8.1 批量归一化层</h3><ul><li><strong>通常，我们将批量归⼀化层置于全连接层中的仿射变换和激活函数之间</strong></li><li>首先要对小批量求均值和方差：</li></ul><script type="math/tex; mode=display">\begin{array}{c}\boldsymbol{\mu}_{\mathcal{B}} \leftarrow \frac{1}{m} \sum_{i=1}^{m} \boldsymbol{x}^{(i)} \\\boldsymbol{\sigma}_{\mathcal{B}}^{2} \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}\right)^{2}\end{array}</script><p>得到的均值和方差是两个向量，维度为特征个数</p><ul><li>然后：</li></ul><script type="math/tex; mode=display">\hat{\boldsymbol{x}}^{(i)} \leftarrow \frac{\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}}{\sqrt{\boldsymbol{\sigma}_{\mathcal{B}}^{2}+\epsilon}}</script><ul><li>$\epsilon$ 为一个很小的数，一般取$10^{-8}$ ，是为了保证分母大于0</li><li><strong>但是我们不确定是否一定是所有层都进行批量归一化才是最好的情况，所以我们要给予一个能变回归一化前的值的可能性，所以引入拉伸参数（scale）$\gamma$ 和  偏移参数（shift）$\beta$</strong></li></ul><script type="math/tex; mode=display">\boldsymbol{y}^{(i)} \leftarrow \gamma \odot \hat{\boldsymbol{x}}^{(i)}+\boldsymbol{\beta}</script><p>将$\gamma$ 和 $\beta$ 作为两个可变化参数，然后通过学习来决定拉伸多少和偏移多少</p><h3 id="8-2-对卷积层做批量归一化"><a href="#8-2-对卷积层做批量归一化" class="headerlink" title="8.2 对卷积层做批量归一化"></a>8.2 对卷积层做批量归一化</h3><ul><li>批量归⼀化发⽣在卷积计算之后、应⽤激活函数之前</li><li><p>如果卷积计算输出多个通道，我们需要<strong>对这些通道的输出分别做批量归⼀化，且每个通道都拥有独立的拉伸和偏移参数</strong></p></li><li><p>设小批量中有m个样本。在单个通道上，假设卷积计算输出的⾼和宽分别为p和q。我们需要对该通道中m × p × q个元素同时做批量归⼀化</p></li></ul><h3 id="8-3-预测时的批量归一化"><a href="#8-3-预测时的批量归一化" class="headerlink" title="8.3 预测时的批量归一化"></a>8.3 预测时的批量归一化</h3><ul><li><strong>批量归一化在训练模式和预测模式的计算结果是不⼀样的</strong>。确定均值和方差时，单个样本的输出不应取决于批量归⼀化所需要的随机小批量中的均值和⽅差。⼀种常⽤的⽅法是<strong>通过移动平均（指数加权平均）估算整个训练数据集的样本均值和方差</strong>，并在预测时使⽤它们得到确定的输出</li></ul><h1 id="9-残差网络（ResNet）"><a href="#9-残差网络（ResNet）" class="headerlink" title="9 残差网络（ResNet）"></a>9 残差网络（ResNet）</h1><h3 id="9-1-残差块"><a href="#9-1-残差块" class="headerlink" title="9.1 残差块"></a>9.1 残差块</h3><p><img src="https://i.loli.net/2021/11/25/zADLUxHm7wS8Z9Q.png" alt="image-20211125221657826"></p><ul><li>左图是一般形式的映射，右图为残差映射，是将输入x加权-&gt;激活-&gt;再加权后，再和原输入x相加，再送入激活函数</li><li>这样的结构中，输⼊可通过跨层的数据线路更快地向前传播</li><li>残差块⾥⾸先有2个有相同输出通道数的3 × 3卷积层。每个卷积层后接⼀个批量归⼀化层和ReLU激活函数。然后我们<strong>将输⼊跳过这2个卷积运算后直接加在最后的ReLU激活函数前</strong></li><li>这样的设计要求2个卷积层的输出与输⼊形状⼀样，从而可以相加。如果想改变通道数，就需要引⼊⼀个额外的1 × 1卷积层来将输⼊变换成需要的形状后再做相加运算</li></ul><p><img src="https://pic2.zhimg.com/80/v2-bd76d0f10f84d74f90505eababd3d4a1_720w.jpg" alt=""></p><h3 id="9-2-ResNet模型"><a href="#9-2-ResNet模型" class="headerlink" title="9.2 ResNet模型"></a>9.2 ResNet模型</h3><ul><li>ResNet的前两层跟之前介绍的GoogLeNet中的⼀样：在输出通道数为64、步幅为2的7 × 7卷积层后接步幅为2的3 × 3的最⼤池化层。不同之处在于<strong>ResNet每个卷积层（对应上图每一次加权运算）后增加的批量归⼀化层</strong></li></ul><ul><li><strong>后接4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块</strong></li><li>第⼀个模块的通道数同输⼊通道数⼀致。由于之前已经使⽤了步幅为2的最⼤池化层，所以⽆须减小⾼和宽。<strong>之后的每个模块在第⼀个残差块⾥将上⼀个模块的通道数翻倍，并将高和宽减半</strong></li></ul><ul><li>接着我们为ResNet加⼊所有残差块。这⾥每个模块的残差块个数可以自行定义</li></ul><ul><li>最后，与GoogLeNet⼀样，加⼊全局平均池化层后接上全连接层输出</li></ul><p><img src="https://i.loli.net/2021/11/25/9aypGjvX1ESYtrM.png" alt="image-20211125223902681"></p><p>其中10为类别个数</p><p><img src="https://pic3.zhimg.com/80/v2-862e1c2dcb24f10d264544190ad38142_720w.jpg" alt=""></p><h3 id="9-3-ResNet的作用"><a href="#9-3-ResNet的作用" class="headerlink" title="9.3 ResNet的作用"></a>9.3 ResNet的作用</h3><ul><li>在深度神经网络中，如果我们进行反向传播，那么由链式求导法则可知，我们会<strong>涉及到非常多参数和导数的连乘</strong>，这时误差很容易产生消失或膨胀，通过实验也可以发现，层数更深的神经网络结果反而没有浅层的好</li></ul><p><img src="https://i.loli.net/2021/11/26/YecToJs5xNf6H24.png" alt="image-20211125235804507"></p><p>这种结果很大程度归结于深度神经网络的<strong>梯度消失问题</strong></p><ul><li>而ResNet的提出就是为了解决梯度消失的问题，<strong>既然离输入近的神经网络层较难训练，那么我们可以将他短接到更接近输出的层</strong>，并且这种方法并不会对结果产生影响，假设输入为X，我们在一般网络中想要拟合f(X)，放到残差网络中就只需要拟合f(X) - X 即可</li><li><strong>残差网络的设计思想不仅仅局限于卷积网络，实际上很多其他的网络也用到了残差，也取得了很不错的效果，都是为了解决深度神经网络的梯度消失问题</strong></li></ul><h1 id="10-稠密连接网络（DenseNet）"><a href="#10-稠密连接网络（DenseNet）" class="headerlink" title="10 稠密连接网络（DenseNet）"></a>10 稠密连接网络（DenseNet）</h1><p><img src="https://i.loli.net/2021/11/25/NTajCiqAydPvoVt.png" alt="image-20211125224307704"></p><ul><li>DenseNet里模块B的输出不是像ResNet那样和模块A的输出相加，而是<strong>在通道维上连结</strong></li><li>DenseNet的主要构建模块是<strong>稠密块（dense block）</strong>和<strong>过渡层（transition layer）</strong>。前者定义了输⼊和输出是如何连结的，后者则⽤来控制通道数，使之不过⼤</li></ul><h3 id="10-1-稠密块"><a href="#10-1-稠密块" class="headerlink" title="10.1 稠密块"></a>10.1 稠密块</h3><ul><li>我们将批量归⼀化、激活和卷积组合到一起形成一种块：</li></ul><p><img src="https://i.loli.net/2021/11/25/hfHF7BLySM1swZG.png" alt="image-20211125225431518"></p><ul><li><strong>稠密块由多个conv_block组成，每块使⽤相同的输出通道数。但在前向计算时，我们将每块的输⼊和输出在通道维上连结</strong></li></ul><h3 id="10-2-过渡层"><a href="#10-2-过渡层" class="headerlink" title="10.2 过渡层"></a>10.2 过渡层</h3><ul><li>由于每个稠密块都会带来通道数的增加，使⽤过多则会带来过于复杂的模型。过渡层⽤来控制模型复杂度。它<strong>通过1 × 1卷积层来减小通道数，并使⽤步幅为2的平均池化层减半高和宽</strong>，并且也要进行激活和BN运算</li></ul><h3 id="10-3-DenseNet模型"><a href="#10-3-DenseNet模型" class="headerlink" title="10.3 DenseNet模型"></a>10.3 DenseNet模型</h3><ul><li>DenseNet⾸先使⽤同ResNet⼀样的单卷积层和最⼤池化层</li></ul><p><img src="https://i.loli.net/2021/11/25/DqcGv6FtMioNez1.png" alt="image-20211125230039527"></p><ul><li>接着使用4个稠密块，同ResNet⼀样，我们可以设置每个稠密块使⽤多少个卷积层</li></ul><ul><li><p>在稠密块之间我们使用过渡层来减半高宽，并减半通道数</p><p>注意最后一层是不使用过渡层进行减半的</p></li><li><p>最后再和ResNet一样，接上全局平均池化层和全连接层来输出</p></li></ul><p><img src="https://pic2.zhimg.com/80/v2-c81da515c8fa9796601fde82e4d36f61_720w.jpg" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不同batch size梯度下降的影响</title>
    <link href="/2021/11/23/%E4%B8%8D%E5%90%8Cbatch%20size%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2021/11/23/%E4%B8%8D%E5%90%8Cbatch%20size%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<ul><li>梯度下降法作为机器学习中较常使用的优化算法，针对不同的batch size，有着3种不同的形式：<strong>批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）、小批量梯度下降（Mini-Batch Gradient Descent）</strong></li></ul><h1 id="1-批量梯度下降（BGD）"><a href="#1-批量梯度下降（BGD）" class="headerlink" title="1 批量梯度下降（BGD）"></a>1 批量梯度下降（BGD）</h1><p>使用整个训练集的优化算法被称为<strong>批量</strong>(batch)或<strong>确定性</strong>(deterministic)梯度算法，因为它们会<strong>在一个大批量中同时处理所有样本</strong></p><p><strong>批量梯度下降法</strong>是最原始的形式，它是指在<strong>每一次迭代时</strong>使用<strong>所有样本</strong>来进行梯度的更新</p><ul><li><strong>优点：</strong></li></ul><ol><li>在训练过程中，使用固定的学习率</li><li>由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向</li><li>一次迭代是对所有样本进行计算，此时利用向量化进行操作，实现了并行</li></ol><ul><li><strong>缺点：</strong></li></ul><ol><li><strong>尽管在计算过程中，使用了向量化计算，但是遍历全部样本仍需要大量时间，尤其是当数据集很大时（几百万甚至上亿），就有点力不从心了</strong></li><li>不能投入新数据实时更新模型</li><li>对非凸函数可能只能收敛到局部最小点，而非全局最小点</li></ol><p><img src="https://i.loli.net/2021/11/11/mCkfeDIPyh3a5iY.png" alt="BGD"></p><h1 id="2-随机梯度下降（SGD）"><a href="#2-随机梯度下降（SGD）" class="headerlink" title="2 随机梯度下降（SGD）"></a>2 随机梯度下降（SGD）</h1><p><strong>随机梯度下降法</strong>不同于批量梯度下降，随机梯度下降是在<strong>每次迭代时</strong>使用<strong>一个样本</strong>来对参数进行更新（mini-batch size =1）</p><ul><li><strong>优点：</strong></li></ul><ol><li>在学习过程中加入了噪声，提高了泛化误差</li><li><strong>噪声造成的扰动可能可以使其脱离局部最小点</strong></li><li>SGD一次只遍历一个样本就可以进行更新 ，所以收敛很快，并且可以新增样本</li></ol><ul><li><strong>缺点：</strong></li></ul><ol><li><strong>不收敛，在最小值附近波动</strong></li><li><strong>不能在一个样本中使用并行化计算，学习过程变得很慢</strong></li><li>单个样本并不能代表全体样本的趋势，所以学习过程可能变得特别的曲折，<strong>虽然包含一定的随机性，但是从期望上来看，它是等于正确的导数的</strong>，如下图</li></ol><p><img src="https://i.loli.net/2021/11/11/GLBkox67lvnmsOA.png" alt="image-20211111201918007" style="zoom: 67%;" /></p><ul><li><strong>对上面期望的证明，SGD的梯度是BGD梯度的无偏估计：</strong></li></ul><script type="math/tex; mode=display">E(\nabla f_i(x)) = \frac{1}{n}\sum_{i = 1}^n\nabla f_i(x) = \nabla f(x)</script><p><strong>这说明了SGD的总体优化方向仍然是对的</strong></p><h1 id="3-Mini-batch梯度下降"><a href="#3-Mini-batch梯度下降" class="headerlink" title="3 Mini-batch梯度下降"></a>3 Mini-batch梯度下降</h1><p>大多数用于深度学习的梯度下降算法介于以上两者之间，<strong>使用一个以上而又不是全部的训练样本</strong></p><ul><li><p>在一次取样本的时候我们需要在所有样本中<strong>随机</strong>取batch-size个样本</p></li><li><p><strong>优点：</strong></p></li></ul><ol><li>收敛速度比BGD快，因为只遍历部分样例就可执行更新</li><li>随机选择样例有利于避免重复多余的样例和对参数更新较少贡献的样例</li><li>每次使用一个batch可以大大减小收敛所需要的迭代次数，同时可以使收敛到的结果更加接近梯度下降的效果</li><li>因为有噪音（但是噪音比SGD小），所以<strong>可能脱离局部最小点</strong></li></ol><ul><li><strong>缺点：</strong></li></ul><ol><li>在迭代的过程中，因为噪音的存在，学习过程会出现波动。因此，它在最小值的区域徘徊，不会收敛</li><li>学习过程会有更多的振荡，为更接近最小值，需要增加<strong>学习率衰减项</strong>，以降低学习率，避免过度振荡</li></ol><ul><li><strong>小批量大小</strong>（mini-batch size）的选择：</li></ul><ol><li>更大的批量会计算更精确的梯度，但是回报却是小于线性的</li><li>极小的批量通常难以充分利用多核结构。当批量低于某个数值时，计算时间不会减少</li><li>批量处理中的所有样本可以并行处理，<strong>内存消耗和批量大小会成正比</strong>。对于很多硬件设备，这是批量大小的限制因素</li><li>在使用<strong>GPU</strong>时，通常使用<strong>2的幂数作为批量大小</strong>可以获得更少的运行时间。一般，2的幂数取值范围是<strong>32~256</strong>。16有时在尝试大模型时使用</li></ol><p>使用三种梯度下降的收敛过程：</p><p><img src="https://i.loli.net/2021/11/11/paxvbFh9fRiDKNg.png" alt="image-20211111204100788" style="zoom: 80%;" /></p><ul><li><p><strong>Mini-batch梯度下降和SGD一样，其梯度也是BGD梯度的无偏估计</strong></p></li><li><p><strong>从无偏估计可以看出，Mini-batch和SGD其实就是在用部分样本梯度来代替总体梯度</strong></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用损失函数和评估模型的指标</title>
    <link href="/2021/11/13/%E5%B8%B8%E7%94%A8%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8C%87%E6%A0%87/"/>
    <url>/2021/11/13/%E5%B8%B8%E7%94%A8%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-常用损失函数"><a href="#1-常用损失函数" class="headerlink" title="1 常用损失函数"></a>1 常用损失函数</h1><h3 id="1-1-0-1损失函数"><a href="#1-1-0-1损失函数" class="headerlink" title="1.1 0-1损失函数"></a>1.1 0-1损失函数</h3><script type="math/tex; mode=display">L(y, \hat{y}) = \begin{cases}1 & y\neq \hat{y}\\0 & y = \hat{y}\end{cases}</script><ul><li>0-1损失函数直接对应分类判断错误的个数，但是它是一个非凸函数，不太适用</li><li>感知机就是用的这种损失函数。但是相等这个条件太过严格，因此可以放宽条件，即满足$|y - \hat{y}| &lt; T$时认为相等，即：</li></ul><script type="math/tex; mode=display">L(y, \hat{y}) = \begin{cases}1 & |y - \hat{y}| \geq T\\0 & |y - \hat{y}| < T\end{cases}</script><h3 id="1-2-均方差损失函数（MSE）"><a href="#1-2-均方差损失函数（MSE）" class="headerlink" title="1.2 均方差损失函数（MSE）"></a>1.2 均方差损失函数（MSE）</h3><script type="math/tex; mode=display">J_{MSE} = \frac{1}{N} \sum_{i = 1}^N(y_i - \hat{y_i})^2</script><ul><li>也称L2 Loss</li></ul><h5 id="1-2-1-证明"><a href="#1-2-1-证明" class="headerlink" title="1.2.1 证明"></a>1.2.1 证明</h5><p>假设预测值和真实值的误差$\epsilon$服从标准正态分布，则给定一个$x_i$输出真实值$y_i$的概率为：</p><script type="math/tex; mode=display">p(\hat y_i = y_i|x_i) = p(\hat y_i = f(x_i) + \epsilon) | x_i) = p(\epsilon) = \frac{1}{\sqrt{2\pi}}exp(-\frac{(y_i - \hat{y_i})^2}{2})</script><p>其实就是极大似然估计，我们要寻找一组参数，使$p(y_i|x_i)$最大</p><p>进一步对所有样本，由于他们相互独立，所以所有样本都正好取到真实值$y$的概率为：</p><script type="math/tex; mode=display">L(x, y) = \prod_{i = 1}^N\frac{1}{\sqrt{2\pi}}exp(-\frac{(y_i - \hat{y_i})^2}{2})</script><p>现在我们就要使$L(x, y)$最大，为了方便计算，我们取对数：</p><script type="math/tex; mode=display">LL(x, y) = log(L(x, y)) = -\frac{N}{2}log2\pi - \frac{1}{2}\sum_{i = 1}^N(y_i - \hat{y_i})^2</script><p>把第一项无关项去掉，再取负：</p><script type="math/tex; mode=display">NLL(x, y) = \frac{1}{2}\sum_{i = 1}^N(y_i - \hat{y_i})^2</script><p>即得到均方差形式</p><h5 id="1-2-2-为什么可以用极大似然"><a href="#1-2-2-为什么可以用极大似然" class="headerlink" title="1.2.2 为什么可以用极大似然"></a>1.2.2 为什么可以用极大似然</h5><p><strong>在模型输出与真实值的误差服从高斯分布的假设下，最小化均方差损失函数与极大似然估计本质上是一致的，拟合数据最好的情况就是所有的$y_i = \hat{y_i}$，即每个样本的$p(y_i|x_i)$取最大，即$L(x, y)$取最大，由于对数运算不改变单调性，并且最后取了个负值，所以即$NLL(x, y)$取最小</strong></p><h3 id="1-3-平均绝对误差损失（MAE）"><a href="#1-3-平均绝对误差损失（MAE）" class="headerlink" title="1.3 平均绝对误差损失（MAE）"></a>1.3 平均绝对误差损失（MAE）</h3><script type="math/tex; mode=display">J_{MAE} = \frac{1}{N}\sum_{i = 1}^N|y_i - \hat{y_i}|</script><ul><li>也称L1 Loss</li></ul><h5 id="1-3-1-拉普拉斯分布"><a href="#1-3-1-拉普拉斯分布" class="headerlink" title="1.3.1 拉普拉斯分布"></a>1.3.1 拉普拉斯分布</h5><script type="math/tex; mode=display">f(x|\mu, b) = \frac{1}{2b}exp(-\frac{|x - \mu|}{b})</script><p>期望值：$\mu$             方差：$2b^2$</p><p><img src="https://i.loli.net/2021/11/08/yWY3hI4ioKpADRF.png" alt="Laplace_distribution_pdf" style="zoom: 25%;" /></p><h5 id="1-3-2-证明"><a href="#1-3-2-证明" class="headerlink" title="1.3.2 证明"></a>1.3.2 证明</h5><p>假设预测值和真实值的误差服从拉普拉斯分布（$\mu = 0, b = 1$）</p><script type="math/tex; mode=display">p(y_i | x_i) = \frac{1}{2}exp(-{|y_i - \hat{y_i}|})</script><p>剩余证明和上述MSE证明过程一样</p><h5 id="1-3-3-MSE和MAE的区别："><a href="#1-3-3-MSE和MAE的区别：" class="headerlink" title="1.3.3 MSE和MAE的区别："></a>1.3.3 MSE和MAE的区别：</h5><ul><li><strong>MSE 损失相比 MAE 通常可以更快地收敛</strong></li></ul><p>关于$\hat{y_i}$求导时，MSE为$-(y_i - \hat{y_i})$，MAE为$\pm1$，即 MSE 的梯度的 scale 会随误差大小变化，而 MAE 的梯度的 scale 则一直保持为 1，即便在绝对误差很小的时候 MAE 的梯度 scale 也同样为 1，这实际上是非常不利于模型的训练的（当然也可以通过调整学习率缓解这个问题，但总体来说还是MSE更快）。</p><ul><li><strong>MAE对于离群值更加健壮，即更加不易受到离群值影响</strong></li></ul><ol><li>由于MAE 损失与绝对误差之间是线性关系，MSE 损失与误差是平方关系，当误差非常大的时候，MSE 损失会远远大于 MAE 损失</li><li>MSE 假设了误差服从正态分布，MAE 假设了误差服从拉普拉斯分布。拉普拉斯分布本身对于离群值更加健壮</li></ol><h5 id="1-3-4-MSE和MAE的收敛"><a href="#1-3-4-MSE和MAE的收敛" class="headerlink" title="1.3.4 MSE和MAE的收敛"></a>1.3.4 MSE和MAE的收敛</h5><ul><li>MSE收敛于均值</li></ul><p>将$\hat{y_i}$设为变量$t$：</p><script type="math/tex; mode=display">J_{MSE} = \frac{1}{N}\sum_{i = 1}^N(t - y_i)^2</script><p>关于$t$求导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial t} = \frac{2}{N}\sum_{i = 1}^N(t - y_i) = 0</script><p>求得：</p><script type="math/tex; mode=display">t = \frac{1}{N}\sum_{i = 1}^Ny_i = E(y)</script><ul><li>MAE收敛于中值</li></ul><p>将$\hat{y_i}$设为变量$t$：</p><script type="math/tex; mode=display">J_{MAE} = \frac{1}{N}\sum_{i = 1}^N|t - y_i|</script><p>关于$t$求导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial t} = \frac{1}{N}\sum_{i = 1}^Nsgn(t - y_i) = 0</script><p>显然在该种情况下应该取$t$为中值</p><h3 id="1-4-Huber-Loss"><a href="#1-4-Huber-Loss" class="headerlink" title="1.4 Huber Loss"></a>1.4 Huber Loss</h3><ul><li>上面介绍了MSE和MAE，他们各有各的优缺点，MSE 损失收敛快但容易受 outlier 影响，MAE 对 outlier 更加健壮但是收敛慢，而Huber Loss则是将两者结合起来，原理很简单，就是误差接近 0 时使用 MSE，误差较大时使用 MAE：</li></ul><script type="math/tex; mode=display">J_{huber} = \frac{1}{N} \sum_{i=1}^{N} \mathbb{I}_{\left|y_{i}-\hat{y}_{i}\right| \leq \delta} \frac{\left(y_{i}-\hat{y}_{i}\right)^{2}}{2}+\mathbb{I}_{\left|y_{i}-\hat{y}_{i}\right|>\delta}\left(\delta\left|y_{i}-\hat{y}_{i}\right|-\frac{1}{2} \delta^{2}\right)</script><ul><li>前半部分是MSE部分，后半部分是MAE部分，超参数$\delta$为两个部分的连接处</li><li>MAE部分为$\delta |y_i - \hat{y_i}| - \frac{1}{2}\delta ^2$是为了在$|y_i - \hat{y_i}| = \delta$ 端点处连续可导</li></ul><p><img src="https://i.loli.net/2021/11/09/e6FQMBY42PDGxtI.png" alt="超参数为1的Huber Loss"></p><ul><li>Huber Loss 结合了 MSE 和 MAE 损失，在误差接近 0 时使用 MSE，使损失函数可导并且梯度更加稳定；在误差较大时使用 MAE 可以降低 outlier 的影响，使训练对 outlier 更加健壮。缺点是需要额外地设置一个$\delta$超参数。</li></ul><h3 id="1-5-分位数损失（Quantile-Loss）"><a href="#1-5-分位数损失（Quantile-Loss）" class="headerlink" title="1.5 分位数损失（Quantile Loss）"></a>1.5 分位数损失（Quantile Loss）</h3><script type="math/tex; mode=display">J_{\text {quant }}=\frac{1}{N} \sum_{i=1}^{N} \mathbb{I}_{\hat{y}_{i} \geq y_{i}}(1-r)\left|y_{i}-\hat{y}_{i}\right|+\mathbb{I}_{\hat{y}_{i}<y_{i}} r\left|y_{i}-\hat{y}_{i}\right|</script><ul><li>这是一个分段函数，这个损失函数是一个分段的函数 ，将$\hat{y_i} \geq y_i$（高估） 和$\hat{y_i} &lt; y_i$（低估) 两种情况分开来，并分别给予不同的系数</li><li>分位数损失实现了分别用不同的系数（r和1-r）控制高估和低估的损失</li><li>特别地，当$r = 0.5$时分位数损失退化为 MAE 损失</li></ul><p><img src="https://i.loli.net/2021/11/09/BvpTeXqWFYRKoMU.png" alt="Quantile Loss"></p><h3 id="1-6-交叉熵损失（Cross-Entropy-Loss）"><a href="#1-6-交叉熵损失（Cross-Entropy-Loss）" class="headerlink" title="1.6 交叉熵损失（Cross Entropy Loss）"></a>1.6 交叉熵损失（Cross Entropy Loss）</h3><ul><li>上文介绍的几种损失函数都是适用于回归问题损失函数，对于分类问题，最常用的损失函数是交叉熵损失函数 </li></ul><h5 id="1-6-1-二分类"><a href="#1-6-1-二分类" class="headerlink" title="1.6.1 二分类"></a>1.6.1 二分类</h5><script type="math/tex; mode=display">J_{C E}=-\sum_{i=1}^{N}\left(y_{i} \log \left(\hat{y}_{i}\right)+\left(1-y_{i}\right) \log \left(1-\hat{y}_{i}\right)\right)</script><p><img src="https://i.loli.net/2021/11/09/hPt1nITJ624Llfp.png" alt="二分类的交叉熵"></p><ul><li>证明：</li></ul><p>在二分类中我们通常将输出结果用sigmoid映射到区间$(0, 1)$，并将其作为该类的概率，由于只有两类，所以给定$x_i$求出类别为1或0的概率分别为：</p><script type="math/tex; mode=display">\begin{gather}p(y_i = 1|x_i) = \hat{y_i} \\p(y_i = 0|x_i) = 1 - \hat{y_i}\end{gather}</script><p>合并成一个式子：</p><script type="math/tex; mode=display">p(y_i|x_i) = (\hat{y_i})^{y_i}(1 - \hat{y_i})^{1 - y_i}</script><p>由于各数据点独立同分布，则似然可以表示为：</p><script type="math/tex; mode=display">L(x, y) = \prod_{i=1}^{N}\left(\hat{y}_{i}\right)^{y_{i}}\left(1-\hat{y}_{i}\right)^{1-y_{i}}</script><p>取负对数：</p><script type="math/tex; mode=display">N L L(x, y)=J_{C E}=-\sum_{i=1}^{N}\left(y_{i} \log \left(\hat{y}_{i}\right)+\left(1-y_{i}\right) \log \left(1-\hat{y}_{i}\right)\right)</script><h5 id="1-6-2-多分类"><a href="#1-6-2-多分类" class="headerlink" title="1.6.2 多分类"></a>1.6.2 多分类</h5><p>在多分类的任务中，交叉熵损失函数的推导思路和二分类是一样的，变化的地方是真实值$y_i$现在是一个 One-hot 向量，同时模型输出的压缩由原来的 Sigmoid 函数换成 Softmax 函数</p><script type="math/tex; mode=display">J_{C E}=-\sum_{i=1}^{N} \sum_{k=1}^{K} y_{i}^{k} \log \left(\hat{y}_{i}^{k}\right)</script><p>因为$y_i$是一个One-hot向量，所以还可以写为：</p><script type="math/tex; mode=display">J_{C E}=-\sum_{i=1}^{N} y_{i}^{c_{i}} \log \left(\hat{y}_{i}^{c_{i}}\right)</script><p>其中$c_i$为样本$x_i$的目标类</p><ul><li>证明：</li></ul><p>对于一个样本，分类正确的概率为：</p><script type="math/tex; mode=display">p(y_i|x_i) = \prod_{k=1}^{K}\left(\hat{y}_{i}^{k}\right)^{y_{i}^{k}}</script><p>（其中$y_i^k和\hat{y_i}^k$为该向量的第k维）</p><p>因为所有样本相互，所有相乘再取负对数即可得到：</p><script type="math/tex; mode=display">N L L(x, y)=J_{C E}=-\sum_{i=1}^{N} \sum_{k=1}^{K} y_{i}^{k} \log \left(\hat{y}_{i}^{k}\right)</script><h3 id="1-7-合页损失（Hinge-Loss）"><a href="#1-7-合页损失（Hinge-Loss）" class="headerlink" title="1.7 合页损失（Hinge Loss）"></a>1.7 合页损失（Hinge Loss）</h3><ul><li>Hinge Loss也是一种二分类损失函数</li></ul><script type="math/tex; mode=display">J_{\text {hinge }}=\sum_{i=1}^{N} \max \left(0,1-\operatorname{sgn}\left(y_{i}\right) \hat{y}_{i}\right)</script><p>下图是$y$为正类， 即$sgn(y) = 1$时，不同输出的合页损失示意图：</p><p><img src="https://i.loli.net/2021/11/09/KngeQOwp54JZRMf.png" alt="image-20211109225642368"></p><ul><li>可以看到当$y$为正类时，模型输出负值会有较大的惩罚，当模型输出为正值且在$(0, 1)$区间时还会有一个较小的惩罚。即合页损失不仅惩罚预测错的，并且对于预测对了但是置信度不高的也会给一个惩罚，只有置信度高的才会有零损失。<strong>使用合页损失直觉上理解是要找到一个决策边界，使得所有数据点被这个边界正确地、高置信地被分类</strong></li><li><p><strong>Hinge Loss常用在支持向量机（SVM）中，在SVM的软间隔中替换数学性质不好的0/1损失</strong></p></li><li><p><strong>Hinge Loss变种：</strong>有些时候我们关注的并不是单个样本的分类结果，而是两个样本之间的相似性，所以会使用：</p></li></ul><script type="math/tex; mode=display">\ell= \max(0, m + score(pos\_pair) - score(neg\_pair))</script><p>其中两个score分别为正负样本对的得分，m是间隔参数margin，目的是<strong>希望正样本分数越高越好，负样本分数越低越好，但二者得分之差最多到m就足够了，差距增大并不会有任何奖励。这样能够拉开正负样本间的差距，更好区分正负样本</strong></p><h1 id="2-评估模型的指标"><a href="#2-评估模型的指标" class="headerlink" title="2 评估模型的指标"></a>2 评估模型的指标</h1><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p><img src="https://i.loli.net/2021/11/09/OCNnaMs2ceBQIJz.png" alt="image-20211109233859657"></p><h3 id="2-2-查准率和查全率"><a href="#2-2-查准率和查全率" class="headerlink" title="2.2 查准率和查全率"></a>2.2 查准率和查全率</h3><script type="math/tex; mode=display">查准率 P（Precision） = \frac{TP}{TP + FP}</script><script type="math/tex; mode=display">查全率 R（Recall） = \frac{TP}{TP + FN}</script><ul><li>查准率可以直观理解为所有预测为正项的样本中有多少是真正的正项</li><li>查全率可以直观理解为所有label是正项的样本中有多少被成功预测出来了</li><li>理想情况下，查准率和查全率两者都越高越好。<strong>然而事实上这两者在某些情况下是矛盾的，一般来说，查准率高时，查全率低；查确率低时，查全率高</strong></li></ul><h3 id="2-3-准确率和错误率"><a href="#2-3-准确率和错误率" class="headerlink" title="2.3 准确率和错误率"></a>2.3 准确率和错误率</h3><p>准确率：</p><script type="math/tex; mode=display">accuracy = \frac{TP + TF}{TP + TN + FP + FN}</script><ul><li>即有多少样本被分类正确</li></ul><p>而错误率：</p><script type="math/tex; mode=display">errorrate = 1 - accuracy</script><h3 id="2-4-P-R曲线"><a href="#2-4-P-R曲线" class="headerlink" title="2.4 P-R曲线"></a>2.4 P-R曲线</h3><p><img src="https://i.loli.net/2021/11/10/zV1Sj4HyYfD3G5e.png" alt="image-20211110000609300" style="zoom: 80%;" /></p><ul><li>P-R曲线直观地显示出学习器在样本总体上地查全率、查准率，在进行比较时，<strong>若一个学习器的P-R曲线被另一个学习器曲线“完全包住”，则可以断言后者的性能一定优于前者，如上图的B性能优于C，而A、B不一定</strong></li><li>平衡点（BEP）时$P = R$时的取值，如上图A的BEP为0.8，而如果基于BEP比较，可知A优于B</li></ul><h3 id="2-5-F函数"><a href="#2-5-F函数" class="headerlink" title="2.5 F函数"></a>2.5 F函数</h3><p>BEP还是过于简化了些，更常用得是F1度量，我们可以取P和R的调和平均：</p><script type="math/tex; mode=display">\frac{2}{F_1} = \frac{1}{P} + \frac{1}{R}</script><p>求得：</p><script type="math/tex; mode=display">F1 = \frac{2PR}{P + R}</script><p>但是在许多应用中我们对查准率和查全率得重视程度不同，所以可以给予P和R不同的权重，取P和R的加权调和平均：</p><script type="math/tex; mode=display">\frac{1}{F_{\beta}} = \frac{1}{1 + \beta ^2}(\frac{1}{P} + \frac{\beta ^2}{R})</script><p>求得：</p><script type="math/tex; mode=display">F_{\beta} = \frac{(1 + \beta ^2)PR}{\beta ^2P + R}</script><ul><li>$\beta &gt; 0$度量了查全率和查准率的相对重要性，$\beta = 1$退化为标准的F1，$\beta &gt; 1$查全率有更大影响，$\beta &lt; 1$查准率有更大影响</li></ul><h3 id="2-6-ROC与AUC"><a href="#2-6-ROC与AUC" class="headerlink" title="2.6 ROC与AUC"></a>2.6 ROC与AUC</h3><h5 id="2-6-1-基本概念"><a href="#2-6-1-基本概念" class="headerlink" title="2.6.1 基本概念"></a>2.6.1 基本概念</h5><ul><li><p>大多二分类问题是将输出的预测值与一个<strong>分类阈值（threshold）</strong>进行比较，若预测值大于阈值则为正类，反之则为负类</p></li><li><p>根据预测值，我们可将测试样本进行排序，根据预测值由大到小，“最可能”是正例的排在前面，“最不可能”是正例的排到后面。<strong>这样，分类过程就相当于以中间某个截断点（也就是分类阈值）将样本分为两部分，前一部分判定为正例，后一部分判定为反例</strong></p></li><li><p>在不同的任务中，我们我们可以根据任务需求采取不同的截断点。例如如更重视查准率，可以将截断点设置靠前，更注重查全率，可以将截断点靠后</p></li><li>而我们根据预测值进行排序后，按顺序将样本逐个作为正例进行预测，每次计算出<strong>真正例率（TPR）</strong>和<strong>假正例率（FPR）</strong>，以他们为横纵坐标就得到了<strong>ROC曲线</strong></li></ul><h5 id="2-6-2-ROC曲线"><a href="#2-6-2-ROC曲线" class="headerlink" title="2.6.2 ROC曲线"></a>2.6.2 ROC曲线</h5><ul><li>首先介绍真正例率和假正例率：</li></ul><script type="math/tex; mode=display">\begin{gather}TPR = \frac{TP}{TP + FN}, \\FPR = \frac{FP}{TN + FP}\end{gather}</script><ul><li>ROC曲线：</li></ul><p>首先将分类阈值设最大，则所有类都被分类为负类，TPR和FPR都为0，然后每次将分类阈值设为下一个样本点的预测值（按预测值由大到小进行排序），记录每次的TPR和FPR，组成ROC曲线</p><p><img src="https://i.loli.net/2021/11/10/TUMHuC3N9rX18iz.png" alt="image-20211110140633061"></p><p>但是现实中我们是基于有限个样本画的图，所以不会产生这么平滑的曲线，更多情况应该像下图：</p><p><img src="https://i.loli.net/2021/11/10/xG1TrPNfyimzq7Q.png" alt="image-20211110140853013"></p><ul><li>基于ROC的比较方法</li></ul><blockquote><p>如果一个学习器的ROC曲线完全被另一个学习器的”包住“，则后者性能优于前者</p><p>若两者的曲线交叉，则可以通过ROC曲线所包裹的面积进行判断，即<strong>AUC</strong></p></blockquote><h5 id="2-6-3-AUC"><a href="#2-6-3-AUC" class="headerlink" title="2.6.3 AUC"></a>2.6.3 AUC</h5><ul><li><strong>AUC就是ROC曲线下的面积</strong>，假定ROC曲线是由坐标为<script type="math/tex">\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right),\left(x_{3}, y_{3}\right), \cdots,\left(x_{m}, y_{m}\right)</script>的点按序连接而形成，则AUC为：</li></ul><script type="math/tex; mode=display">A U C=\frac{1}{2} \sum_{i=1}^{m-1}\left(x_{i+1}-x_{i}\right)\left(y_{i}+y_{i+1}\right)</script><ul><li><p>从Mann–Whitney U statistic的角度来解释，AUC就是从所有1样本中随机选取一个样本， 从所有0样本中随机选取一个样本，然后根据你的分类器对两个随机样本进行预测，把1样本预测为1的概率为p1，把0样本预测为1的概率为p0，p1&gt;p0的概率就等于AUC， 即<strong>AUC是指随机给定一个正样本和一个负样本，分类器输出该正样本为正的那个概率值比分类器输出该负样本为正的那个概率值要大的可能性</strong></p></li><li><p><strong>所以AUC反应的是分类器对样本的排序能力</strong></p></li></ul><p>证明：</p><p>设所有正类的集合$X = { \hat{X_1}, \hat{X_2}, …, \hat{X_m}}$和负类的集合$Y = { \hat{Y_1}, \hat{Y_2}, …, \hat{Y_n}}$，其中是每个样本对应的预测值，设分类阈值为c，$F_X(x)$和$F_Y(y)$分别为X和Y的分布函数，则$TPR(c) = 1 - F_X(c)$，$FPR(c) = 1 - F_Y(c)$</p><p>设$t = FPR(c)$， 则$c = F_Y^{-1}(1 - t)$，则$ROC(t) = 1 - F_X(F_Y^{-1}(1 - t))$</p><p>则：</p><script type="math/tex; mode=display">\begin{gather}AUC = \int_0^1ROC(t)dt \\=\int_0^1 [1 - F_X(F_Y^{-1}(1 - t))] dt \\=\int_0^1 [1 - F_X(F_Y^{-1}(t))] dt \\=\int_{-\infty}^{+\infty} [1 - F_X(y)] dF_Y(y) \\=\int_{-\infty}^{+\infty}P(X > y)f_Y(y)dy \\=\int_{-\infty}^{+\infty}P(X > y, Y = y)dy \\=P(X > Y)\end{gather}</script><h5 id="2-6-4-使用ROC和AUC的优点"><a href="#2-6-4-使用ROC和AUC的优点" class="headerlink" title="2.6.4 使用ROC和AUC的优点"></a>2.6.4 使用ROC和AUC的优点</h5><ul><li><strong>AUC的计算方法同时考虑了学习器对于正例和负例的分类能力，在样本不平衡（正负类样本不相同）的情况下，依然能够对分类器做出合理的评价</strong></li></ul><script type="math/tex; mode=display">\begin{gather}TPR = P(\hat{Y} = 1 | Y = 1), \\FPR = P(\hat{Y} = 1 | Y = 0)\end{gather}</script><p><strong>由上式可得：无论Y的真实概率是多少， 都不会影响TPR和FPR</strong></p><p>而PR曲线更关注正例</p><ul><li>ROC曲线能很容易的查出任意阈值对学习器的泛化性能影响，有助于选择最佳的阈值。ROC曲线越靠近左上角，模型的查全率就越高。最靠近左上角的ROC曲线上的点是分类错误最少的最好阈值，其假正例和假反例总数最少</li></ul><ul><li>上面几种评估方法都是<strong>用于分类</strong>的评估方法，而在<strong>回归问题</strong>当中，这些一般是不适用的，回归问题中我们比较常用的评估方法有一下两种</li></ul><h3 id="2-7-平方根误差（RMSE）"><a href="#2-7-平方根误差（RMSE）" class="headerlink" title="2.7 平方根误差（RMSE）"></a>2.7 平方根误差（RMSE）</h3><script type="math/tex; mode=display">RMSE = \sqrt{\frac{\sum_{i = 1}^n(y_i - \hat y_i)^2}{n}}</script><ul><li>其实RMSE就是MSE开了个根，但是我们做这样的处理能让<strong>误差和结果值在同一个数量级上，这样能更直观有效的反应拟合程度</strong></li><li>但是RMSE有着和MSE一样的缺点，那就是<strong>对离群值十分敏感，健壮性很差</strong></li><li>比如在实际应用中，有可能在对于预测某些剧集的流量时，以便进行广告投放，在95%的区间内的预测误差都十分低，比如小于1%，这是相当不错的预测结果。但是在总体上，无论运用何种模型，RMSE可能都一直居高不下。<strong>原因是可能在剩余的5%区间里有非常严重的离群点，比如某些冷门剧、新上映的剧</strong></li><li>对此我们可以选择对数据进行处理，或者换一种模型指标</li></ul><h3 id="2-8-平均绝对百分比误差（MAPE）"><a href="#2-8-平均绝对百分比误差（MAPE）" class="headerlink" title="2.8 平均绝对百分比误差（MAPE）"></a>2.8 平均绝对百分比误差（MAPE）</h3><script type="math/tex; mode=display">MAPE = \sum_{i = 1}^n |\frac{y_i - \hat{y}_i}{y_i}| \times \frac{100}{n}</script><ul><li>相比RMSE， MAPE相当于把每个点的误差进行了归一化，降低了个别离群点带来的影响</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>激活函数的作用和比较</title>
    <link href="/2021/10/20/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%AF%94%E8%BE%83/"/>
    <url>/2021/10/20/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1 线性结构"></a>1 线性结构</h1><p>如果满足：</p><script type="math/tex; mode=display">y = wx + b</script><p>则可称y、x间具有线性关系</p><p>而对于神经网络，相邻两层之间的输出之间满足：</p><script type="math/tex; mode=display">X^{[l]} = w^{[l]}X^{[l - 1]} + b^{[l]}</script><p>则可称其满足线性结构</p><h1 id="2-激活函数的作用"><a href="#2-激活函数的作用" class="headerlink" title="2 激活函数的作用"></a>2 激活函数的作用</h1><ul><li>我们先假设不用激活函数，假设神经网络有3层，每层的权重为$w^{[l]}$，偏差都为$b^{[l]}$，输入为$X$，输出为$Y$，则从头到尾的计算为：</li></ul><script type="math/tex; mode=display">Y = w^{[3]}(w^{[2]}(w^{[1]}X + b^{[1]}) + b^{[2]}) + b^{[3]}</script><p>就相当于做一次线性运算：</p><script type="math/tex; mode=display">Y = w'X + b'</script><p>则从头到尾都是线性结构，这在某些情况是适用的，但是大多数时候输入和输出的关系是非线性的，<strong>这时候我们就需要引入非线性因素，即激活函数，来使得神经网络有足够的capacity来抓取复杂的pattern</strong></p><p>所谓激活函数（Activation Function），就是在人工神经网络的神经元上运行的函数，负责将神经元的输入映射到输出端。</p><ul><li><strong>能用线性拟合的情况：</strong></li></ul><p><img src="https://i.loli.net/2021/11/11/NdbYFTOkwyBj7xh.png" alt="image-20211111115632781" style="zoom:50%;" /></p><ul><li><strong>无法用线性拟合的情况：</strong></li></ul><p><img src="https://i.loli.net/2021/11/11/Zvo5O17LesqBbVF.png" alt="image-20211111115745462" style="zoom:50%;" /></p><h1 id="3-常用激活函数的优缺点"><a href="#3-常用激活函数的优缺点" class="headerlink" title="3 常用激活函数的优缺点"></a>3 常用激活函数的优缺点</h1><h3 id="3-1-Sigmoid函数"><a href="#3-1-Sigmoid函数" class="headerlink" title="3.1 Sigmoid函数"></a>3.1 Sigmoid函数</h3><ol><li><p>Sigmoid具有一个很好的特性就是能将输入值映射到$(0, 1)$，便于我们将值转化为概率，并且sigmoid平滑，便于求导</p></li><li><p>但sigmoid还有三大缺点：</p></li></ol><ul><li><strong>Gradient Vanishing：</strong></li></ul><p><img src="https://i.loli.net/2021/11/11/TWxNvl6CrD4kuAU.png" alt="image-20211111155149051"></p><p><strong>由图可以看出，在输入值较大或者较小时，其导数是趋于0，而在梯度下降时，其值就基本不会被更新</strong></p><ul><li><strong>函数输出并不是zero-centered</strong></li></ul><p>我们以一个二维的情况举例：</p><script type="math/tex; mode=display">f(\vec{x} ; \vec{w}, b)=f\left(w_{0} x_{0}+w_{1} x_{1}+b\right)</script><p>现在假设，参数 $w_0, w_1$ 的最优解 $w_0^∗, w_1^∗$ 满足条件:</p><script type="math/tex; mode=display">\left\{\begin{array}{l}w_{0}<w_{0}^{*} \\w_{1} \geqslant w_{1}^{*}\end{array}\right.</script><p>所以我们现在就是要让$w_0$变大，$w_1$变小，而：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w_0} = x_0 \frac{\partial L}{\partial f}, \\\frac{\partial L}{\partial w_1} = x_1 \frac{\partial L}{\partial f}</script><p>由于上一层sigmoid输出的$x_0, x_1$为正值，所以$w_0, w_1$的梯度一定同正或同负，所以我们要逼近最小值点，只能走下图红色线路：</p><p><img src="https://i.loli.net/2021/11/11/IXqb8Brk9KOH7WG.png" alt="image-20211111160220315" style="zoom:50%;" /></p><p>而显然绿色线路才是最快的，但是由于绿色路线的<script type="math/tex">\frac{\partial L}{\partial w_0},\frac{\partial L}{\partial w_1}</script>符号相反，所以不能走，所以这会<strong>影响梯度下降的速度</strong></p><ul><li><strong>幂运算相对来说比较耗时</strong></li></ul><h3 id="3-2-Tanh函数"><a href="#3-2-Tanh函数" class="headerlink" title="3.2 Tanh函数"></a>3.2 Tanh函数</h3><ul><li>tanh一般优于sigmoid，就是因为tanh是zero-centered，但是tanh仍然没有解决sigmoid的其他两个问题</li></ul><h3 id="3-3-ReLu函数"><a href="#3-3-ReLu函数" class="headerlink" title="3.3 ReLu函数"></a>3.3 ReLu函数</h3><ol><li>优点：</li></ol><ul><li>解决了gradient vanishing问题 (在正区间)</li><li>计算速度非常快，只需要判断输入是否大于0</li><li>收敛速度快</li></ul><ol><li>缺点：</li></ol><ul><li>ReLU的输出不是zero-centered</li><li><strong>Dead ReLU Problem：</strong></li></ul><p>指的是某些神经元可能永远不会被激活，导致相应的参数永远不能被更新。</p><p>在x&lt;0时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应</p><p><strong>产生原因：</strong></p><ol><li><p>参数初始化问题（比较少见）</p></li><li><p>learning rate太高导致在训练过程中参数更新太大</p></li></ol><p>而为了防止这种情况，我们可以使用改进的ReLu函数，如Leaky ReLu：</p><script type="math/tex; mode=display">f(x) = max(0.01x, x)</script><p>但是大部分时候我们还是使用ReLu，很多时候LReLu的表现和ReLu其实相差不多，只有神经元大量坏死，ReLu表现不好的时候，我们才会考虑使用LReLu，甚至更复杂的PReLu和ELU</p><h3 id="3-4-GeLU函数"><a href="#3-4-GeLU函数" class="headerlink" title="3.4 GeLU函数"></a>3.4 GeLU函数</h3><ul><li>其实ReLU的非线性因素在于：<strong><script type="math/tex">P=0.5</script>的概率随机使一部分神经元失活</strong></li><li>而GeLU相当于把这个概率分布改为了标准正态分布：</li></ul><script type="math/tex; mode=display">\operatorname{GELU}(\mathrm{x})=\mathrm{xP}(\mathrm{X}<=\mathrm{x})=\mathrm{x} \Phi(\mathrm{x})</script><ul><li><p>GeLU的思想在于：<strong>直观来说，因为一般更大的激活值更加重要，所以我们希望拥有更大激活值的神经元失活的概率小一些，所以采用了累积概率分布来体现这一点</strong></p></li><li><p>在具体使用中一般不使用标准正态分布，而使用其近似值：</p></li></ul><script type="math/tex; mode=display">\operatorname{GELU}(\mathrm{x})=0.5 \mathrm{x}\left(1+\tanh \left[\sqrt{2 / \pi}\left(\mathrm{x}+0.044715 \mathrm{x}^{3}\right)\right]\right)</script><ul><li>而BERT的源码中的实现还要简便一些：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gelu</span>(<span class="hljs-params">input_tensor</span>):</span><br>cdf = <span class="hljs-number">0.5</span> * (<span class="hljs-number">1.0</span> + tf.erf(input_tensor / tf.sqrt(<span class="hljs-number">2.0</span>)))<br><span class="hljs-keyword">return</span> input_tesnsor*cdf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习基础总结</title>
    <link href="/2021/10/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-行业知识体系"><a href="#1-行业知识体系" class="headerlink" title="1 行业知识体系"></a>1 行业知识体系</h1><h3 id="1-1-机器学习算法"><a href="#1-1-机器学习算法" class="headerlink" title="1.1 机器学习算法"></a>1.1 机器学习算法</h3><p><img src="https://i.loli.net/2021/10/31/romyfLZ5KjP9a3B.jpg" alt="qq_pic_merged_1635482805011"></p><h3 id="1-2-机器学习分类"><a href="#1-2-机器学习分类" class="headerlink" title="1.2 机器学习分类"></a>1.2 机器学习分类</h3><p><img src="https://i.loli.net/2021/10/31/7Lvd8NIsezYm1Qy.jpg" alt="qq_pic_merged_1635482964705"></p><h1 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2 线性回归"></a>2 线性回归</h1><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p><img src="https://i.loli.net/2021/10/31/ChVyXvJetFWN5Y8.png" alt="image-20211029131504886"></p><ul><li><p>线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析</p></li><li><p>线性回归输出是⼀个连续值，因此适⽤于回归问题</p></li></ul><h3 id="2-2-损失函数"><a href="#2-2-损失函数" class="headerlink" title="2.2 损失函数"></a>2.2 损失函数</h3><ul><li><strong>均方差（mse）：</strong></li></ul><script type="math/tex; mode=display">\ell^{(i)}(W, b) = \frac{(\hat{y}^{(i)} - y^{(i)})^2}{2}</script><p>其中$\hat{y}$为计算出的预测值，$y$为真实值（label）</p><h1 id="3-全连接层（稠密层）"><a href="#3-全连接层（稠密层）" class="headerlink" title="3  全连接层（稠密层）"></a>3  全连接层（稠密层）</h1><ul><li>输出层中的神经元和输⼊ 层中各个输⼊完全连接</li><li>计算完全依赖于输入层。</li></ul><h1 id="4-小批量随机梯度下降"><a href="#4-小批量随机梯度下降" class="headerlink" title="4  小批量随机梯度下降"></a>4  小批量随机梯度下降</h1><ul><li><p>在每次迭代中，先随机均匀采样⼀个由固定数⽬训练数据样本所组成的小批量（mini-batch）$\mathbb{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后⽤此结果与预先设定的⼀个正数的乘积（学习率$\eta$）作为模型参数在本次迭代的减小量。</p></li><li><p>每次mini-batch梯度下降计算过程：</p></li></ul><script type="math/tex; mode=display">w_1 = w_1 - \frac{\eta}{|\mathbb{B}|}\sum_{i \in \mathbb{B}}\frac{\partial{\ell(...)}}{\partial{w_1}}</script><ul><li>注意学习率要取正数</li></ul><h1 id="5-Softmax分类"><a href="#5-Softmax分类" class="headerlink" title="5  Softmax分类"></a>5  Softmax分类</h1><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><ul><li>softmax回归跟线性回归⼀样将输⼊特征与权重做线性叠加。与线性回归的⼀个主要不同在于， softmax回归的输出值个数等于标签⾥的类别数</li><li>由于输出元有多个，所以我们要讲输出做softmax计算，得到的结果作为该类的概率，具体计算如下：</li></ul><p>假设输出元有3个，输出值分别为$o_1, o_2, o_3$， 则:</p><script type="math/tex; mode=display">\hat{y}_1, \hat{y}_2, \hat{y}_3 = softmax(o_1, o_2, o_3)</script><p>其中</p><script type="math/tex; mode=display">\hat{y}_i = \frac{e^{o_i}}{\sum_{j = 1}^{3}e^{o_j}}</script><ul><li>容易看出$\sum_{i = 1}^{3}y_i = 1$（即所有概率加起来等于1）</li><li>通常，我们把预测概率最⼤的类别作为输出类别</li></ul><h3 id="5-2-损失函数"><a href="#5-2-损失函数" class="headerlink" title="5.2 损失函数"></a>5.2 损失函数</h3><ul><li>这里我们运用交叉熵损失函数（cross entropy）：</li></ul><script type="math/tex; mode=display">H(y^{(i)}, \hat{y}^{(i)}) = -\sum_{j = 1}^qy_j^{(i)}\log{\hat{y}^{(i)}}</script><p>q为输出元个数$\times$样本个数，即所有样本的所有输出元都要参与运算，最后求平均值</p><h1 id="6-多层感知机（MLP）"><a href="#6-多层感知机（MLP）" class="headerlink" title="6 多层感知机（MLP）"></a>6 多层感知机（MLP）</h1><ul><li>多层感知机有一到多个隐藏层</li><li>多层感知机中的隐藏层和输出层都是全连接层</li><li>多层感知机具有激活函数，下面介绍常用激活函数</li></ul><h1 id="7-激活函数"><a href="#7-激活函数" class="headerlink" title="7 激活函数"></a>7 激活函数</h1><h3 id="7-1-Sigmoid函数"><a href="#7-1-Sigmoid函数" class="headerlink" title="7.1 Sigmoid函数"></a>7.1 Sigmoid函数</h3><script type="math/tex; mode=display">sigmoid(x) = \frac{1}{1 + e^{-x}}</script><script type="math/tex; mode=display">sigmoid'(x) = sigmoid(x)(1 - sigmoid(x))</script><p><img src="https://i.loli.net/2021/10/31/2JsDXo9mQtI6rzM.png" alt="image-20211030004640247"></p><ul><li>一般用在二分类的输出层中</li></ul><h3 id="7-2-tanh函数"><a href="#7-2-tanh函数" class="headerlink" title="7.2 tanh函数"></a>7.2 tanh函数</h3><script type="math/tex; mode=display">tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}}</script><script type="math/tex; mode=display">tanh'(x) = 1 - tanh^2(x)</script><p><img src="https://i.loli.net/2021/10/31/rdx3sEtVFGlHink.png" alt="image-20211030005138300"></p><ul><li>tanh和sigmoid比较相似，但是性能一般要优于sigmoid</li></ul><h3 id="7-3-ReLU函数"><a href="#7-3-ReLU函数" class="headerlink" title="7.3 ReLU函数"></a>7.3 ReLU函数</h3><script type="math/tex; mode=display">ReLU(x) = max(0, x)</script><p><img src="https://i.loli.net/2021/10/31/6Ioqb3OBldsCuS8.png" alt="image-20211030005121490"></p><ul><li>十分常用</li></ul><h3 id="7-4-Leaky-ReLU函数"><a href="#7-4-Leaky-ReLU函数" class="headerlink" title="7.4 Leaky ReLU函数"></a>7.4 Leaky ReLU函数</h3><script type="math/tex; mode=display">Leaky\_Relu(x) = max(0.1 * x, x)</script><p><img src="https://i.loli.net/2021/10/31/qA4w6a7Irj3WEJg.png" alt="image-20211030005818507"></p><h1 id="8-训练误差和泛化误差"><a href="#8-训练误差和泛化误差" class="headerlink" title="8 训练误差和泛化误差"></a>8 训练误差和泛化误差</h1><h3 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h3><ul><li><strong>训练误差：</strong>指模型在训练数据集上表现出的误差</li><li><strong>泛化误差：</strong>指模型在任意⼀个测试数据样本上表现出的误差的期望</li></ul><h3 id="8-2-k折交叉验证"><a href="#8-2-k折交叉验证" class="headerlink" title="8.2 k折交叉验证"></a>8.2 k折交叉验证</h3><ul><li>当训练数据不够⽤时，预留⼤量的验证数据显得太奢侈，这时候就可以运用k折交叉验证法</li><li>即我们把原始训练数据 集分割成k个不重合的⼦数据集，然后我们做k次模型训练和验证。每⼀次，我们使⽤⼀个子数据集验证模型，并使⽤其他k − 1个⼦数据集来训练模型，最后，我们对这k次训练误差和验证误差分别求平均。</li></ul><h3 id="8-3-欠拟合和过拟合"><a href="#8-3-欠拟合和过拟合" class="headerlink" title="8.3 欠拟合和过拟合"></a>8.3 欠拟合和过拟合</h3><ul><li><p><strong>欠拟合：</strong>训练误差过高</p></li><li><p><strong>过拟合：</strong>泛化误差过高</p></li><li><p>我们知道进行反向传播的目的是让学习器去拟合数据，而当拟合程度不够时就称为<strong>欠拟合</strong>，拟合程度过于高时则称为<strong>过拟合</strong>，用下图可以很好的解释：</p><p><img src="https://i.loli.net/2021/11/11/npR3aNjrLOISQC8.png" alt="image-20211111215618245"  /></p></li><li><p>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了，<strong>可以使用early stop来防止训练时间不足导致的欠拟合</strong>。但是如果真的还是存在的话，可以通过<strong>增加网络复杂度</strong>或者在模型中<strong>增加特征</strong>，这些都是很好解决欠拟合的方法。而一般我们更加关注的是如何如何防止过拟合</p></li></ul><h3 id="8-4-造成过拟合的原因"><a href="#8-4-造成过拟合的原因" class="headerlink" title="8.4 造成过拟合的原因"></a>8.4 造成过拟合的原因</h3><ul><li><strong>训练数据集样本单一，样本不足</strong>。如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型</li><li><strong>训练数据中噪声干扰过大</strong>。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系</li><li><strong>模型过于复杂。</strong>模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。<blockquote><ul><li>模型太复杂是过拟合的重要因素，下面提到的正则化方法和Dropout方法都是基于减少模型复杂度来进行的。</li><li>另外，在模型设计方面有一个根本设计原则<strong>奥卡姆剃刀法则：优先选择拟合数据的最简单的假设。 简单的模型才是最好的</strong></li><li><strong>当模型复杂度过高的时候，拟合函数的系数往往非常大，需要顾忌每一个点，最终形成的拟合函数波动很大</strong>，如上图过拟合情况。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的梯度非常大，所以才需要惩罚项来降低</li><li><strong>模型复杂度也可以解释为：模型对某些非必要的特征过于看重（即给予了较大的权值）</strong></li></ul></blockquote></li></ul><h3 id="8-5-对应过拟合手段"><a href="#8-5-对应过拟合手段" class="headerlink" title="8.5 对应过拟合手段"></a>8.5 对应过拟合手段</h3><h4 id="8-5-1-增加数据"><a href="#8-5-1-增加数据" class="headerlink" title="8.5.1 增加数据"></a>8.5.1 增加数据</h4><ul><li>由于<strong>数据量不足是造成过拟合的根本原因</strong>，所以对应过拟合最有效的手段肯定是增大数据集，但是这种方法成本过高</li><li>在数据层面，还可以进行<strong>数据增强</strong>，创造一些假数据，还可以提升模型的泛化能力</li><li>在CV方面常用的数据增强有旋转图像、缩放图像、随机裁剪等，而在NLP方面还有同义词替换、随机删除词、随机颠倒句子顺序等方法</li></ul><h4 id="8-5-2-正则化"><a href="#8-5-2-正则化" class="headerlink" title="8.5.2 正则化"></a>8.5.2 正则化</h4><ul><li>L2范数惩罚项指的是模型权重参数每个元素的平⽅和与⼀个正的常数的乘积</li><li>损失函数添加一个L2惩罚项：</li></ul><script type="math/tex; mode=display">\ell(...) + \frac{\lambda}{2}\begin{Vmatrix} W \end{Vmatrix}^2</script><p>求导后：（每个mini-batch）</p><script type="math/tex; mode=display">w1 = (1 - \eta\lambda)w1 - \frac{\eta}{|\mathbb{B}|}\sum_{i \in \mathbb{B}}\frac{\partial\ell^{(i)}(...)}{\partial{w1}}</script><p>其中超参数$\lambda$ &gt; 0。当权重参数均为0时，惩罚项最小。当$\lambda$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda$设为0时，惩罚项完全不起作⽤。</p><ul><li>除此之外还有L1正则化，使用L1范数作为惩罚项：</li></ul><script type="math/tex; mode=display">\ell(...) + \frac{\lambda}{2}\begin{Vmatrix} W \end{Vmatrix}</script><ul><li>一般训练集中的损失函数要加惩罚项，测试集中不用</li><li>正则化的原理可以从<strong>拉格朗日乘子法和最大后验概率估计</strong>两方面解释</li><li>首先是拉格朗日乘子法：</li></ul><blockquote><ul><li>设模型本来的优化目标为：</li></ul><script type="math/tex; mode=display">\min _{w} J(w ; X, y)</script><ul><li>而过拟合的原因在于模型复杂度过高，而一般模型复杂度和参数<script type="math/tex">w</script>的稀疏度相关，即<strong>参数越少或参数中0的个数越多，模型复杂度越小</strong></li><li>那么0的个数可以让我们联想到<strong>w的L0范数（代表w中非零元素的个数）</strong>，那么可以<strong>添加一个约束，使得优化目标变为：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{c}\min _{w} J(w ; X, y) \\s \cdot t .\|w\|_{0} \leq C\end{array}</script><ul><li>但是<strong>使用L0范数太过困难，主要是L0范数无法进行求导来反向传播，所以我们退而求其次，要求权重w向量中某些维度的非零参数尽可能接近于0，尽可能的小，所以就可以使用L1、L2范数：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{c}\min _{w} J(w ; X, y) \\s \cdot t .\|w\|_{1} \leq C 或 s \cdot t .\|w\|_{2} \leq C \end{array}</script><ul><li>以L2正则化为例，采用拉格朗日乘子法，其拉格朗日函数为：</li></ul><script type="math/tex; mode=display">\min _{w} J(w ; X, y)+\alpha^{*}\|w\|_{2}^{2}</script><ul><li>这就是现在的优化目标，而后面的一项恰好就是惩罚项</li></ul></blockquote><ul><li>还可以用最大后验概率估计来解释：</li></ul><blockquote><ul><li>最大后验估计的优化目标是：</li></ul><script type="math/tex; mode=display">M A P=\log P(y \mid X, w) P(w)=\log P(y \mid X, w)+\log P(w)</script><ul><li>上式左边的一项即最大化似然的优化目标，也就是本来的不加惩罚项的优化目标；<strong>而右边的一项仅关于参数w的先验分布</strong></li><li>我们对w的先验分布进行不同的假设，即可得到不同的惩罚项</li><li><strong>在L2正则化中，假设<script type="math/tex">w \sim N(0, \sigma^2)</script>，那么有：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{l}\log P(w)=\log \prod_{j} P\left(w_{j}\right)= \\\log \prod_{j}\left[\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{\left(w_{j}\right)^{2}}{2 \sigma^{2}}}\right] \\=-\frac{1}{2 \sigma^{2}} \sum_{j} w_{j}^{2}+C\end{array}</script><p>那么就得到了L2范数作为惩罚项</p><ul><li><strong>L1正则化也一样，假设<script type="math/tex">w</script>服从均值为0参数为a的拉普拉斯分布，那么有：</strong></li></ul><script type="math/tex; mode=display">\begin{array}{l}\log P(w)=\log \prod_{j} P\left(w_{j}\right)= \\\log \prod_{j}\left[\frac{1}{\sqrt{2 a} \sigma} e^{-\frac{w_{j}}{a}}\right] \\=-\frac{1}{2 a} \sum_{j}\left|w_{j}\right|+C\end{array}</script></blockquote><h4 id="8-5-2-丢弃法（Dropout）"><a href="#8-5-2-丢弃法（Dropout）" class="headerlink" title="8.5.2 丢弃法（Dropout）"></a>8.5.2 丢弃法（Dropout）</h4><ul><li>对于每一层的神经元，有一定的概率被丢弃掉，设丢弃概率为p，计算新的单元：</li></ul><script type="math/tex; mode=display">h_i' = \frac{\xi_i}{1 - p}h_i</script><p>$\xi_i$为0和1的概率分别为p和1 - p</p><p>分母中的1- p是为了不改变其输⼊的期望值：</p><script type="math/tex; mode=display">由于E(\xi_i) = 1 - p \\所以E(h_i') = \frac{E(\xi_i)}{1 - p}h_i = h_i</script><ul><li><p>测试模型时，我们为了得到更加确定性的结果，⼀般不使⽤丢弃法</p></li><li><p>进行了Dropout的多层感知机：</p></li></ul><p><img src="https://i.loli.net/2021/10/31/CnUgmA4dVb8vFR2.png" alt="image-20211030141251677"></p><p>可以看到隐藏层中的$h_2$和$h_5$消失了</p><ul><li><p>每一层的丢弃概率可以不同，通常把靠近输⼊层的丢弃概率设得小⼀点</p></li><li><p><strong>Dropout的原理：</strong></p></li></ul><blockquote><ol><li><strong>集成学习：</strong>每次随机置0都可以得到一个新模型，而Dropout可以当作对这些所有新得到的模型的集成</li><li><strong>正则化：</strong>因为Dropout导致两个神经元不一定每次都在一个dropout网络中出现，这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 ，迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。正因为这样，网络由于不知道浅层的哪些神经元会失活，导致网络不敢赋予浅层神经元太大的权重，这样就减轻了网络对某些局部特征的依赖，换句话说网络不会对一些特定的线索片段太过敏感，即使丢失特定的线索，它也可以从众多其它线索中学习一些共同的特征。从这个角度看Dropout就类似于L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。</li></ol></blockquote><h1 id="9-正向传播和反向传播"><a href="#9-正向传播和反向传播" class="headerlink" title="9 正向传播和反向传播"></a>9 正向传播和反向传播</h1><h3 id="9-1-正向传播"><a href="#9-1-正向传播" class="headerlink" title="9.1 正向传播"></a>9.1 正向传播</h3><ul><li>正向传播（forward propagation）是指对神经⽹络沿着从输⼊层到输出层的顺序，依次计算并存储模型的中间变量（包括输出）</li><li>中间变量称为缓存，在反向传播中会用到，避免重复计算，如每层的输出值等</li><li>正向传播的计算图：</li></ul><p><img src="https://i.loli.net/2021/10/31/4LnFKkrSQHsUYNv.png" alt="image-20211030142019713"></p><p>其中：</p><ol><li>左下⻆是输⼊，右上⻆是输出</li><li>⽅框代表变量，圆圈代表运算符</li><li>$J = L + s$，$J$称为目标函数，$L$为损失函数，$s$为惩罚项</li></ol><h3 id="9-2-反向传播"><a href="#9-2-反向传播" class="headerlink" title="9.2 反向传播"></a>9.2 反向传播</h3><ul><li>反向传播最重要的是通过链式法则求导，从后往前进行计算</li><li>反向传播的梯度计算可能依赖于各变量的当前值，而这些变量的当前值是通过正向传播计算得到的</li></ul><h3 id="9-3-衰减和爆炸"><a href="#9-3-衰减和爆炸" class="headerlink" title="9.3 衰减和爆炸"></a>9.3 衰减和爆炸</h3><ul><li>如果隐藏层的层数很大，$H(l)$的计算可能会出现衰减或爆炸，如：</li></ul><p>假设输⼊和所有层的权重参数都是标量，如权重参数为0.2和5，多层感知 机的第30层输出为输⼊X分别与0.2 30 ≈ 1 × 10−21（衰减）和5 30 ≈ 9 × 1020（爆炸）的乘积</p><h3 id="9-4-随机初始化参数"><a href="#9-4-随机初始化参数" class="headerlink" title="9.4 随机初始化参数"></a>9.4 随机初始化参数</h3><ul><li>考虑三种参数的极端情况：</li></ul><blockquote><ol><li><strong>参数很稀疏，那么输入的特征会在经过前向计算后逐渐消失（计算出来都接近0）</strong></li><li><strong>参数很大，输出值容易进入激活函数的饱和区，比如Sigmoid函数</strong></li><li>假设将每个隐藏单元的参数都初始化为相等的值，那么在正向传播时每个隐藏单元将根据相同的输⼊计算出相同的值， 并传递⾄输出层。在反向传播中，每个隐藏单元的参数梯度值相等。因此，这些参数在使⽤基于梯度的优化算法迭代后值依然相等。<strong>在这种情况下，无论隐藏单元有多少， 隐藏层本质上只有1个隐藏单元在发挥作用</strong></li></ol></blockquote><ul><li>可以看出，我们<strong>希望每一层的输出方差能够固定</strong>，因为这样能够防止我们的信号变得很大/直接消失。换句话来说，<strong>我们需要一种权重初始化的手段，使得输入、输出的方差保持不变，</strong>这就是Xavier初始化做的事。</li></ul><h3 id="9-5-Xavier随机初始化"><a href="#9-5-Xavier随机初始化" class="headerlink" title="9.5 Xavier随机初始化"></a>9.5 Xavier随机初始化</h3><ul><li>假设某层的参数，前一层神经元个数为a，后一层神经元个数为b，Xavier随机初始化将使该层中权重参数的每个元素都随机采样于均匀分布：</li></ul><script type="math/tex; mode=display">U(-\sqrt{\frac{6}{a + b}}, \sqrt{\frac{6}{a + b}})</script><ul><li><p>该设计主要为了<strong>在前向计算的时候，经过此层的参数后得到的输出方差不变（即输入输出方差相等）；并且在反向计算的时候，后一层的梯度和前一层的梯度方差也相等</strong></p></li><li><p><strong>Xavier初始化在sigmoid和tanh激活函数上有很好的表现，但是在Relu激活函数上表现很差。</strong></p></li><li><p>现在开始推导，这里只展示前向计算时，首先是有3个假设：</p></li></ul><blockquote><ul><li>激活函数为<script type="math/tex">f(x) = x</script></li><li>偏置项b初始化为0</li><li>输入和参数的期望都为0</li></ul></blockquote><ul><li>设某一层值为<script type="math/tex">x</script>，参数为<script type="math/tex">w</script>，对应输入为<script type="math/tex">y = x^Tw</script>（注意<script type="math/tex">x,w</script>为向量，<script type="math/tex">y</script>为标量），那么我们的目的是：</li></ul><script type="math/tex; mode=display">Var[y] = Var[x] \\Var[x^Tw] = Var[x]</script><ul><li>引入公式：</li></ul><script type="math/tex; mode=display">Var[XY] = E[X^2]E[Y^2] - E^2[X]E^2[Y] \\在E[X] = E[Y]时，可以得出： Var[XY] = Var[X]Var[Y]</script><ul><li>而由于<script type="math/tex">E[w] = E[x] = 0</script>，所以：</li></ul><script type="math/tex; mode=display">Var[x] = Var[x^Tw] = Var[\sum^{N}_ix_iw_i] = N* Var[x]Var[w]</script><p>其中<script type="math/tex">N = dim(x) = dim(w)</script>，即当前层的神经元个数</p><ul><li>由上式可以得出：</li></ul><script type="math/tex; mode=display">N * Var[w] = 1 \\Var[w] = \frac{1}{N}</script><ul><li>而在反向传播的时候，我们同样可以推出<script type="math/tex">Var[w] = \frac{1}{N'}</script>，其中<script type="math/tex">N'</script>为下一层神经元个数</li><li>而由于方差取值无法同时满足前后向，所以采用两者的平均数：</li></ul><script type="math/tex; mode=display">Var[w] = \frac{2}{N + N'}</script><ul><li>我们可以通过<script type="math/tex">N(0, \frac{2}{N+N'})</script>对w取样，也可以使用均匀分布采样，采用均匀函数的时候需要进行一定的放缩（Var[w]的分子不一定为2）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown &amp; Letax常用语法</title>
    <link href="/2021/09/15/%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/15/%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>~<span class="hljs-number">6</span>级标题<br><span class="hljs-attribute">1</span>~<span class="hljs-number">6</span>个#加个空格<br></code></pre></td></tr></table></figure><h1 id="2、代码块"><a href="#2、代码块" class="headerlink" title="2、代码块"></a>2、代码块</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">​``` + 代码语言<br></code></pre></td></tr></table></figure><h1 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">加粗：<span class="hljs-strong">**文本**</span><br>删除线:~~文本~~<br>斜体：<span class="hljs-strong">*文本*</span><br></code></pre></td></tr></table></figure><p>加粗：<strong>文本</strong><br>删除线：<del>文本</del><br>斜体：<em>文本</em></p><h1 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;<span class="hljs-selector-tag">A</span><br>&gt;&gt;<span class="hljs-selector-tag">A</span><br>&gt;&gt;&gt;<span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><blockquote><p>A</p><blockquote><p>A</p><blockquote><p>A</p></blockquote></blockquote></blockquote><h1 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><hr><h1 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[名字]</span>(本地或网页链接)<br></code></pre></td></tr></table></figure><h1 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h1><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[名字](链接)<br></code></pre></td></tr></table></figure><p><a href="www.baidu.com">百度</a></p><h1 id="8、列表"><a href="#8、列表" class="headerlink" title="8、列表"></a>8、列表</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">无序列表<br>- <span class="hljs-comment">(空格)</span> 内容<br>有序列表<br>数字.<span class="hljs-comment">(空格)</span>内容<br></code></pre></td></tr></table></figure><ul><li>无序</li></ul><ol><li>有序</li></ol><h1 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">干脆直接快捷键<br></code></pre></td></tr></table></figure><h1 id="10、Latex"><a href="#10、Latex" class="headerlink" title="10、Latex"></a>10、Latex</h1><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>Latex</th><th>对应形式</th><th>Latex</th><th>对应形式</th></tr></thead><tbody><tr><td>\alpha</td><td>$\alpha$</td><td>\Alpha</td><td>$\Alpha$</td></tr><tr><td>\beta</td><td>$\beta$</td><td>\Beta</td><td>$\Beta$</td></tr><tr><td>\gamma</td><td>$\gamma$</td><td>\Gamma</td><td>$\Gamma$</td></tr><tr><td>\delta</td><td>$\delta$</td><td>\Delta</td><td>$\Delta$</td></tr><tr><td>\epsilon</td><td>$\epsilon$</td><td>\Epsilon</td><td>$\Epsilon$</td></tr><tr><td>\zeta</td><td>$\zeta$</td><td>\Zeta</td><td>$\Zeta$</td></tr><tr><td>\eta</td><td>$\eta$</td><td>\Eta</td><td>$\Eta$</td></tr><tr><td>\theta</td><td>$\theta$</td><td>\Theta</td><td>$\Theta$</td></tr><tr><td>\lambda</td><td>$\lambda$</td><td>\Lambda</td><td>$\Lambda$</td></tr><tr><td>\mu</td><td>$\mu$</td><td>\Mu</td><td>$\Mu$</td></tr><tr><td>\nu</td><td>$\nu$</td><td>\Nu</td><td>$\Mu$</td></tr><tr><td>\xi</td><td>$\xi$</td><td>\Xi</td><td>$\Xi$</td></tr><tr><td>\pi</td><td>$\pi$</td><td>\Pi</td><td>$\Pi$</td></tr><tr><td>\rho</td><td>$\rho$</td><td>\Rho</td><td>$\Rho$</td></tr><tr><td>\sigma</td><td>$\sigma$</td><td>\Sigma</td><td>$\Sigma$</td></tr><tr><td>\varphi  //  \phi</td><td>$\varphi$ // $\phi$</td><td>\Phi</td><td>$\Phi$</td></tr><tr><td>\chi</td><td>$\chi$</td><td>\Chi</td><td>$\Chi$</td></tr><tr><td>\psi</td><td>$\psi$</td><td>\Psi</td><td>$\Psi$</td></tr><tr><td>\omega</td><td>$\omega$</td><td>\Omega</td><td>$\Omega$</td></tr><tr><td>\ell</td><td>$\ell$</td><td>\varepsilon</td><td>$\varepsilon$</td></tr></tbody></table></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><div class="table-container"><table><thead><tr><th>解释</th><th>代码</th></tr></thead><tbody><tr><td>粗体</td><td>\pmb{…..}</td></tr><tr><td>单空格</td><td>\quad</td></tr><tr><td>双空格</td><td>\qquad</td></tr><tr><td>换行</td><td>\\</td></tr><tr><td>$\times$</td><td>\times</td></tr><tr><td>$\div$</td><td>\div</td></tr><tr><td>$\pm$</td><td>\pm</td></tr><tr><td>下标</td><td>_</td></tr><tr><td>上标</td><td>^</td></tr><tr><td>$\hat{a}$</td><td>\hat{a}</td></tr><tr><td><script type="math/tex">\tilde{a}</script></td><td>\tilde{a}</td></tr><tr><td>$\bar{a}$</td><td>\bar{a}</td></tr><tr><td>$\vec{a}$</td><td>\vec{a}</td></tr><tr><td>$\overrightarrow{a}$</td><td>\overrightarrow{a}</td></tr><tr><td>$\overleftarrow{a}$</td><td>\overleftarrow{a}</td></tr><tr><td>$\log_{32}{xy}$</td><td>\log_{32}{xy}</td></tr><tr><td>{ }</td><td>需要转义</td></tr><tr><td>$\sum_1^n$</td><td>\sum_1^n</td></tr><tr><td>$\prod_{k=1}^nk^2$</td><td>\prod_{k=1}^nk^2</td></tr><tr><td>$\tilde{H}$</td><td>\tilde{H}</td></tr><tr><td></td><td></td></tr><tr><td>$\int_a^b$</td><td>\int_a^b</td></tr><tr><td>$\iint$</td><td>\iint</td></tr><tr><td>$\iiint$</td><td>\iiint</td></tr><tr><td>$\infty$</td><td>\infty</td></tr><tr><td>$\lim_{x\to0}$</td><td>极限       \lim_{x\to0}</td></tr><tr><td>$f^{\prime}(x)$</td><td>导数    f^{\prime}(x)</td></tr><tr><td><script type="math/tex">\int_{\theta=0}^{2\pi}    \int_{r=0}^R</script></td><td>\int<em>{\theta=0}^{2\pi}    \int</em>{r=0}^R</td></tr><tr><td>$\nabla$</td><td>\nabla</td></tr><tr><td>$\partial$</td><td>\partial</td></tr><tr><td>$\forall$</td><td>\forall</td></tr><tr><td>$\exists$</td><td>\exists</td></tr><tr><td><script type="math/tex">\wedge</script></td><td>\wedge</td></tr><tr><td><script type="math/tex">\vee</script></td><td>\vee</td></tr><tr><td><script type="math/tex">\neg</script></td><td>\neg</td></tr><tr><td></td><td></td></tr><tr><td>$\subset$</td><td>\subset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\in$</td><td>\in</td></tr><tr><td>$\notin$</td><td>\notin</td></tr><tr><td>$\emptyset$</td><td>\emptyset</td></tr><tr><td>$\varnothing$</td><td>\varnothing</td></tr><tr><td>$\bigcup$</td><td>\bigcup</td></tr><tr><td>$\cup$</td><td>\cup</td></tr><tr><td>$\bigcap$</td><td>\bigcap</td></tr><tr><td>$\cap$</td><td>\cap</td></tr><tr><td></td><td></td></tr><tr><td>$\frac{a+1}{b+1}$</td><td>分数    \frac{a+1}{b+1}</td></tr><tr><td>$\sqrt{x^5}$</td><td>开方      \sqrt{x^5}</td></tr><tr><td>$\sqrt[3]{xy}$</td><td>开方       \sqrt[3]{xy}</td></tr><tr><td></td><td></td></tr><tr><td>$\le$</td><td>\le</td></tr><tr><td>$\geq$</td><td>\geq</td></tr><tr><td>$\neq$</td><td>\neq</td></tr><tr><td>$\approx$</td><td>\approx</td></tr><tr><td>$\equiv$</td><td>\equiv</td></tr><tr><td>$\pm$</td><td>\pm</td></tr><tr><td>$\mp$</td><td>\mp</td></tr><tr><td>$\mathbb{R}$</td><td>将字母改为黑板字体\mathbb{R}</td></tr><tr><td>$\mathcal{B}$</td><td>\mathcal{B}</td></tr><tr><td>$\leftarrow$</td><td>\leftarrow</td></tr><tr><td>$\rightarrow$</td><td>\rightarrow</td></tr><tr><td><script type="math/tex">\Leftarrow</script></td><td>\Leftarrow</td></tr><tr><td><script type="math/tex">\Rightarrow</script></td><td>\Rightarrow</td></tr><tr><td><script type="math/tex">\sim</script></td><td>\sim</td></tr><tr><td>$\odot$</td><td>\odot</td></tr><tr><td>$\perp$</td><td>独立符号\perp</td></tr><tr><td><script type="math/tex">\propto</script></td><td>正比符号\propto</td></tr></tbody></table></div><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><script type="math/tex; mode=display">\begin{aligned}the \ first \ row \\the \ second \ row\end{aligned}</script><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\begin&#123;aligned&#125;</span><br>the <span class="hljs-string">\</span> first <span class="hljs-string">\</span> row <span class="hljs-string">\\</span><br>the <span class="hljs-string">\</span> second <span class="hljs-string">\</span> row<br><span class="hljs-string">\end&#123;aligned&#125;</span><br><br><span class="hljs-comment"># 若要居中对齐，则把aligned改为gather</span><br>$$<br></code></pre></td></tr></table></figure><h3 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h3><script type="math/tex; mode=display">f(x) = \begin{cases}1 & x = 2\\2 & x > 2\\3 & x \leqslant 2\\\end{cases}</script><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br>f(x) = <span class="hljs-string">\begin&#123;cases&#125;</span><br><span class="hljs-number">1</span> &amp; x = <span class="hljs-number">2</span> <span class="hljs-string">\\</span><br><span class="hljs-number">2</span> &amp; x &gt; <span class="hljs-number">2</span> <span class="hljs-string">\\</span><br><span class="hljs-number">3</span> &amp; x <span class="hljs-string">\leqslant</span> <span class="hljs-number">2</span><span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;cases&#125;</span><br>$$<br></code></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><script type="math/tex; mode=display">\begin{matrix}1 & 2 \\3 & 4 \end{matrix}</script><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;matrix&#125;<br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> \\<br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br>\<span class="hljs-keyword">end</span>&#123;matrix&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{pmatrix}1 & 2 \\3 & 4 \end{pmatrix}</script><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;pmatrix&#125;<br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> \\<br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br>\<span class="hljs-keyword">end</span>&#123;pmatrix&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\3 & 4 \end{bmatrix}</script><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;bmatrix&#125;<br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> \\<br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br>\<span class="hljs-keyword">end</span>&#123;bmatrix&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{Bmatrix}1 & 2 \\3 & 4 \end{Bmatrix}</script><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;Bmatrix&#125;<br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> \\<br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br>\<span class="hljs-keyword">end</span>&#123;Bmatrix&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{vmatrix}1 & 2 \\3 & 4 \end{vmatrix}</script><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;vmatrix&#125;</span><br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span><br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br><span class="hljs-string">\end&#123;vmatrix&#125;</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{Vmatrix}1 & 2 \\3 & 4 \end{Vmatrix}</script><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;Vmatrix&#125;</span><br><span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span> <span class="hljs-string">\\</span><br><span class="hljs-number">3</span> &amp; <span class="hljs-number">4</span> <br><span class="hljs-string">\end&#123;Vmatrix&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
