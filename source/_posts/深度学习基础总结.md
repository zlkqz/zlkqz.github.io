---
title: 深度学习基础总结
math: true
date: 2021-10-15
---



# 1 行业知识体系

### 1.1 机器学习算法

![qq_pic_merged_1635482805011](https://i.loli.net/2021/10/31/romyfLZ5KjP9a3B.jpg)



### 1.2 机器学习分类

![qq_pic_merged_1635482964705](https://i.loli.net/2021/10/31/7Lvd8NIsezYm1Qy.jpg)





# 2 线性回归

### 2.1 基本概念

![image-20211029131504886](https://i.loli.net/2021/10/31/ChVyXvJetFWN5Y8.png)

- 线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析

- 线性回归输出是⼀个连续值，因此适⽤于回归问题



### 2.2 损失函数

- **均方差（mse）：**

$$
\ell^{(i)}(W, b) = \frac{(\hat{y}^{(i)} - y^{(i)})^2}{2}
$$

其中$\hat{y}$为计算出的预测值，$y$为真实值（label）





# 3  全连接层（稠密层）

- 输出层中的神经元和输⼊ 层中各个输⼊完全连接
- 计算完全依赖于输入层。





# 4  小批量随机梯度下降

- 在每次迭代中，先随机均匀采样⼀个由固定数⽬训练数据样本所组成的小批量（mini-batch）$\mathbb{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后⽤此结果与预先设定的⼀个正数的乘积（学习率$\eta$）作为模型参数在本次迭代的减小量。

- 每次mini-batch梯度下降计算过程：

$$
w_1 = w_1 - \frac{\eta}{|\mathbb{B}|}\sum_{i \in \mathbb{B}}\frac{\partial{\ell(...)}}{\partial{w_1}}
$$

- 注意学习率要取正数





# 5  Softmax分类

### 5.1 基本概念

- softmax回归跟线性回归⼀样将输⼊特征与权重做线性叠加。与线性回归的⼀个主要不同在于， softmax回归的输出值个数等于标签⾥的类别数
- 由于输出元有多个，所以我们要讲输出做softmax计算，得到的结果作为该类的概率，具体计算如下：

假设输出元有3个，输出值分别为$o_1, o_2, o_3$， 则:
$$
\hat{y}_1, \hat{y}_2, \hat{y}_3 = softmax(o_1, o_2, o_3)
$$
其中
$$
\hat{y}_i = \frac{e^{o_i}}{\sum_{j = 1}^{3}e^{o_j}}
$$

- 容易看出$\sum_{i = 1}^{3}y_i = 1$（即所有概率加起来等于1）
- 通常，我们把预测概率最⼤的类别作为输出类别



### 5.2 损失函数

- 这里我们运用交叉熵损失函数（cross entropy）：

$$
H(y^{(i)}, \hat{y}^{(i)}) = -\sum_{j = 1}^qy_j^{(i)}\log{\hat{y}^{(i)}}
$$

q为输出元个数$\times$样本个数，即所有样本的所有输出元都要参与运算，最后求平均值





# 6 多层感知机（MLP）

- 多层感知机有一到多个隐藏层
- 多层感知机中的隐藏层和输出层都是全连接层
- 多层感知机具有激活函数，下面介绍常用激活函数





# 7 激活函数

### 7.1 Sigmoid函数

$$
sigmoid(x) = \frac{1}{1 + e^{-x}}
$$

$$
sigmoid'(x) = sigmoid(x)(1 - sigmoid(x))
$$

![image-20211030004640247](https://i.loli.net/2021/10/31/2JsDXo9mQtI6rzM.png)

- 一般用在二分类的输出层中



### 7.2 tanh函数

$$
tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}}
$$

$$
tanh'(x) = 1 - tanh^2(x)
$$

![image-20211030005138300](https://i.loli.net/2021/10/31/rdx3sEtVFGlHink.png)

- tanh和sigmoid比较相似，但是性能一般要优于sigmoid



### 7.3 ReLU函数

$$
ReLU(x) = max(0, x)
$$

![image-20211030005121490](https://i.loli.net/2021/10/31/6Ioqb3OBldsCuS8.png)

- 十分常用



### 7.4 Leaky ReLU函数

$$
Leaky\_Relu(x) = max(0.1 * x, x)
$$

![image-20211030005818507](https://i.loli.net/2021/10/31/qA4w6a7Irj3WEJg.png)





# 8 训练误差和泛化误差

### 8.1 基本概念

- **训练误差：**指模型在训练数据集上表现出的误差
- **泛化误差：**指模型在任意⼀个测试数据样本上表现出的误差的期望




### 8.2 k折交叉验证

- 当训练数据不够⽤时，预留⼤量的验证数据显得太奢侈，这时候就可以运用k折交叉验证法
- 即我们把原始训练数据 集分割成k个不重合的⼦数据集，然后我们做k次模型训练和验证。每⼀次，我们使⽤⼀个子数据集验证模型，并使⽤其他k − 1个⼦数据集来训练模型，最后，我们对这k次训练误差和验证误差分别求平均。



### 8.3 欠拟合和过拟合

- **欠拟合：**训练误差过高

- **过拟合：**泛化误差过高

- 我们知道进行反向传播的目的是让学习器去拟合数据，而当拟合程度不够时就称为**欠拟合**，拟合程度过于高时则称为**过拟合**，用下图可以很好的解释：

  <img src="https://i.loli.net/2021/11/11/npR3aNjrLOISQC8.png" alt="image-20211111215618245"  />

- 欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了，**可以使用early stop来防止训练时间不足导致的欠拟合**。但是如果真的还是存在的话，可以通过**增加网络复杂度**或者在模型中**增加特征**，这些都是很好解决欠拟合的方法。而一般我们更加关注的是如何如何防止过拟合



### 8.4 造成过拟合的原因

- **训练数据集样本单一，样本不足**。如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型
- **训练数据中噪声干扰过大**。噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系
- **模型过于复杂。**模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。
> - 模型太复杂是过拟合的重要因素，下面提到的正则化方法和Dropout方法都是基于减少模型复杂度来进行的。
> - 另外，在模型设计方面有一个根本设计原则**奥卡姆剃刀法则：优先选择拟合数据的最简单的假设。 简单的模型才是最好的**
> - **当模型复杂度过高的时候，拟合函数的系数往往非常大，需要顾忌每一个点，最终形成的拟合函数波动很大**，如上图过拟合情况。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的梯度非常大，所以才需要惩罚项来降低
> - **模型复杂度也可以解释为：模型对某些非必要的特征过于看重（即给予了较大的权值）**



### 8.5 对应过拟合手段

#### 8.5.1 增加数据

- 由于**数据量不足是造成过拟合的根本原因**，所以对应过拟合最有效的手段肯定是增大数据集，但是这种方法成本过高
- 在数据层面，还可以进行**数据增强**，创造一些假数据，还可以提升模型的泛化能力
- 在CV方面常用的数据增强有旋转图像、缩放图像、随机裁剪等，而在NLP方面还有同义词替换、随机删除词、随机颠倒句子顺序等方法



#### 8.5.2 正则化

- L2范数惩罚项指的是模型权重参数每个元素的平⽅和与⼀个正的常数的乘积
- 损失函数添加一个L2惩罚项：

$$
\ell(...) + \frac{\lambda}{2}\begin{Vmatrix} W \end{Vmatrix}^2
$$

求导后：（每个mini-batch）
$$
w1 = (1 - \eta\lambda)w1 - \frac{\eta}{|\mathbb{B}|}\sum_{i \in \mathbb{B}}\frac{\partial\ell^{(i)}(...)}{\partial{w1}}
$$
其中超参数$\lambda$ > 0。当权重参数均为0时，惩罚项最小。当$\lambda$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda$设为0时，惩罚项完全不起作⽤。

- 除此之外还有L1正则化，使用L1范数作为惩罚项：

$$
\ell(...) + \frac{\lambda}{2}\begin{Vmatrix} W \end{Vmatrix}
$$

- 一般训练集中的损失函数要加惩罚项，测试集中不用
- 正则化的原理可以从**拉格朗日乘子法和最大后验概率估计**两方面解释
- 首先是拉格朗日乘子法：

> - 设模型本来的优化目标为：
>
> $$
> \min _{w} J(w ; X, y)
> $$
>
> - 而过拟合的原因在于模型复杂度过高，而一般模型复杂度和参数$$w$$的稀疏度相关，即**参数越少或参数中0的个数越多，模型复杂度越小**
> - 那么0的个数可以让我们联想到**w的L0范数（代表w中非零元素的个数）**，那么可以**添加一个约束，使得优化目标变为：**
>
> $$
> \begin{array}{c}
> \min _{w} J(w ; X, y) \\
> s \cdot t .\|w\|_{0} \leq C
> \end{array}
> $$
>
> - 但是**使用L0范数太过困难，主要是L0范数无法进行求导来反向传播，所以我们退而求其次，要求权重w向量中某些维度的非零参数尽可能接近于0，尽可能的小，所以就可以使用L1、L2范数：**
>
> $$
> \begin{array}{c}
> \min _{w} J(w ; X, y) \\
> s \cdot t .\|w\|_{1} \leq C 或 s \cdot t .\|w\|_{2} \leq C 
> \end{array}
> $$
>
> - 以L2正则化为例，采用拉格朗日乘子法，其拉格朗日函数为：
>
> $$
> \min _{w} J(w ; X, y)+\alpha^{*}\|w\|_{2}^{2}
> $$
>
> - 这就是现在的优化目标，而后面的一项恰好就是惩罚项

- 还可以用最大后验概率估计来解释：

> - 最大后验估计的优化目标是：
>
> $$
> M A P=\log P(y \mid X, w) P(w)=\log P(y \mid X, w)+\log P(w)
> $$
>
> - 上式左边的一项即最大化似然的优化目标，也就是本来的不加惩罚项的优化目标；**而右边的一项仅关于参数w的先验分布**
> - 我们对w的先验分布进行不同的假设，即可得到不同的惩罚项
> - **在L2正则化中，假设$$w \sim N(0, \sigma^2)$$，那么有：**
>
> $$
> \begin{array}{l}
> \log P(w)=\log \prod_{j} P\left(w_{j}\right)= \\
> \log \prod_{j}\left[\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{\left(w_{j}\right)^{2}}{2 \sigma^{2}}}\right] \\
> =-\frac{1}{2 \sigma^{2}} \sum_{j} w_{j}^{2}+C
> \end{array}
> $$
>
> 那么就得到了L2范数作为惩罚项
>
> - **L1正则化也一样，假设$$w$$服从均值为0参数为a的拉普拉斯分布，那么有：**
>
> $$
> \begin{array}{l}
> \log P(w)=\log \prod_{j} P\left(w_{j}\right)= \\
> \log \prod_{j}\left[\frac{1}{\sqrt{2 a} \sigma} e^{-\frac{w_{j}}{a}}\right] \\
> =-\frac{1}{2 a} \sum_{j}\left|w_{j}\right|+C
> \end{array}
> $$



#### 8.5.2 丢弃法（Dropout）

- 对于每一层的神经元，有一定的概率被丢弃掉，设丢弃概率为p，计算新的单元：

$$
h_i' = \frac{\xi_i}{1 - p}h_i
$$

$\xi_i$为0和1的概率分别为p和1 - p

分母中的1- p是为了不改变其输⼊的期望值：
$$
由于E(\xi_i) = 1 - p \\
所以E(h_i') = \frac{E(\xi_i)}{1 - p}h_i = h_i
$$

- 测试模型时，我们为了得到更加确定性的结果，⼀般不使⽤丢弃法

- 进行了Dropout的多层感知机：

![image-20211030141251677](https://i.loli.net/2021/10/31/CnUgmA4dVb8vFR2.png)

可以看到隐藏层中的$h_2$和$h_5$消失了

- 每一层的丢弃概率可以不同，通常把靠近输⼊层的丢弃概率设得小⼀点

- **Dropout的原理：**

> 1. **集成学习：**每次随机置0都可以得到一个新模型，而Dropout可以当作对这些所有新得到的模型的集成
> 2. **正则化：**因为Dropout导致两个神经元不一定每次都在一个dropout网络中出现，这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 ，迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。正因为这样，网络由于不知道浅层的哪些神经元会失活，导致网络不敢赋予浅层神经元太大的权重，这样就减轻了网络对某些局部特征的依赖，换句话说网络不会对一些特定的线索片段太过敏感，即使丢失特定的线索，它也可以从众多其它线索中学习一些共同的特征。从这个角度看Dropout就类似于L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。



# 9 正向传播和反向传播

### 9.1 正向传播

- 正向传播（forward propagation）是指对神经⽹络沿着从输⼊层到输出层的顺序，依次计算并存储模型的中间变量（包括输出）
- 中间变量称为缓存，在反向传播中会用到，避免重复计算，如每层的输出值等
- 正向传播的计算图：

![image-20211030142019713](https://i.loli.net/2021/10/31/4LnFKkrSQHsUYNv.png)

其中：

1. 左下⻆是输⼊，右上⻆是输出
2. ⽅框代表变量，圆圈代表运算符
3. $J = L + s$，$J$称为目标函数，$L$为损失函数，$s$为惩罚项



### 9.2 反向传播

- 反向传播最重要的是通过链式法则求导，从后往前进行计算
- 反向传播的梯度计算可能依赖于各变量的当前值，而这些变量的当前值是通过正向传播计算得到的



### 9.3 衰减和爆炸

- 如果隐藏层的层数很大，$H(l)$的计算可能会出现衰减或爆炸，如：

假设输⼊和所有层的权重参数都是标量，如权重参数为0.2和5，多层感知 机的第30层输出为输⼊X分别与0.2 30 ≈ 1 × 10−21（衰减）和5 30 ≈ 9 × 1020（爆炸）的乘积



### 9.4 随机初始化参数

- 考虑三种参数的极端情况：

> 1. **参数很稀疏，那么输入的特征会在经过前向计算后逐渐消失（计算出来都接近0）**
> 2. **参数很大，输出值容易进入激活函数的饱和区，比如Sigmoid函数**
> 3. 假设将每个隐藏单元的参数都初始化为相等的值，那么在正向传播时每个隐藏单元将根据相同的输⼊计算出相同的值， 并传递⾄输出层。在反向传播中，每个隐藏单元的参数梯度值相等。因此，这些参数在使⽤基于梯度的优化算法迭代后值依然相等。**在这种情况下，无论隐藏单元有多少， 隐藏层本质上只有1个隐藏单元在发挥作用**

- 可以看出，我们**希望每一层的输出方差能够固定**，因为这样能够防止我们的信号变得很大/直接消失。换句话来说，**我们需要一种权重初始化的手段，使得输入、输出的方差保持不变，**这就是Xavier初始化做的事。



### 9.5 Xavier随机初始化

- 假设某层的参数，前一层神经元个数为a，后一层神经元个数为b，Xavier随机初始化将使该层中权重参数的每个元素都随机采样于均匀分布：

$$
U(-\sqrt{\frac{6}{a + b}}, \sqrt{\frac{6}{a + b}})
$$

- 该设计主要为了**在前向计算的时候，经过此层的参数后得到的输出方差不变（即输入输出方差相等）；并且在反向计算的时候，后一层的梯度和前一层的梯度方差也相等**

- **Xavier初始化在sigmoid和tanh激活函数上有很好的表现，但是在Relu激活函数上表现很差。**

- 现在开始推导，这里只展示前向计算时，首先是有3个假设：

> - 激活函数为$$f(x) = x$$
> - 偏置项b初始化为0
> - 输入和参数的期望都为0

- 设某一层值为$$x$$，参数为$$w$$，对应输入为$$y = x^Tw$$（注意$$x,w$$为向量，$$y$$为标量），那么我们的目的是：

$$
Var[y] = Var[x] \\
Var[x^Tw] = Var[x]
$$

- 引入公式：

$$
Var[XY] = E[X^2]E[Y^2] - E^2[X]E^2[Y] \\
在E[X] = E[Y]时，可以得出： Var[XY] = Var[X]Var[Y]
$$

- 而由于$$E[w] = E[x] = 0$$，所以：

$$
Var[x] = Var[x^Tw] = Var[\sum^{N}_ix_iw_i] = N* Var[x]Var[w]
$$

其中$$N = dim(x) = dim(w)$$，即当前层的神经元个数

- 由上式可以得出：

$$
N * Var[w] = 1 \\
Var[w] = \frac{1}{N}
$$

- 而在反向传播的时候，我们同样可以推出$$Var[w] = \frac{1}{N'}$$，其中$$N'$$为下一层神经元个数
- 而由于方差取值无法同时满足前后向，所以采用两者的平均数：

$$
Var[w] = \frac{2}{N + N'}
$$

- 我们可以通过$$N(0, \frac{2}{N+N'})$$对w取样，也可以使用均匀分布采样，采用均匀函数的时候需要进行一定的放缩（Var[w]的分子不一定为2）